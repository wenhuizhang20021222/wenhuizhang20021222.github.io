<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/06/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<span id="more"></span>

<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>os绪论</title>
    <url>/2022/06/23/os%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="一、操作系统绪论"><a href="#一、操作系统绪论" class="headerlink" title="一、操作系统绪论"></a>一、操作系统绪论</h1><h2 id="x3D-x3D-重点考察概念-x3D-x3D"><a href="#x3D-x3D-重点考察概念-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;重点考察概念&#x3D;&#x3D;"></a>&#x3D;&#x3D;重点考察概念&#x3D;&#x3D;</h2><p>操作系统的定义，操作系统在计算机系统中的地位，操作系统的主要功能，资源复用、虚化、抽象，操作系统的特征，多道程序设计，并发，中断，系统调用，CPU 的两种工作模式（用户态、内核态），特权指令和非特权指令 </p>
<h2 id="1、操作系统概念、功能及提供的接口"><a href="#1、操作系统概念、功能及提供的接口" class="headerlink" title="1、操作系统概念、功能及提供的接口"></a>1、操作系统概念、功能及提供的接口</h2><p><strong>操作系统的概念</strong>：管理计算机硬件并提供应用程序运行环境的软件。操作系统是配置在计算机硬件上的第一层软件，是对硬件的首次扩充，形成了虚拟计算机&#x2F;扩展机。它位于硬件与其它软件之间，是所有其他软件运行的基础。</p>
<span id="more"></span>

<p><strong>操作系统的作用：</strong></p>
<p><strong>用户视角：</strong> 操作系统是用户与计算机硬件之间的接口。为用户使用计算机提供服务。</p>
<p><strong>系统视角：</strong> </p>
<ul>
<li>&#x3D;&#x3D;资源管理器&#x3D;&#x3D; ：管理计算机系统的软硬件资源。<strong>资源复用、资源虚化以及资源抽象</strong> 。<ul>
<li>资源复用：分为时间复用和空间复用。时间复用指的是多个用户或程序轮流使用某个资源，如CPU使用；空间复用指的是多个用户或程序同时使用资源的一部分，如内存使用。</li>
<li>资源虚化：让一个物理设备变成多个相对独立的对应物</li>
<li>资源抽象：对内封装细节，对外通过管理对象与访问接口，如：面向进程而不是CPU，面向文件而不是物理存储介质，面向窗口而不是屏幕</li>
<li>&#x3D;&#x3D;复用与虚拟化解决的是资源不足的问题。资源抽象解决的是资源复杂的问题。&#x3D;&#x3D;</li>
</ul>
</li>
<li>&#x3D;&#x3D;控制程序&#x3D;&#x3D; ：控制程序执行过程，防止错误和计算机的不当使用</li>
</ul>
<p><img data-src="https://s2.loli.net/2022/05/13/msaGykqzLiVtrDT.png" alt="image-20220513191418134"></p>
<p><img data-src="https://s2.loli.net/2022/05/13/HKJvnRhTVw89bdC.png" alt="image-20220513193433159"></p>
<p><img data-src="https://s2.loli.net/2022/05/13/AQW3CRkS6fHpBNw.png" alt="image-20220513192502110"></p>
<p><img data-src="https://s2.loli.net/2022/05/13/LiEpfK6Awz8WFvs.png" alt="image-20220513193123123"></p>
<p>联机命令接口 &#x3D; 交互命令接口，如命令行</p>
<p>脱机命令接口 &#x3D; 批处理命令接口，如*.bat文件</p>
<p>程序接口：如dll文件，调用dll文件即可进行系统调用，只能通过应用程序间接使用</p>
<h2 id="2、操作系统的特征"><a href="#2、操作系统的特征" class="headerlink" title="2、操作系统的特征"></a>2、操作系统的特征</h2><ul>
<li><p><strong>并发性：</strong> 多个事件在同一事件间隔内发生（并行：同一时刻）。并发的实质是一个物理CPU(也可以多个物理CPU) 在若干道程序之间多路复用，并发性是对有限物理资源强制行使多用户共享以提高效率。</p>
</li>
<li><p><strong>共享性：</strong> 系统中的资源可供多个并发执行的进程共同使用。有两种资源共享方式：</p>
<ul>
<li>互斥共享：一段时间只允许一个进程访问。如对摄像头设备的共享使用</li>
<li>同时访问：一段时间允许多个进程访问。如对硬盘资源的共享使用</li>
</ul>
<p>  &#x3D;&#x3D;并发和共享是操作系统的两个最基本特征，二者之间互为存在条件。&#x3D;&#x3D; </p>
</li>
<li><p><strong>虚拟性：</strong> 把一个物理上的实体变为若干个逻辑上的对应物；或把物理上的多个实体变成逻辑上的一个对应物的技术。eg.虚拟存储器</p>
<ul>
<li><p>空分复用技术：如虚拟存储技术</p>
</li>
<li><p>时分复用技术：如虚拟处理器技术</p>
<p>  并发性是虚拟性存在的基础</p>
</li>
</ul>
</li>
<li><p><strong>异步性（或不确定性）：</strong> 多个作业的执行过程是走走停停的，其执行顺序和每个作业的执行时间是不确定的。</p>
</li>
</ul>
<h2 id="3、操作系统的发展与分类"><a href="#3、操作系统的发展与分类" class="headerlink" title="3、操作系统的发展与分类"></a>3、操作系统的发展与分类</h2><p><img data-src="https://s2.loli.net/2022/05/13/3AWQXpLSTGkobFC.png" alt="image-20220513201053867"></p>
<p>批处理技术是指计算机系统对一批作业自动进行处理的一种技术。</p>
<p>分类：</p>
<ul>
<li>联机批处理：采用联机输入&#x2F;输出，即输入&#x2F;输出操作在监督程序控制下，同步进行。 缺点：速度慢 </li>
<li>脱机批处理：外围机：独立于主机，负责把作业任务写入磁带，以及从磁带输出到打印机。主机：负责从磁带上把作业调入内存，或者把结果写回磁带。实现了部分异步能力、减少了CPU的空闲时间、提高了I&#x2F;O速度</li>
</ul>
<hr>
<p>多道程序设计：</p>
<ul>
<li><strong>核心思想：</strong> 将多个作业存放在主存中，这些程序在管理程序的控制下交替运行，共享处理机和系统中的其他资源。即通过安排作业（编码与数据）&#x3D;&#x3D;使得CPU无论何时都有进程执行，从而最大化CPU利用率&#x3D;&#x3D; </li>
<li>没有提供用户与计算机系统的交互</li>
<li>多道程序宏观上并行，微观上串行</li>
<li>多道程序设计的道数不是任意的</li>
<li><strong>优缺点：</strong> <ul>
<li>提高了CPU的利用率</li>
<li>提高了内存和I&#x2F;O设备的利用率</li>
<li>改进了系统的吞吐率</li>
<li>充分发挥了系统的并行性</li>
<li>其主要缺点是: 作业周转时间延长</li>
</ul>
</li>
<li>**多重处理系统:   ** 指配置了多个物理CPU，能真正同时执行多道程序的系统。</li>
</ul>
<hr>
<p>&#x3D;&#x3D;操作系统的三种基本类型：批处理操作系统、分时操作系统、实时操作系统&#x3D;&#x3D; </p>
<p>分时系统：允许多个联机用户同时使用一台计算机系统进行计算的操作系统称分时操作系统</p>
<p><strong>分时技术：</strong> 把处理机的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。</p>
<p>是多道程序设计的自然延伸</p>
<p>采用调度算法，以快速切换作业，好像每个作业同时执行</p>
<p><strong>特征：</strong> </p>
<ul>
<li>多路性：也称同时性，一台计算机与若干台终端相连接，终端上的这些用户可以同时使用计算机。</li>
<li>交互性：用户通过终端采用人机会话的方式直接控制程序运行，同程序进行交互。</li>
<li>独立性：用户彼此之间都感觉不到别人也在使用这台计算机，好像只有自己独占计算机一样。</li>
<li>及时性：用户请求能在很短时间内获得响应。</li>
</ul>
<h2 id="4、操作系统的运行机制与体系结构"><a href="#4、操作系统的运行机制与体系结构" class="headerlink" title="4、操作系统的运行机制与体系结构"></a>4、操作系统的运行机制与体系结构</h2><p><img data-src="https://s2.loli.net/2022/05/13/uCvXRb5ixgc4ep9.png" alt="image-20220513203343485"></p>
<blockquote>
<p>用程序状态字寄存器（PSW， program status word）中的某标志位来标识当前处理器处于什么状态。如0为用户态，1为核心态</p>
</blockquote>
<hr>
<p>内核是操作系统的构件，或称基本单位。 </p>
<p>内核作用：  为进程提供管理 、为进程执行提供良好的运行环境</p>
<p>&#x3D;&#x3D;基本功能:&#x3D;&#x3D;  </p>
<ul>
<li>中断处理：截获中断，转向中断处理例程</li>
<li>短程调度：CPU调度，保存与恢复现场</li>
<li>原语管理：原语是不可中断过程</li>
</ul>
<p>&#x3D;&#x3D;基本属性:&#x3D;&#x3D; </p>
<ul>
<li>内核是由中断驱动的</li>
<li>内核的执行是连续的</li>
<li>内核在屏蔽中断状态下执行</li>
<li>内核可以使用特权指令</li>
</ul>
<p>&#x3D;&#x3D;分类：&#x3D;&#x3D;</p>
<ul>
<li><p><strong>模块结构（整体式结构）</strong>：将内核划分为一个个独立的模块，模块之间相互调用。效率高但是结构不清晰，访问控制困难</p>
</li>
<li><p><strong>层次结构</strong>：一种特殊的模块结构。将内核划分为一系列相互依赖的层次，每个层次也可以分解为一系列更小的模块。</p>
<p>  <img data-src="https://s2.loli.net/2022/03/04/2PkGeSmIBXyOTai.png"></p>
</li>
<li><p><strong>微内核结构</strong></p>
</li>
</ul>
<p><img data-src="https://s2.loli.net/2022/05/13/OzmplexJuwFcj24.png" alt="image-20220513202231353"></p>
<p><img data-src="https://s2.loli.net/2022/05/13/7S4E6d3gHUeNlpI.png" alt="image-20220513202617422"></p>
<h2 id="5、中断和异常"><a href="#5、中断和异常" class="headerlink" title="5、中断和异常"></a>5、中断和异常</h2><p><img data-src="https://s2.loli.net/2022/05/13/ojrdODLXqEezi3G.png" alt="image-20220513205554625"></p>
<p>&#x3D;&#x3D;用户态 → 核心态是通过中断实现的，并且中断是唯一途径&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;核心态 → 用户态的切换是通过执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态”&#x3D;&#x3D;</p>
<p><img data-src="https://s2.loli.net/2022/05/13/twndlTegkLJ6x9X.png" alt="image-20220513205029547"></p>
<p><img data-src="https://s2.loli.net/2022/05/13/EYTzjIOvW7drqfx.png" alt="image-20220513205136837"></p>
<p><strong>外中断的处理过程：</strong></p>
<p><img data-src="https://s2.loli.net/2022/05/13/oRmXYrNvBUkTgfI.png" alt="image-20220513205420243"></p>
<h2 id="6、系统调用"><a href="#6、系统调用" class="headerlink" title="6、系统调用"></a>6、系统调用</h2><p><img data-src="https://s2.loli.net/2022/05/13/xzmwb1KdrT5MIsp.png" alt="image-20220513213014300"></p>
<p>系统调用是操作系统提供给应用程序（程序员&#x2F;编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。</p>
<p>系统调用与库函数的区别：</p>
<p><img data-src="https://s2.loli.net/2022/05/13/tK9mNhM6OdzepCP.png" alt="image-20220513211951839"></p>
<p>系统调用背后的过程：</p>
<p><img data-src="https://s2.loli.net/2022/05/13/obNKP1RrQt9sBuV.png" alt="image-20220513212751507"></p>
<p>中断、异常和系统调用：</p>
<table>
<thead>
<tr>
<th></th>
<th>产生原因</th>
<th>实现机制</th>
<th>区别</th>
<th>保存地址</th>
<th>处理</th>
</tr>
</thead>
<tbody><tr>
<td><strong>中断</strong></td>
<td>由定时器和I&#x2F;O设备产生（来自硬件设备的处理请求）</td>
<td>中断机制</td>
<td>①由与现行指令无关的中断信号触发的(异步的)；②中断的发生与CPU处在用户模式或内核模式无关，系统不能确定中断发生的时间 ；③一般来说，中断处理程序提供的服务不是为当前进程所需的</td>
<td>保存的是下一条指令的地址，以便在指令结束后检测有没有中断</td>
<td><strong>硬件和软件结合</strong> 。①定时器：定时器是OS回收控制的重要方式，可设置为在指定周期（固定或可变）后中断计算机。防止用户程序陷入死循环，或不调用系统服务并且不将控制返回给操作系统。在将控制交到用户之前，操作系统确保定时器已设置好以便产生中断；②中断装置（发生中断源并产生中断的<strong>硬件</strong> ）：发现中断源、保护现场、启动中断处理程序（IDTR寄存器中存放了中断描述符表在内存的起始地址）；③中断处理程序： 保护未被硬件保护的一些必需的处理状态 （CPU自动保存的只有EIP&#x2F;EFLAGS&#x2F;ESP&#x2F;SS&#x2F;CS） ；识别各个中断源，分析产生中断的原因；处理中断事件；恢复正常操作；④OS必须保证中断前后的同步性，必须保证现场保护的原子性（保护现场的过程不能被中断）</td>
</tr>
<tr>
<td><strong>异常</strong></td>
<td>由程序错误产生，或者由内核必须处理的异常条件产生</td>
<td>中断机制</td>
<td>① 由处理器正在执行现行指令而引起的； ②异常处理程序提供的服务是为当前进程所用的；③异常包括出错、陷入、终止和编程异常等等；④异常通常由意想不到的行为触发</td>
<td>出错保存的是当前指令的地址，陷入保存的是下一条指令的地址</td>
<td>①由硬件检测并处理（如除0）；②硬件自身出错产生的异常：通常会在检测错误之后重新执行该指令，CPU保存运行状态；③有些异常是修复后返回并重新执行出错的指令（如页错误）；有些异常是OS通知相应进程；④异常发生在内核会导致OS崩溃</td>
</tr>
<tr>
<td><strong>系统调用</strong></td>
<td>程序主动请求操作系统服务</td>
<td>通常通过一种特殊的异常来实现</td>
<td>程序主动请求系统服务</td>
<td>保存的是下一条指令的地址</td>
<td>提供给用户态程序执行特权操作的接口；触发事件，切换至内核态；传递系统调用的参数； 保存状态以便完成系统调用后恢复执行</td>
</tr>
</tbody></table>
<h2 id="7、-x3D-x3D-可能的大题：多道程序运行、简答题-x3D-x3D"><a href="#7、-x3D-x3D-可能的大题：多道程序运行、简答题-x3D-x3D" class="headerlink" title="7、&#x3D;&#x3D;可能的大题：多道程序运行、简答题&#x3D;&#x3D;"></a>7、&#x3D;&#x3D;可能的大题：多道程序运行、简答题&#x3D;&#x3D;</h2><h3 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h3><p>计算作业完成时间，CPU或者I&#x2F;O设备的利用率等等</p>
<p>资源利用率：CPU利用率 &#x3D; CPU有效工作时间&#x2F;CPU总的运行时间， CPU总的运行时间 &#x3D; CPU有效工作时间+CPU空闲等待时间。</p>
<p>I&#x2F;O设备的利用率同理。</p>
<p>&#x3D;&#x3D;注意考虑优先级以及是否能够抢占&#x3D;&#x3D;</p>
<p><strong>（1）</strong>在单CPU和两台I&#x2F;O(I1,I2)设备的多道程序设计环境下，同时投入三个作业运行。它们的执行轨迹如下：</p>
<p>Job1：I2(30ms)、CPU(10ms)、I1(30ms)、CPU(10ms)</p>
<p>Job2：I1(20ms)、CPU(20ms)、I2(40ms)</p>
<p>Job3：CPU(30ms)、I1(20ms)</p>
<p>如果CPU、I1和I2都能并行工作，优先级从高到低为Job1、Job2和Job3，优先级高的作业可以抢占优先级低的作业的CPU。试求：(1)每个作业从投入到完成分别所需的时间。(2) 每个作业投入到完成CPU的利用率。(3)I&#x2F;O设备利用率。</p>
<p><strong>答：</strong>画出三个作业并行工作图如下(图中着色部分为作业等待时间)：</p>
<p><img data-src="https://s2.loli.net/2022/05/14/FxBnaZuVIQ8Nhe7.png" alt="img"></p>
<p>(1) Job1从投入到运行完成需80ms，Job2从投入到运行完成需90ms，Job3从投入到运行完成需90ms。</p>
<p>(2) CPU空闲时间段为：60ms至70ms，80ms至90ms。所以CPU利用率为(90-20)&#x2F;90&#x3D;77.78%。</p>
<p>(3) 设备I1空闲时间段为：20ms至40ms，故I1的利用率为(90-20)&#x2F;90&#x3D;77.78%。设备I2空闲时间段为：30ms至50ms，故I2的利用率为(90-20)&#x2F;90&#x3D;77.78%。</p>
<p>2、 若内存中有3道程序A、B、C，它们按A、B、C优先次序运行（不考虑强占）。各程序的计算轨迹为：</p>
<p>A：计算(20)、I&#x2F;O(30)、计算(10) </p>
<p>B：计算(40)、I&#x2F;O(20)、计算(10)</p>
<p>C：计算(10)、I&#x2F;O(30)、计算(20)</p>
<p>如果三道程序都使用相同设备进行I&#x2F;O(即程序用串行方式使用设备，调度开销忽略不计)。试分别画出单道和多道运行的时间关系图。两种情况下，CPU的平均利用率各为多少?</p>
<p><strong>答</strong>：分别画出单道和多道运行的时间图</p>
<p>(1) 单道运行时间关系图</p>
<p>  <img data-src="https://s2.loli.net/2022/05/14/FhG1CTOSvzJu8EM.png" alt="img"></p>
<p>单道总运行时间为190ms。CPU利用率为(190-80)&#x2F;190&#x3D;57.9%</p>
<p>(2) 多道运行时间关系图</p>
<p>  <img data-src="https://s2.loli.net/2022/05/14/vworFI23sGiWeKp.png" alt="img"></p>
<p>多道总运行时间为140ms。CPU利用率为(140-30)&#x2F;140&#x3D;78.6%</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>sql概述与sql定义语言</title>
    <url>/2022/06/23/sql%E6%A6%82%E8%BF%B0%E4%B8%8Esql%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="三、-sql概述与sql定义语言"><a href="#三、-sql概述与sql定义语言" class="headerlink" title="三、 sql概述与sql定义语言"></a>三、 sql概述与sql定义语言</h1><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><p><strong>sql的特点：</strong></p>
<ul>
<li>综合统一：集数据定义、数据操纵、数据控制语言的功能为一体</li>
<li>高度非过程化</li>
<li>面向集合的操作方式</li>
<li>两种使用方式，统一的语法结构</li>
<li>简洁易学、通用、功能强</li>
</ul>
<span id="more"></span>

<p><strong>sql语言的分类</strong>：数据定义语言DDL、数据操作语言DML、数据查询语言DQL、数据控制语言DCL</p>
<p><strong>sql数据库的三级结构：</strong></p>
<p><img data-src="https://s2.loli.net/2022/05/17/3IjuTbYwHFQzdAp.png" alt="image-20220517103508209"></p>
<p>子模式对应于视图和部分查询表，模式对应于基本表，内模式对应于存储文件</p>
<p><strong>sql语句的分类</strong>：模式定义语句、数据操纵语句（增删改查）、事务与控制语句、会话及诊断语句</p>
<p><strong>sql的数据类型：</strong></p>
<p><img data-src="https://s2.loli.net/2022/05/17/fhJG9wazTZ1ydL5.png" alt="image-20220517104732266"></p>
<blockquote>
<p>在实验中发现，如果要显示001这种类型的数字，可以设置为<em>sno int(3) zerofill</em></p>
</blockquote>
<h2 id="2、sql的数据定义"><a href="#2、sql的数据定义" class="headerlink" title="2、sql的数据定义"></a>2、sql的数据定义</h2><p><img data-src="https://s2.loli.net/2022/05/17/5Qv3qyIM9TeJrXG.png" alt="image-20220517110612939"></p>
<blockquote>
<p>👉总结：</p>
<p>创建：create  对象类型 对象名</p>
<p>删除：drop 对象类型 对象名   [RESTRICT | CASCADE]</p>
<p>RESTRICT：如果有其它对象依赖于该对象，则拒绝进行DROP操作</p>
<p>CASCADE：级联删除该对象及所有依赖于该对象的对象</p>
</blockquote>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ul>
<li><p>模式的定义：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SCHEMA <span class="operator">&lt;</span>模式名<span class="operator">&gt;</span> <span class="keyword">AUTHORIZATION</span> <span class="operator">&lt;</span>用户名<span class="operator">&gt;</span>  #若不指定<span class="operator">&lt;</span>模式名<span class="operator">&gt;</span>，则隐含为<span class="operator">&lt;</span>用户名<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line">#eg</span><br><span class="line"><span class="keyword">CREATE</span> SCHEMA library_db <span class="keyword">AUTHORIZATION</span> Guoqing;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模式的删除</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> SCHEMA <span class="operator">&lt;</span>模式名<span class="operator">&gt;</span> [RESTRICT <span class="operator">|</span> CASCADE];</span><br><span class="line">#RESTRICT – 如果模式内没有对象，则删除该模式</span><br><span class="line">#CASCADE – 删除模式中所有对象的内容和定义</span><br><span class="line"></span><br><span class="line">#eg.</span><br><span class="line"><span class="keyword">DROP</span> SCHEMA library RESTRICT;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><ul>
<li><p>定义域：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DOMAIN <span class="operator">&lt;</span>域名<span class="operator">&gt;</span> [<span class="keyword">AS</span>] <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [<span class="keyword">DEFAULT</span> <span class="operator">&lt;</span>默认值<span class="operator">&gt;</span>] [<span class="operator">&lt;</span>域约束<span class="operator">&gt;</span>] </span><br><span class="line"></span><br><span class="line">#eg</span><br><span class="line"><span class="keyword">CREATE</span> DOMAIN SexType <span class="keyword">AS</span> <span class="type">CHAR</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> ‘M’ <span class="keyword">CHECK</span> (<span class="keyword">VALUE</span> <span class="keyword">IN</span> (‘M’, ‘F’));</span><br><span class="line">sex SexType <span class="keyword">NOT</span> <span class="keyword">NULL</span>;  #使用域</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除域：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DOMAIN <span class="operator">&lt;</span>域名<span class="operator">&gt;</span> [RESTRICT <span class="operator">|</span> CASCADE];</span><br><span class="line">#如果指定RESTRICT，且域用于现有的表中，则删除失败</span><br><span class="line">#如果指定CASCADE，基于域的任一表中的列都会自动地改变为基本域类型，该域的<span class="keyword">CHECK</span>约束或默认值都会被列的约束或默认值代替</span><br><span class="line"></span><br><span class="line">#eg</span><br><span class="line"><span class="keyword">DROP</span> DOMAIN SexType；</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><ul>
<li><p>表的建立</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [模式名.] <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> </span><br><span class="line">(   </span><br><span class="line">    <span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>[<span class="keyword">NOT</span> <span class="keyword">NULL</span>│<span class="keyword">NULL</span>][<span class="keyword">UNIQUE</span>]</span><br><span class="line">    [, <span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>[<span class="keyword">NOT</span> <span class="keyword">NULL</span>│<span class="keyword">NULL</span>][<span class="keyword">UNIQUE</span>]]…</span><br><span class="line">    [, <span class="keyword">PRIMARY</span> KEY （<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>[，<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>] …）]    #主键,主键属性列用括号括起来</span><br><span class="line">    [, <span class="keyword">FOREIGN</span> KEY （<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>[，<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>] …）<span class="keyword">REFERENCES</span>  <span class="operator">&lt;</span>被参照表名<span class="operator">&gt;</span>]#外键</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#eg</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> PropertyForRent </span><br><span class="line">(</span><br><span class="line">    propertyNo PNumber <span class="keyword">NOT</span> <span class="keyword">NULL</span>,      #数据类型为用户定义的域</span><br><span class="line">    rooms PRooms <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">4</span>, </span><br><span class="line">    rent PRent <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">600</span>, </span><br><span class="line">    ownerNo OwnerNumber <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">    staffNo StaffNumber <span class="keyword">Constraint</span> StaffNotHandlingTooMuch ….</span><br><span class="line">    branchNo BranchNumber <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (propertyNo),   #主键属性和外键属性要用括号括起来</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (staffNo) <span class="keyword">REFERENCES</span> Staff </span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE …. #可采取的行为</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>表的删除</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [CASCADE <span class="operator">|</span> RESTRICT]</span><br><span class="line">#既删除DD中表的结构定义，也删除DB中的数据文件</span><br><span class="line">#RESTRICT：如果有其它对象依赖于该表，则拒绝进行<span class="keyword">DROP</span>操作</span><br><span class="line">#CASCADE：级联删除表及所有依赖于该表的对象</span><br><span class="line"></span><br><span class="line">#eg</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> PropertyForRent;</span><br></pre></td></tr></table></figure>
</li>
<li><p>&#x3D;&#x3D;修改表&#x3D;&#x3D;</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ALETR <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">ADD</span> <span class="operator">&lt;</span>新列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> &#123;<span class="keyword">NULL</span>&#125;]     #加新列，新增加的列默认为空值</span><br><span class="line">[<span class="keyword">ADD</span> <span class="operator">&lt;</span>完整性约束条件<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">DROP</span> <span class="operator">&lt;</span>完整性约束条件<span class="operator">&gt;</span>]   #删除列的完整性约束条件，没有提供删除列的子句</span><br><span class="line">[MODIFY <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>]   #修改列，可能破坏已有数据</span><br><span class="line"></span><br><span class="line">#eg 增加学生姓名必须取唯一值的约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> c1_name <span class="keyword">UNIQUE</span> (SN)  #c1_name是约束的名字</span><br><span class="line"></span><br><span class="line">#eg 删除学生姓名必须取唯一值的约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> S </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">UNIQUE</span>（SN）;  </span><br><span class="line">#或者 <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> c1_name</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul>
<li><p>建立索引</p>
<p>  一条语句建立一个索引</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">UNIQUE</span>表示每个索引值只能对应唯一的数据记录，CLUSTER表示聚簇索引，即索引项的顺序与表中记录的物理顺序一致的有序索引，一个基本表最多只能建立一个聚簇索引</span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] [CLUSTER] INDEX <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span>  </span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> (<span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span>[<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span>[<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], ...);</span><br><span class="line">#<span class="keyword">ASC</span>表示升序，<span class="keyword">DESC</span>表示降序。默认为升序。</span><br><span class="line"></span><br><span class="line">#eg:在SC中按sno升序cno降序建唯一索引</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX SC_index <span class="keyword">ON</span> SC( sno <span class="keyword">ASC</span>，cno <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除索引</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX [<span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>]<span class="operator">&lt;</span>索引名<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line">#eg</span><br><span class="line"><span class="keyword">DROP</span> INDEX SC_index;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="x3D-x3D-3、⚠⚠⚠sql数据查询-x3D-x3D"><a href="#x3D-x3D-3、⚠⚠⚠sql数据查询-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;3、⚠⚠⚠sql数据查询&#x3D;&#x3D;"></a>&#x3D;&#x3D;3、⚠⚠⚠sql数据查询&#x3D;&#x3D;</h2><h3 id="一般格式"><a href="#一般格式" class="headerlink" title="一般格式"></a>一般格式</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span>]...      #<span class="keyword">ALL</span>为默认设置，即不取消重复值，<span class="keyword">DISTINCT</span>表示取消重复值</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span>[,表名或视图名]...     #<span class="keyword">SELECT</span>子句与<span class="keyword">FROM</span>子句是必选子句</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span>[<span class="keyword">HAVING</span><span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span>[<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]];     #其中，列名<span class="number">2</span>也可以用<span class="keyword">SELECT</span>子句中相应列的序号</span><br></pre></td></tr></table></figure>

<p><strong>含义：</strong></p>
<p><img data-src="https://s2.loli.net/2022/05/17/GUvQItYzXHpeOmW.png" alt="image-20220517114258444"></p>
<p><strong>概念性的执行步骤：</strong></p>
<ul>
<li>计算出现在FROM后面的表之间的笛卡儿积</li>
<li>实施由WHERE后面的条件规定的选择操作</li>
<li>根据GROUP BY后面的属性的值进行分组</li>
<li>对于分组出来的每一个小组，实施由HAVING后面的条件规定的选择操作，保留满足条件的小组</li>
<li>将出现在SELECT后面的属性投影成结果表</li>
<li>将结果表中的元组根据ORDER BY后面的属性及指定的顺序（升序或降序）输出</li>
</ul>
<h3 id="SELECT子句："><a href="#SELECT子句：" class="headerlink" title="SELECT子句："></a>SELECT子句：</h3><p><em>SELECT [ALL|DISTINCT] &lt;目标列表达式&gt;[,&lt;目标列表达式&gt;]…</em></p>
<ul>
<li><p>*代表指定表的所有列，一般用在exists和not exists里面</p>
</li>
<li><p>ALL为默认设置 ，即不取消重复值，DISTINCT表示取消重复值</p>
</li>
<li><p>&#x3D;&#x3D;聚集函数（只能用于SELECT子句和HAVING子句中 ）&#x3D;&#x3D;</p>
<p>  <img data-src="https://s2.loli.net/2022/03/05/YGrdqMfam4Qhb8P.png" alt="image-20220305102158697"></p>
<p>  <img data-src="https://s2.loli.net/2022/03/07/xj6qmHkOhKrcvag.png" alt="image-20220307231705848"></p>
<blockquote>
<p>当这些函数遇到空值时，除COUNT(*)外，都跳过空值而只处理非空值。</p>
</blockquote>
<p>  例子：</p>
  <img data-src="https://s2.loli.net/2022/05/17/5Yvk4aWe1JPLMOw.png" alt="image-20220517115836637" style="zoom: 67%;" />
</li>
<li><p>&#x3D;&#x3D;算术表达式：&#x3D;&#x3D;  </p>
<p>  +、-、*、&#x2F;、%、INTEGER（取整）、SQRT（求平方根）、三角函数（SIN、COS）、字符串函数SUBSTRING（取子串）、UPPER（大写字符）、MONTHS_BETWEEN（月份差）</p>
<hr>
</li>
<li><p>用AS子句为列命名 </p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> staffNo, fName, lName, salary<span class="operator">/</span><span class="number">12</span> <span class="keyword">AS</span> monthlySalary <span class="keyword">FROM</span> Staff;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="FROM子句："><a href="#FROM子句：" class="headerlink" title="FROM子句："></a>FROM子句：</h3><p>可以给表指定别名：多个表放在FROM子句中，代表多表进行笛卡尔积</p>
<p><img data-src="https://s2.loli.net/2022/05/17/4bpXBmUsKrI3CdH.png" alt="image-20220517120134854"></p>
<h3 id="WHERE子句："><a href="#WHERE子句：" class="headerlink" title="WHERE子句："></a>WHERE子句：</h3><p>WHERE子句的查询条件可以用多种形式表示： </p>
<img data-src="https://s2.loli.net/2022/05/18/X4nGHxUtsuZCcio.png" style="zoom:67%;" />

<ul>
<li><p>比较运算作为查找条件 (&gt;,  &lt;,  &gt;&#x3D;,  &lt;&#x3D;,  &#x3D;,  &lt;&gt;(不等于))</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>复合比较运算作为查找条件 (AND, OR, NOT ) </p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> city <span class="operator">=</span> ‘London’ <span class="keyword">OR</span> city <span class="operator">=</span> ‘Glasgow’</span><br></pre></td></tr></table></figure>
</li>
<li><p>范围作为查找条件（BETWEEN &#x2F; NOT BETWEEN）。&#x3D;&#x3D;BETWEEN包含端点&#x3D;&#x3D;</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> grade <span class="keyword">BETWEEN</span> <span class="number">85</span> <span class="keyword">AND</span> <span class="number">95</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>集合成员测试作为查找条件（IN &#x2F; NOT IN）</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> place <span class="keyword">IN</span>(<span class="string">&#x27;湖南&#x27;</span>,<span class="string">&#x27;湖北&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>模式匹配作为查找条件（LIKE &#x2F; NOT LIKE）</p>
<p>  SQL中的两种特殊的模式匹配符号：</p>
<ul>
<li><p>%: 百分号表示零或多个字符序列（通配符）</p>
</li>
<li><p>_: 下划线表示任意单个字符</p>
  <img data-src="https://s2.loli.net/2022/03/07/Z52TOHjLlb6tivJ.png" alt="image-20220307230435181" style="zoom:67%;" /></li>
</ul>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> sname <span class="keyword">LIKE</span> <span class="string">&#x27;刘%&#x27;</span> <span class="keyword">OR</span> SNAME <span class="keyword">LIKE</span> <span class="string">&#x27;__晓%&#x27;</span>   #一个汉字占两个字符位</span><br></pre></td></tr></table></figure>
</li>
<li><p>空查找条件（IS NULL  &#x2F;  IS NOT NULL）</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> propertyNo <span class="operator">=</span> ‘PG4’ <span class="keyword">AND</span> comment <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="GROUP-BY子句-："><a href="#GROUP-BY子句-：" class="headerlink" title="GROUP BY子句 ："></a>GROUP BY子句 ：</h3><p>将查询结果按指定列名的取值分组，并选取满足HAVING中的内部函数表达式所指定条件的组。目的：细化聚集函数的作用对象。 &#x3D;&#x3D;HAVING子句是包含在GROUP BY子句中的&#x3D;&#x3D; </p>
<blockquote>
<p>WHERE子句是在表中选择满足条件的元组，而HAVING子句是在各组中选择满足条件的小组</p>
</blockquote>
<blockquote>
<p>ISO标准规定，应用GROUP BY时，两个空值被认为是相等的</p>
</blockquote>
<blockquote>
<p>&#x3D;&#x3D;当使用GROUP BY时， SELECT列表中的项必须每组都有单一值(因为最终一个组会变成一个元组)&#x3D;&#x3D; </p>
</blockquote>
<blockquote>
<p>当使用GROUP BY时， SELECT子句中除集合函数外，其它所有列必须在GROUP BY子句中出现；反之，GROUP BY子句出现的列不一定出现在SELECT列表中；</p>
<p>HAVING子句使用的列名必须出现在GROUP BY 子句列表中，或者包括在集合函数中。实践中，HAVING子句的条件表达式至少包括一个集合函数</p>
</blockquote>
<h3 id="ORDER-BY子句"><a href="#ORDER-BY子句" class="headerlink" title="ORDER BY子句"></a>ORDER BY子句</h3><p>order by子句必须放最后用于对最终的查询结果进行排序，<u>不能用在子查询中</u></p>
<p>该子句后可以跟多个排序的变量名，第一个变量为主序，下面依次类推。&#x3D;&#x3D;ASC（升序）为默认设置&#x3D;&#x3D; 。它也可以用SELECT子句中相应列的序号。</p>
<img data-src="https://s2.loli.net/2022/05/17/5Yvk4aWe1JPLMOw.png" alt="image-20220517115836637" style="zoom: 67%;" />

<img data-src="https://s2.loli.net/2022/05/17/GeHg8L1yBXIUpJt.png" alt="image-20220517120939452" style="zoom: 80%;" />

<h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><p>单表查询</p>
<ul>
<li>查询指定的列：通过在SELECT子句的&lt;目标列表达式&gt;中指定要查询的列来实现。可以使用*、聚集函数、算术表达式等</li>
<li>查询表中行：通过WHERE子句的查询条件来实现</li>
</ul>
<h3 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h3><h4 id="连接查询："><a href="#连接查询：" class="headerlink" title="连接查询："></a>连接查询：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student.sno, sname, cno, grade <span class="keyword">FROM</span> student, s_c <span class="keyword">WHERE</span> student.sno <span class="operator">=</span> s_c.sno;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;注意在多表查询中，当两个列名相同时，需采用表名.列名以示区别&#x3D;&#x3D;</p>
<h4 id="嵌套查询（子查询）："><a href="#嵌套查询（子查询）：" class="headerlink" title="嵌套查询（子查询）："></a>嵌套查询（子查询）：</h4><p>子查询可以被使用在外部SELECT语句的WHERE子句、HAVING子句甚至SELECT子句中</p>
<p>&#x3D;&#x3D;子查询应遵循如下规则：&#x3D;&#x3D; </p>
<ul>
<li><p>ORDER BY子句不能用于子查询（因为ORDER BY子句是对最终显示的结果进行排序）</p>
</li>
<li><p>子查询总是<strong>括在圆括号</strong> 中，作为表达式的一部分出现在条件比较运算符的右边，并且可以有选择的跟在IN，SOME（ANY），ALL和EXIST等谓词后面。</p>
</li>
<li><p>子查询select列表必须由<strong>单个列名或表达式</strong> （如集合函数）组成，除非子查询使用了关键字EXISTS（多列多行时使用）</p>
</li>
<li><p>默认情况下，子查询中列名取自子查询的FROM子句中给定的表，也可以通过限定列名的办法指定取自外查询的FROM子句中的表（不相关子查询和相关子查询）</p>
</li>
<li><p>带有比较运算符的子查询（&#x3D;&#x3D;此时子查询返回单个值&#x3D;&#x3D;，可以使用集合函数 ）</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#列出个人工资高于平均工资的所有职员，并求出多于平均数的值。</span><br><span class="line"><span class="keyword">SELECT</span> staffNo, fName, lName, position, salary–(<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> Staff) <span class="keyword">AS</span> SalDiff</span><br><span class="line"><span class="keyword">FROM</span> Staff</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">FROM</span> Staff);</span><br></pre></td></tr></table></figure>
</li>
<li><p>带有IN谓词的子查询（子查询返回单个值或单个列多个行）</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查询选修了课程“C2”的学生的学号和姓名</span><br><span class="line"><span class="keyword">SELECT</span> sno, sname <span class="keyword">FROM</span> S <span class="keyword">WHERE</span> sno <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> sno <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> cno <span class="operator">=</span> ‘C2’ );</span><br></pre></td></tr></table></figure>
</li>
<li><p>多层嵌套：子查询中又嵌套子查询</p>
</li>
<li><p>&#x3D;&#x3D;不相关子查询和相关子查询&#x3D;&#x3D; </p>
<ul>
<li><p>不相关子查询：内层的子查询完全独立于外层的SELECT语句。&#x3D;&#x3D;m + n&#x3D;&#x3D; （只执行了一次子查询，在检查外层的元组时，无需再执行子查询）</p>
<blockquote>
<p>执行过程：1）执行子查询，其结果不被显示，而是传递给外部查询，作为外部查询的条件使用。2）执行外部查询，并显示整个结果。</p>
</blockquote>
</li>
<li><p>相关子查询：子查询的判断条件涉及外层父查询的属性。要用到存在谓词EXISTS和NOT EXISTS，或者ALL、SOME等。&#x3D;&#x3D;m * n&#x3D;&#x3D; （每检查一个元组，都要执行一次子查询）</p>
<blockquote>
<p>执行过程：1）从外层查询中取出一个元组，将元组相关列（被内层子查询引用）的值传给内层查询。2）执行内层查询，得到子查询操作的值。3）外查询根据子查询返回的结果或结果集得到满足条件的行。4）然后外层查询取出下一个元组重复做步骤1-3，直到外层的元组全部处理完毕。</p>
</blockquote>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#找出每个学生超过他自己已选修课程平均成绩的课程号</span><br><span class="line"><span class="keyword">SELECT</span> sno, cno <span class="keyword">FROM</span> SC x <span class="keyword">WHERE</span> G<span class="operator">&gt;=</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(G) <span class="keyword">FROM</span> SC y <span class="keyword">WHERE</span> x.sno <span class="operator">=</span> y.sno);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>量化比较谓词</p>
<ul>
<li><p>作用：产生单个列的子查询</p>
</li>
<li><p>通用形式：<code>expr Θ &#123; SOME | ANY | ALL &#125; (Subquery)其中Θ∈&#123;&lt;,&lt;=,=,&lt;&gt;,&gt;,&gt;=&#125; </code>。expr为表达式。该形式中的SOME与ANY含义相同，但用SOME而不用ANY。SOME某些，ALL全部。</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查询其它系中比信息系某一学生年龄小的学生姓名和年龄</span><br><span class="line"><span class="keyword">SELECT</span> SN, SA <span class="keyword">FROM</span> S <span class="keyword">WHERE</span> SA <span class="operator">&lt;</span> <span class="keyword">SOME</span> (<span class="keyword">SELECT</span> SA <span class="keyword">FROM</span> S <span class="keyword">WHERE</span> SD <span class="operator">=</span>‘<span class="keyword">IS</span>’) <span class="keyword">AND</span> SD <span class="operator">&lt;&gt;</span>‘<span class="keyword">IS</span>’;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>expr Θ （子查询）  子查询返回单个值</p>
<p>expr IN （子查询）</p>
<p>expr Θ { SOME | ANY | ALL } (子查询)，&gt;&#x3D; ALL可以用于求最大值</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;EXISTS谓词&#x3D;&#x3D; </p>
<ul>
<li><p>通用形式：[NOT] EXISTS （Subquery）</p>
</li>
<li><p>作用：测试被子查询检索到的行集(子查询可以返回多行多列)<strong>是否为空</strong> 。谓词 EXISTS （Subquery）为真当且仅当子查询返回一个非空的集合。NOT_EXISTS则相反</p>
</li>
<li><p>NOT EXISTS谓词可以实现<strong>关系代数的差运算</strong></p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查询没有选修‘C1’号课程的学生的姓名。</span><br><span class="line"><span class="keyword">SELECT</span> sname <span class="keyword">FROM</span> S <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> sno <span class="operator">=</span> S.sno <span class="keyword">AND</span> cno <span class="operator">=</span> ‘C1’);</span><br></pre></td></tr></table></figure>
</li>
<li><p>所有带IN谓词、比较运算符、SOME和ALL谓词的子查询都可以用带EXISTS谓词的子查询等价替换，反过来就不一定</p>
</li>
<li><p>可以采用双嵌套NOT_EXISTS来实现<strong>带全称量词的查询</strong>。<img data-src="https://s2.loli.net/2022/03/15/Km17HNji9vZAeGV.png" alt="image-20220315110415416" style="zoom:50%;" /></p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查询选修了全部课程的学生姓名</span><br><span class="line">#转化为查询这样的学生x，没有一门课程y 是x不选修的</span><br><span class="line"><span class="keyword">SELECT</span> SN</span><br><span class="line"><span class="keyword">FROM</span> S     #查询学生x</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>  #不存在课程y</span><br><span class="line">    （<span class="keyword">SELECT</span> ﹡</span><br><span class="line">    <span class="keyword">FROM</span> C</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>  #x不选修课程y</span><br><span class="line">        （<span class="keyword">SELECT</span> ﹡</span><br><span class="line">        <span class="keyword">FROM</span> SC</span><br><span class="line">        <span class="keyword">WHERE</span> S# <span class="operator">=</span> S.S#</span><br><span class="line">        <span class="keyword">AND</span> C# <span class="operator">=</span> C.C#））</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以采用NOT EXISTS谓词实现<strong>关系代数的除运算</strong></p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查询至少选修了学生‘<span class="number">95002</span>’选修的全部课程的学生号码</span><br><span class="line">#转换为查询学号为x的学生，不存在这样的课程y，学生<span class="number">95002</span>选修了y，而学生x没有选</span><br><span class="line"><span class="keyword">SELECT</span> S#</span><br><span class="line"><span class="keyword">FROM</span> S          #查询学生x</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">    （<span class="keyword">SELECT</span> ﹡</span><br><span class="line">    <span class="keyword">FROM</span> C       #不存在课程y</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>   #<span class="number">95002</span>选修了课程y</span><br><span class="line">        (<span class="keyword">SELECT</span> ﹡</span><br><span class="line">        <span class="keyword">FROM</span> SC SCX</span><br><span class="line">        <span class="keyword">WHERE</span> SCX.C# <span class="operator">=</span> C.C# <span class="keyword">AND</span> SCX.S#<span class="operator">=</span>‘<span class="number">95002</span>’）</span><br><span class="line">    <span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>   #x没有选修y</span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">        <span class="keyword">FROM</span> SC SCY</span><br><span class="line">        <span class="keyword">WHERE</span> SCY.C# <span class="operator">=</span> C.C# <span class="keyword">AND</span> SCY.S#<span class="operator">=</span>S.S#)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> S#    #因为是从SC里选的学号，故需要<span class="keyword">DISTINCT</span></span><br><span class="line"><span class="keyword">FROM</span> SC SCX         #查询学生x</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">    （<span class="keyword">SELECT</span> ﹡</span><br><span class="line">    <span class="keyword">FROM</span> SC SCY    #不存在课程y</span><br><span class="line">    <span class="keyword">WHERE</span> SCY.S# <span class="operator">=</span> ‘<span class="number">95002</span>’  #<span class="number">95002</span>选修了课程y</span><br><span class="line">    <span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>    #x没有选修y</span><br><span class="line">        （<span class="keyword">SELECT</span> ﹡  </span><br><span class="line">        <span class="keyword">FROM</span> SC SCZ</span><br><span class="line">        <span class="keyword">WHERE</span> SCZ.S# <span class="operator">=</span> SCX.S#</span><br><span class="line">        <span class="keyword">AND</span> SCZ.C# <span class="operator">=</span> SCY.C#））；</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><img data-src="https://s2.loli.net/2022/03/14/2srATEC8QOWUzM4.png" alt="image-20220314232322210"></p>
<h2 id="4、数据更新"><a href="#4、数据更新" class="headerlink" title="4、数据更新"></a>4、数据更新</h2><h3 id="插入数据：INSERT-（元组级）"><a href="#插入数据：INSERT-（元组级）" class="headerlink" title="插入数据：INSERT （元组级）"></a>插入数据：INSERT （元组级）</h3><p>&#x3D;&#x3D;插入数据时，表定义中说明了NOT NULL的列不能取空值&#x3D;&#x3D; </p>
<ul>
<li><p>用<strong>子句</strong>向表中插入数据：将新元组插入表中</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> </span><br><span class="line"><span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [(<span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span>[, <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span>]...)] </span><br><span class="line"><span class="keyword">VALUES</span>(<span class="operator">&lt;</span>常量<span class="number">1</span><span class="operator">&gt;</span>[, <span class="operator">&lt;</span>常量<span class="number">2</span><span class="operator">&gt;</span>]...)  </span><br><span class="line"> #未指定任何列名时，新插入的属性必须在每个属性列上均有值，仅指定部分列名时，新元组的其他列为空值</span><br><span class="line"> </span><br><span class="line">#eg 插入一条选课记录（‘<span class="number">95020</span>’，‘C1’）</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC（S#, C#）<span class="keyword">VALUES</span> （‘<span class="number">95020</span>’, ‘C1’）; </span><br></pre></td></tr></table></figure>
</li>
<li><p>用<strong>子查询</strong>向表中插入数据</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> </span><br><span class="line"><span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [(<span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span>[, <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span>]...)] </span><br><span class="line"><span class="keyword">SELECT</span>语句;  #<span class="keyword">SELECT</span>语句的返回列要和INFO里的对应</span><br><span class="line"></span><br><span class="line">#eg  对每个系，求学生的平均年龄，并把结果存入数据库</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Deptage (SD, Avgage) <span class="keyword">SELECT</span> SD, <span class="built_in">AVG</span>(SA) <span class="keyword">FROM</span> S <span class="keyword">GROUP</span> <span class="keyword">BY</span> SD;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="修改数据：UPDATE"><a href="#修改数据：UPDATE" class="headerlink" title="修改数据：UPDATE"></a>修改数据：UPDATE</h3><p>一条UPDATE语句在某一时刻只能更新<strong>一张表</strong>，但可以更新一张表中的<strong>多列</strong>，也可以更新<strong>多行</strong>数据。</p>
<ul>
<li><p>用<strong>子句</strong>修改表中数据</p>
<p>  修改表中满足WHERE条件的元组：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">SET</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">=</span> <span class="operator">&lt;</span>表达式<span class="operator">&gt;</span>[, <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">=</span> <span class="operator">&lt;</span>表达式<span class="operator">&gt;</span>] #用表达式的值取代相应的属性列值</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]				#省略<span class="keyword">WHERE</span>语句则修改全部元组</span><br><span class="line"></span><br><span class="line">#eg 将学生<span class="number">95001</span>的年龄改为<span class="number">22</span>岁</span><br><span class="line"><span class="keyword">UPDATE</span> S <span class="keyword">SET</span> SA <span class="operator">=</span> <span class="number">22</span> <span class="keyword">WHERE</span> S# <span class="operator">=</span> ‘<span class="number">95001</span>’;</span><br><span class="line"></span><br><span class="line">#eg 将所有学生的年龄增加<span class="number">1</span>岁</span><br><span class="line"><span class="keyword">UPDATE</span> S <span class="keyword">SET</span> SA <span class="operator">=</span> SA <span class="operator">+</span> <span class="number">1</span>；</span><br></pre></td></tr></table></figure>
</li>
<li><p>用<strong>子查询</strong>修改表中数据：子查询可以嵌套在WHERE语句的条件表达式中，用于构造修改的条件。相关子查询</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#将计算机科学系全体学生的成绩置零</span><br><span class="line">#相关子查询，每次拿出SC中的一个元组，得到它的系，如果为CS则将成绩置<span class="number">0</span></span><br><span class="line"><span class="keyword">UPDATE</span> SC <span class="keyword">SET</span> G <span class="operator">=</span> <span class="number">0</span> <span class="keyword">WHERE</span> ‘CS’ <span class="operator">=</span> ( <span class="keyword">SELECT</span> SD <span class="keyword">FROM</span> S <span class="keyword">WHERE</span> S.S# <span class="operator">=</span> SC.S#);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="删除数据：DELETE-（元组级）"><a href="#删除数据：DELETE-（元组级）" class="headerlink" title="删除数据：DELETE （元组级）"></a>删除数据：DELETE （元组级）</h3><p>DELETE用于<strong>从指定表中删除满足条件的元组</strong>，但不能用来从特定的列中删除数据。一条DELETE语句可以从表中删除一个或多个元组。</p>
<ul>
<li><p>用<strong>子句</strong>删除表中数据</p>
<p>  删除表中满足WHERE条件的元组：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> </span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]  </span><br><span class="line"></span><br><span class="line">#eg 删除学号为<span class="number">95001</span>的学生记录</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> S <span class="keyword">WHERE</span> S# <span class="operator">=</span> ‘<span class="number">95001</span>’;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>省略WHERE语句则删除全部元组，但<strong>只删除了表中的数据</strong>，而不是表的定义，表的定义仍在DD中。<strong>删除表应当用DROP</strong></p>
</blockquote>
</li>
<li><p><strong>子查询</strong>可以嵌套在WHERE语句的条件表达式中。相关子查询</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#删除计算机科学系全体学生的选课记录</span><br><span class="line">#相关子查询</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> ‘CS’ <span class="operator">=</span> ( <span class="keyword">SELECT</span> SD <span class="keyword">FROM</span> S <span class="keyword">WHERE</span> S.S# <span class="operator">=</span> SC.S#);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5、视图"><a href="#5、视图" class="headerlink" title="5、视图"></a>5、视图</h2><ul>
<li><strong>概念：</strong><ul>
<li>视图是&#x3D;&#x3D;动态结果&#x3D;&#x3D;：对一个或多个基本关系进行关系操作得到的动态结果，是从一个或几个基本表（或视图）导出的表。而且对基本表的操作将在视图可见的范围内映射到视图上。&#x3D;&#x3D;视图对应的内容是实时的、最新的内容&#x3D;&#x3D; </li>
<li>视图是&#x3D;&#x3D;虚关系&#x3D;&#x3D;：它不包含真正存储的数据，其内容不占用存储空间。</li>
<li><strong>视图的内容被定义成基于一个或多个基本关系的查询</strong></li>
<li>视图是在&#x3D;&#x3D;外模式&#x3D;&#x3D;这一层，为用户所用</li>
</ul>
</li>
<li><strong>操作：</strong>视图可以和基本表一样被查询、被删除。也可以在一个视图之上再定义新的视图，但&#x3D;&#x3D;对视图的更新（增、删、改）操作则有一定的限制&#x3D;&#x3D;。&#x3D;&#x3D;对视图的一切操作最终也要转换为对基本表的操作。&#x3D;&#x3D;</li>
</ul>
<h3 id="视图的创建及种类"><a href="#视图的创建及种类" class="headerlink" title="视图的创建及种类"></a>视图的创建及种类</h3><ul>
<li><p>视图可以从一张表、几张表或其他视图中创建。 </p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span> [(<span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span>[,<span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span>]...)]</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> 语句</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION]  </span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>几点说明：</strong></p>
<ul>
<li><p>&#x3D;&#x3D;创建视图只是将视图的定义存入DD（数据字典），并不会真的执行SELECT语句，当对视图查询时，才根据视图的定义从基本表中将数据查出。&#x3D;&#x3D;</p>
</li>
<li><p><strong>省略视图名后的列名表时</strong>，默认该视图由子查询中SELECT子句目标列中的诸属性列组成</p>
</li>
<li><p>若使用&#x3D;&#x3D;WITH CHECK OPTION&#x3D;&#x3D;，则对视图进行UPDATE和INSERT操作时，保证更新行满足视图定义中的WHERE子句指定的条件，否则将被DBMS拒绝</p>
</li>
<li><p>当目标列不是单一的属性列(如集合函数)、存在同名列以及需启用更合适的名字时，需要指定组成视图的所有列名</p>
</li>
<li><p>可以在视图中增加虚拟列（派生列），即基本表中并不存在的列，如avg(grade)</p>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>视图的种类</strong></p>
<ul>
<li><p>水平视图：从单个基本表导出，并且只是<strong>去掉了</strong>基本表的<strong>某些行</strong></p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#创建一个视图，让分支机构B003的经理只看到他所在分支机构的职员的信息</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> Manager3Staff</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Staff</span><br><span class="line"><span class="keyword">WHERE</span> branchNo <span class="operator">=</span> ‘B003’;</span><br></pre></td></tr></table></figure>
</li>
<li><p>垂直视图：从单个基本表导出，并且只是<strong>去掉了</strong>基本表的<strong>某些列</strong> </p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#建立关于分支机构B003职员信息但不包括工资信息的视图</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> Staff3</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> staffNo, fName, lName, position, sex</span><br><span class="line"><span class="keyword">FROM</span> Manager3Staff;		#视图可以从其他视图中创建</span><br></pre></td></tr></table></figure>
</li>
<li><p>分组视图：用<strong>GROUP BY 子句</strong>定义的视图</p>
</li>
<li><p>连接视图：用<strong>连接运算</strong>得到的视图</p>
<p>  <img data-src="https://s2.loli.net/2022/03/22/CA4TkBawSpnsgIi.png" alt="image-20220322094759185"></p>
</li>
</ul>
</li>
</ul>
<h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><ul>
<li><pre><code class="sql">  DROP VIEW &lt;视图名&gt;&#123;CASCADE|RESTRICT&#125; 
  <figure class="highlight less"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> 视图是虚表，**删除的是<span class="selector-tag">DD</span>中的视图的定义**，**对产生视图数据的基本表中的数据没有影响**</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> 默认<span class="selector-tag">RESTRICT</span> ，如果存在依赖被删除视图的其他对象，则不允许删除</span><br><span class="line"></span><br><span class="line">    如果指定<span class="selector-tag">CASCADE</span>**，**删除视图可能产生级联删除</span><br><span class="line"></span><br><span class="line">### 查询视图</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> **步骤**</span><br><span class="line"></span><br><span class="line">```<span class="selector-tag">mermaid</span></span><br><span class="line"><span class="selector-tag">graph</span> <span class="selector-tag">LR</span></span><br><span class="line">    <span class="selector-tag">a</span><span class="selector-attr">[有效性检查]</span><span class="selector-tag">--</span>&gt;|有效|<span class="selector-tag">b</span><span class="selector-attr">[从DD中取出视图定义]</span></span><br><span class="line">    <span class="selector-tag">b</span><span class="selector-attr">[从DD中取出视图定义]</span><span class="selector-tag">--</span>&gt;|视图消解|<span class="selector-tag">c</span><span class="selector-attr">[对基本表的查询]</span></span><br><span class="line">    <span class="selector-tag">c</span><span class="selector-attr">[对基本表的查询]</span><span class="selector-tag">--</span>&gt;<span class="selector-tag">d</span><span class="selector-attr">[执行查询]</span></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>&#x3D;&#x3D;视图消解&#x3D;&#x3D;：将对视图的查询<strong>转换为对基本表的查询</strong>。执行对视图的查询时，从数据字典中取出视图的定义，将定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询的过程</p>
<blockquote>
<p>简单转换的过程：</p>
<ul>
<li><p>将SELECT列表中给出的列名转换为视图定义中对应的列名</p>
</li>
<li><p>FROM子句的视图名可以视图定义中的FROM列表代替</p>
</li>
<li><p>用AND将WHERE子句和视图定义中的WHERE子句合并</p>
</li>
<li><p>从视图定义中复制GROUP BY和HAVING子句</p>
</li>
<li><p>将 ORDER BY列名转换为视图定义中对应的列名</p>
<p>  例子：</p>
  <img data-src="https://s2.loli.net/2022/03/22/jVlQaEdt8FD5HcW.png" alt="image-20220322221341006" style="zoom:67%;" />

  <img data-src="https://s2.loli.net/2022/03/22/I5TvHtQE4RCPSlk.png" alt="image-20220322221538427" style="zoom: 67%;" />

  <img data-src="https://s2.loli.net/2022/03/22/HOEKyJ3X26nhGs9.png" alt="image-20220322221558073" style="zoom:67%;" /></li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<p>复杂转换：涉及集合函数，考虑HAVING子句等等</p>
<img data-src="https://s2.loli.net/2022/03/22/7WcqENUudBsYIMg.png" alt="image-20220322222248720" style="zoom:67%;" />
</blockquote>
<ul>
<li><p><strong>查询视图的约束：</strong></p>
<ul>
<li><p>如果视图中某个列是基于集合函数的，那么，该列只能出现在访问视图的SELECT和ORDER BY子句中，特别是，该列不能出现在WHERE子句中，并且不能作为集合函数的参数</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> StaffPropCnt <span class="keyword">WHERE</span> cnt <span class="operator">&gt;</span> <span class="number">2</span>; <span class="operator">/</span><span class="operator">/</span>错误</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span> (cnt) <span class="keyword">FROM</span> StaffPropCnt;  <span class="operator">/</span><span class="operator">/</span>错误</span><br></pre></td></tr></table></figure>
</li>
<li><p>分组视图不能与基本表或视图进行连接操作</p>
</li>
</ul>
</li>
</ul>
<h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><ul>
<li>👉<strong>对视图的更新最终要转换为对表的更新</strong>，但有些更新不能有意义地转换成对基本表S的更新，如修改一个集合函数得到的列，因此&#x3D;&#x3D;对视图的更新操作有一定的限制&#x3D;&#x3D;</li>
<li>在视图定义时加上WITH CHECK OPTION子句可以使得对视图进行更新操作时需满足视图定义中子查询的条件</li>
<li>&#x3D;&#x3D;视图可更新的充要条件&#x3D;&#x3D;<ul>
<li>没有指定DISTINCT,即重复元组未从查询结果中消除；</li>
<li>定义查询的SELECT列表中的每个元素均为列名（而不是常量，表达式或聚合函数），且列名不能出现多于一次；</li>
<li>FROM子句只能指定一个表，即视图必须有一个源表且用户有请求该表的权限。如果源表本身就是一个视图，那么视图必须满足这些条件。因此，排除了基于连接、并（UNION）、交（INTERSECT）或差（EXCEPT）操作的所有视图；</li>
<li>WHERE子句不能包括任何引用了FROM子句中的表的嵌套SELECT操作，即不能出现相关子查询</li>
<li>定义查询不能有GROUP BY或HAVING子句。</li>
<li>添加到视图中的每一行都不能违反基本表的完整性约束</li>
</ul>
</li>
<li>分类<ul>
<li>可更新视图：满足上面的六个条件，即对视图的更新能唯一的有意义的转换为对基本表的更新</li>
<li>（理论上）不可更新的视图</li>
<li>不允许更新的视图&#96;(<em>&gt;﹏&lt;</em>)′</li>
</ul>
</li>
</ul>
<h3 id="视图的优缺点"><a href="#视图的优缺点" class="headerlink" title="视图的优缺点"></a>视图的优缺点</h3><ul>
<li><p><strong>优点：</strong>①提高逻辑独立性、②实时性、③提高安全性、④简化结构及复杂操作、⑤多角度地、更灵活地共享、⑥数据完整性</p>
</li>
<li><p><strong>缺点：</strong>①更新的局限性、②结构的局限性、③性能开销（查询时需要转化）</p>
<blockquote>
<p><strong>视图维护：</strong>更新基本表引起视图更新的过程称为视图维护</p>
<p><strong>视图物化：</strong>把第一次访问视图的结果存储为数据库的临时表；这样，基于物化视图的查询比每次重新计算视图要快的多。但会带来视图维护的代价</p>
</blockquote>
</li>
</ul>
<h2 id="x3D-x3D-6、sql的完整性约束-x3D-x3D"><a href="#x3D-x3D-6、sql的完整性约束-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;6、sql的完整性约束&#x3D;&#x3D;"></a>&#x3D;&#x3D;6、sql的完整性约束&#x3D;&#x3D;</h2><h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a><strong>基本概念：</strong></h3><ul>
<li><strong>完整性：</strong>指数据库中数据的正确性、有效性和相容性（表示同一对象的两个或多个数据必须一致）</li>
<li><strong>完整性约束</strong>：数据库中数据应满足的条件</li>
</ul>
<h3 id="非过程性完整性约束"><a href="#非过程性完整性约束" class="headerlink" title="非过程性完整性约束"></a>非过程性完整性约束</h3><ul>
<li><p><strong>数据取值要求：</strong>非空约束（NOT NULL）、唯一性约束（UNIQUE）、CHECK约束（CHECK(searchcondition)）</p>
<blockquote>
<p>CHECK子句只对定义它的关系起约束作用，对其他关系没有任何作用</p>
</blockquote>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sex <span class="type">CHAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">CHECK</span> (sex <span class="keyword">IN</span> (‘M’, ‘F’))</span><br></pre></td></tr></table></figure>

  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#eg 增加学生姓名必须取唯一值的约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> c1_name <span class="keyword">UNIQUE</span> (SN)  #c1_name是约束的名字</span><br><span class="line"></span><br><span class="line">#eg 删除学生姓名必须取唯一值的约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> S </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">UNIQUE</span>（SN）;  </span><br><span class="line">#或者 <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> c1_name</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>域约束：</strong>通过自定义域来实现</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DOMAIN DomainName [<span class="keyword">AS</span>] dataType</span><br><span class="line">[<span class="keyword">DEFAULT</span> defaultOption]</span><br><span class="line">[<span class="keyword">CHECK</span> (searchCondition)]  #searchCondition 可以用<span class="keyword">SELECT</span>语句表达</span><br><span class="line"></span><br><span class="line">#eg</span><br><span class="line"><span class="keyword">CREATE</span> DOMAIN SexType <span class="keyword">AS</span> <span class="type">CHAR</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">DEFAULT</span> ‘M’</span><br><span class="line"><span class="keyword">CHECK</span> (<span class="keyword">VALUE</span> <span class="keyword">IN</span> (‘M’, ‘F’));</span><br><span class="line"></span><br><span class="line">#使用域来定义列</span><br><span class="line">sex SexType <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实体完整性：</strong>主键属性不空。DBMS自动支持实体完整性（拒绝破坏实体完整性的操作（不合法的插入和更新））</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PRIMARY</span> KEY(<span class="operator">&lt;</span>列名表<span class="operator">&gt;</span>)  #主键定义   </span><br><span class="line"><span class="keyword">UNIQUE</span>(<span class="operator">&lt;</span>列名表<span class="operator">&gt;</span>)   #候选键定义</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>参照完整性</strong>：DBMS自动支持参照完整性（拒绝破坏参照完整性的操作，如不合法的对子表（参照表）的插入和更新操作，不合法的对父表（被参照表）的删除和更新操作）。注意SQL语句的顺序。</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FOREIGN</span> KEY （<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>[，<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>] …）<span class="keyword">REFERENCES</span> <span class="operator">&lt;</span>被参照表名<span class="operator">&gt;</span> </span><br><span class="line">[<span class="keyword">ON</span> <span class="keyword">DELETE</span> [CASCADE <span class="operator">|</span> <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="operator">|</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NO</span> ACTION] ]</span><br><span class="line">[<span class="keyword">ON</span> <span class="keyword">UPDATE</span> [CASCADE <span class="operator">|</span> <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> <span class="operator">|</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="operator">|</span><span class="keyword">NO</span> ACTION] ]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参照完整性被破坏时可选择的策略：</p>
<img data-src="https://s2.loli.net/2022/03/22/N9xBsZtjn5iSdO4.png" alt="image-20220322230658737" style="zoom: 80%;" />
</blockquote>
</li>
<li><p><strong>一般约束（企业约束）</strong></p>
<p>  在创建和修改表时使用CHECK&#x2F;UNIQUE，还可以&#x3D;&#x3D;CREATE ASSERTION（设置断言）&#x3D;&#x3D;</p>
<p>  当完整性约束涉及多个关系或者与聚合操作有关，则可以采用SQL的断言机制来完成</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ASSERTION AssertionName</span><br><span class="line"><span class="keyword">CHECK</span> (searchCondition)</span><br><span class="line"></span><br><span class="line">#限制staff不能管理太多的房产</span><br><span class="line"><span class="keyword">CREATE</span> ASSERTION StaffNotHandlingTooMuch</span><br><span class="line"><span class="keyword">CHECK</span> (<span class="keyword">NOT</span> <span class="keyword">EXISTS</span> </span><br><span class="line">           (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">            <span class="keyword">FROM</span> PropertyForRent</span><br><span class="line">            <span class="keyword">GROUP</span> <span class="keyword">BY</span> staffNo</span><br><span class="line">            <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">100</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<img data-src="https://s2.loli.net/2022/03/22/Ihst97CnifNJAq1.png" alt="image-20220322231603163" style="zoom: 67%;" />



<h3 id="过程性完整性约束：触发器"><a href="#过程性完整性约束：触发器" class="headerlink" title="过程性完整性约束：触发器"></a>过程性完整性约束：触发器</h3><ul>
<li><p>概念：一类靠事件驱动的特殊过程，一旦由某个用户定义，任何触发该触发器的事件发生时，均由<strong>服务器</strong>自动激活相应的触发器。</p>
</li>
<li><p>三要素：触发事件（包括Insert、delete、update等）、触发条件、触发动作</p>
</li>
<li><p>作用：示警（给出提示信息）；满足特定条件时自动执行某项任务以消除负面影响</p>
</li>
<li><p>定义(Full SQL-99的Create Trigger语法)</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name </span><br><span class="line">&#123;BEFORE <span class="operator">|</span> AFTER&#125; &#123;<span class="keyword">INSERT</span> <span class="operator">|</span> <span class="keyword">DELETE</span> <span class="operator">|</span> <span class="keyword">UPDATE</span> [<span class="keyword">OF</span> columnname&#123;,columnname…&#125;]&#125; <span class="keyword">ON</span> tablename #触发事件[<span class="keyword">REFERENCING</span> corr_name_def &#123;, corr_name_def…&#125;]  #旧值或新值名表</span><br><span class="line">[<span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="operator">|</span> <span class="keyword">FOR</span> <span class="keyword">EACH</span> STATEMENT]  </span><br><span class="line">[<span class="keyword">WHEN</span> (search_condition)]   #触发条件</span><br><span class="line">&#123;	</span><br><span class="line">	statement <span class="operator">|</span>          #触发动作，为单个或一系列<span class="keyword">SQL</span>语句</span><br><span class="line">	<span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span> statement; </span><br><span class="line">	&#123;statement; …&#125; </span><br><span class="line">	<span class="keyword">END</span></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">#eg 设计一个用于s_c的触发器，该触发器规定，如果需要修改成绩，则需要保证修改之后的成绩不得低于之前的成绩，否则拒绝修改</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trig_grade</span><br><span class="line">AFTER <span class="keyword">UPDATE</span> <span class="keyword">OF</span> grade <span class="keyword">ON</span> s_c</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">OLD</span> <span class="keyword">AS</span> oldg, <span class="keyword">NEW</span> <span class="keyword">AS</span> newg</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (oldg.grade <span class="operator">&gt;</span> newg.grade)</span><br><span class="line">	<span class="keyword">UPDATE</span> s_c</span><br><span class="line">	<span class="keyword">SET</span> GRADE <span class="operator">=</span> oldg.grade</span><br><span class="line">	<span class="keyword">WHERE</span> cno <span class="operator">=</span> oldg.cno <span class="keyword">AND</span> sno <span class="operator">=</span> oldg.sno;  #根据主键找到该元组</span><br></pre></td></tr></table></figure>

<blockquote>
<p>几点说明：</p>
<ul>
<li><p>触发器名是一个标识符，在其所属的模式里是唯一的</p>
</li>
<li><p>ON&lt;表名&gt;子句里的表必须和触发器位于同一个模式中</p>
</li>
<li><p>定义行的相关名字的corr_name_def 如下:</p>
<p>  {OLD [ROW] [AS] old_row_corr_name</p>
<p>  | NEW [ROW] [AS] new_row_corr_name</p>
<p>  | OLD TABLE [AS] old_table_corr_name</p>
<p>  | NEW TABLE [AS] new_table_corr_name}</p>
</li>
<li><p>如果在触发器定义中省略WHEN子句，即省略触发条件，则触发动作在触发器被激活后立即发生</p>
</li>
<li><p>触发动作可以是单个或一系列SQL语句，若为一系列，需要使用BEGIN ATOMIC…END子句，语句之间用分号隔开</p>
</li>
<li><p>注意触发器级联问题，防止一个触发动作引发一系列连锁反应（一个触发器的动作引发另一个触发器的动作）以致失控</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="两种完整性约束的对比"><a href="#两种完整性约束的对比" class="headerlink" title="两种完整性约束的对比"></a>两种完整性约束的对比</h3><ul>
<li><p>非过程性完整性约束：种类和能力有限但易于理解；直接为系统所知；难以给出约束不满足时的相应动作</p>
</li>
<li><p>过程性完整性约束：给出了约束不满足时的相应动作；保证事物的一致性</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库安全</title>
    <url>/2022/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="四、数据库安全"><a href="#四、数据库安全" class="headerlink" title="四、数据库安全"></a>四、数据库安全</h1><p>数据库安全性的定义：对数据库进行安全控制，保护数据库以防止&#x3D;&#x3D;不合法的使用&#x3D;&#x3D;（包括对数据库的查询和修改）所造成的数据泄露、更改或破坏。</p>
<p>数据库系统的安全模型：层层设防</p>
<img data-src="https://s2.loli.net/2022/03/29/Rd34US7IDsHQFx6.png" alt="image-20220329101709334" style="zoom:67%;" />

<h2 id="1、用户标识与鉴别"><a href="#1、用户标识与鉴别" class="headerlink" title="1、用户标识与鉴别"></a>1、用户标识与鉴别</h2><ul>
<li><p>概念：一种用来判断用户身份是否属实的机制，是系统提供的<strong>最外层安全保护措施</strong></p>
<blockquote>
<p>标识（Identification）：身份声明。用户标识由用户名和用户标识号组成（用户标识号在系统整个生命周期内唯一）</p>
<p>鉴别（Authentication ）：检验身份声明的有效性</p>
</blockquote>
</li>
<li><p>用户身份鉴别的方法：</p>
<ul>
<li><p>静态口令鉴别：口令一经设置不再改变，静态口令一般由用户自己设定。易于实现也易泄露，不能对抗穷举攻击等等。</p>
</li>
<li><p>动态口令鉴别：口令是动态变化的，一次一密。eg. 手机验证码</p>
</li>
<li><p>生物特征鉴别：通过每个用户所独有的生物特征进行认证的技术</p>
</li>
<li><p>智能卡鉴别：智能卡是一种不可复制的硬件，内置集成电路的芯片，具有硬件加密功能</p>
<p>  可以考虑多种方法并举</p>
</li>
</ul>
</li>
<li><p>数据库系统用户认证</p>
<ul>
<li>系统管理员通过创建用户帐号来管理用户对计算机系统资源的访问.给定&#x3D;&#x3D;每一位用户一个唯一的标识符和口令&#x3D;&#x3D;,操作系统通过它来判断用户的身份。</li>
<li>DBA负责为DBMS用户建立用户帐号和口令</li>
<li>用户认证的位置和方法：一张有效用户标识符和相关口令清单</li>
<li>方式：通过操作系统&#x2F;数据库&#x2F;网络服务认证</li>
</ul>
</li>
</ul>
<h2 id="2、DBMS的存取控制子系统"><a href="#2、DBMS的存取控制子系统" class="headerlink" title="2、DBMS的存取控制子系统"></a>2、DBMS的存取控制子系统</h2><ul>
<li><p>不同的用户有不同的权限，这由数据库的存取控制机制实现.      eg.DBA拥有所有权限</p>
</li>
<li><p><strong>所有权：</strong>对象的创建者拥有对象,并能够分配对象的相应特权</p>
</li>
<li><p><strong>特权：</strong></p>
<p>  &#x3D;&#x3D;一个策略 两种原则&#x3D;&#x3D;</p>
<ul>
<li><strong>最小特权策略</strong>：只有一个人工作需要的才是他应该知道的</li>
<li><strong>“封闭系统”原则</strong>：&#x3D;&#x3D;默认拒绝&#x3D;&#x3D;。虽然给予用户访问DBMS的权利，但当&#x3D;&#x3D;访问特定数据库对象时需要显式的授权&#x3D;&#x3D;，由DBA或对象的拥有者来执行这个授权过程</li>
<li><strong>“开放系统”原则</strong>：&#x3D;&#x3D;默认允许&#x3D;&#x3D;。与封闭系统原则正好相反，允许用户对数据库的所有对象都拥有访问权限，这时,访问控制可通过&#x3D;&#x3D;显式地去除用户的特权&#x3D;&#x3D;来实现。简单但不够安全</li>
</ul>
</li>
<li><p><strong>授权控制&#x2F;访问控制&#x2F;存取控制：</strong></p>
<ul>
<li><p>概念：授予一个主体权利或特权,使其能够实现对系统或者系统对象的合法访问</p>
</li>
<li><p>组成：定义用户权限、合法权限检查</p>
  <img data-src="https://s2.loli.net/2022/03/28/yQN8WExhAqHluCX.png" alt="image-20220328184353188" style="zoom:67%;" /></li>
</ul>
</li>
<li><p>&#x3D;&#x3D;存取控制的策略：&#x3D;&#x3D;</p>
<ul>
<li><p>&#x3D;&#x3D;自主存取策略：&#x3D;&#x3D;（Discretionary Access Control , DAC）</p>
<ul>
<li><p>概念：是基于用户身份或所属工作组来进行访问控制的一种手段。用户<strong>对于不同的数据对象有相应的存取权限</strong>，而且用户还可以将其拥有的存取权限<strong>转授</strong>给其他用户。</p>
</li>
<li><p>用户分类与权限：</p>
<ul>
<li><p>系统用户（或DBA）：拥有全部权限</p>
</li>
<li><p>数据对象的属主：是创建某个数据对象的用户表，拥有该对象的权限</p>
</li>
<li><p>一般用户：经过授权被允许进行特定操作的用户 </p>
</li>
<li><p>公共用户（PUBLIC）：全体用户，便于共享操作而设置</p>
</li>
</ul>
<blockquote>
<p>SQL中提供CREATE USER 等语句管理用户</p>
</blockquote>
</li>
<li><p>授权粒度（用户访问的数据对象的粒度）：数据库&#x2F;表&#x2F;字段。</p>
<blockquote>
<p>授权粒度越细，授权子系统越灵活，但系统定义与检查权限的开销也越大</p>
</blockquote>
</li>
<li><p><img data-src="https://s2.loli.net/2022/03/28/v8HkOgAE6nYMCox.png" alt="image-20220328185545227"></p>
<blockquote>
<p>谓词是计算结果为逻辑值（为：TRUE、FALSE、UNKNOWN）的逻辑表达式。<br>不直接支持存取谓词的系统中，通过视图可以间接地实现支持存取谓词的用户权限定义。</p>
</blockquote>
</li>
<li><p>自主存取控制是与数据值有关的授权，灵活且易于实现，但由于数据本身并无安全性标志，可能会有无意泄漏问题</p>
</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;强制存取策略&#x3D;&#x3D; (Mandatory Access Control, MAC)</p>
<ul>
<li><p>定义：是基于被访问对象的信任度进行权限控制的一种手段。每一个数据对象被标以一定的密级，每一个用户也被授予某一个级别的许可证。对于任意一个对象，只有具有合法许可证的用户才可以存取。<strong>对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体。</strong></p>
</li>
<li><p>强制访问控制的实施由DBMS完成，但许可证与密级标记由专门的安全管理员设置</p>
</li>
<li><p>主体：系统中的活动实体，包含用户和用户的进程</p>
</li>
<li><p>客体：系统中的被动实体，被主体操纵</p>
</li>
<li><p>敏感度标记：主体的敏感度标记称为许可证级别；客体的敏感度标记称为密级。</p>
<blockquote>
<p>仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体；仅当主体的许可证级别（小于或）等于客体的密级时，该主体才能写相应的客体。 <strong>“下读上写”</strong></p>
<img data-src="https://s2.loli.net/2022/03/28/iWFbB3pIgTkR4GC.png" alt="image-20220328190807758" style="zoom:67%;" />
</blockquote>
</li>
<li><p>比较严格和安全</p>
</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;基于角色的存取控制&#x3D;&#x3D; (RBAC)</p>
<ul>
<li><p>定义：用户通过角色与权限进行关联。每一种角色对应一组相应的权限。一旦用户被分配了适当的角色后，该用户就拥有此角色的所有操作权限。 &#x3D;&#x3D;角色本质上是权限的集合&#x3D;&#x3D; </p>
  <img data-src="https://s2.loli.net/2022/03/28/QPHZD64NiTeCOM5.png" alt="image-20220328193107662" style="zoom:67%;" />
</li>
<li><p>优点：简化用户的权限管理，减少系统的开销</p>
<blockquote>
<p><strong>SQL中提供CREAT ROLE等语句进行角色管理</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="x3D-x3D-3、授权与回收-x3D-x3D"><a href="#x3D-x3D-3、授权与回收-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;3、授权与回收&#x3D;&#x3D;"></a>&#x3D;&#x3D;3、授权与回收&#x3D;&#x3D;</h2><ul>
<li><p>&#x3D;&#x3D;授权：SQL中的GRANT语句&#x3D;&#x3D;</p>
<ul>
<li><p>作用：表(基本表或视图)的所有者授予一个或一类用户访问表的各种权利</p>
</li>
<li><p>局限性：不能根据数据内容进行授权</p>
</li>
<li><p>形式：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &#123;<span class="keyword">ALL</span> PRIVILEGES <span class="operator">|</span> privilege[, privilege] ...&#125; #多种权利</span><br><span class="line"><span class="keyword">ON</span> [<span class="keyword">TABLE</span>]&#123;〈tablename〉<span class="operator">|</span> 〈viewname〉&#125; #一次针对一个对象</span><br><span class="line"><span class="keyword">TO</span> &#123;PUBLIC <span class="operator">|</span>〈username〉[,〈username〉] ...&#125; #多个用户，其中PUBLIC是公共用户</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION];</span><br><span class="line"></span><br><span class="line">#eg</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">UPDATE</span>(sno)</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> s_c</span><br><span class="line"><span class="keyword">TO</span> U1, U2;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一些说明：</p>
<ul>
<li><code>privilege</code>包括<code>SELECT、DELETE、INSERT、UPDATE [columnname [, columnnane]…]、REFERENCES [columnname [, columnnane]…]、ALTER、INDEX等等</code>，对于视图只有<code>SELECT、DELETE、INSERT、UPDATE</code></li>
<li><code>WITH GRANT OPTION</code>用于实现转授，即被授权的用户还可以将权利授予其他用户，但不允许循环授权</li>
<li><strong>每条GRANT语句只能针对一个对象（表）</strong></li>
<li>可同时向<strong>多个用户</strong>授予对同一对象的<strong>多种权力</strong></li>
<li>访问列&#x2F;行的安全性可以通过视图来实现；在视图上授予更新权限时，视图必须是可更新的；表的所有者自动拥有表的所有权限,而且不能被取消</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
</li>
<li><p>&#x3D;&#x3D;回收：SQL中的REVOKE语句&#x3D;&#x3D; &#x3D;&#x3D;GRANT的反操作&#x3D;&#x3D;</p>
<ul>
<li><p>作用：收回已授予给用户的特权</p>
</li>
<li><p>形式： </p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#X<span class="operator">/</span><span class="keyword">Open</span> <span class="keyword">SQL</span>的<span class="keyword">REVOKE</span>语句的语法（基本<span class="keyword">SQL</span>目前不支持&#123;CASCADE <span class="operator">|</span> RESTRICT&#125; 子句）</span><br><span class="line"><span class="keyword">REVOKE</span> [<span class="keyword">GRANT</span> OPTION <span class="keyword">FOR</span>]</span><br><span class="line">&#123;<span class="keyword">ALL</span> PRIVILEGES <span class="operator">|</span> privilege[，privilege] ...&#125;</span><br><span class="line"><span class="keyword">ON</span> [<span class="keyword">TABLE</span>]&#123;〈tablename〉<span class="operator">|</span> 〈viewname〉&#125;</span><br><span class="line"><span class="keyword">FROM</span> &#123;PUBLIC <span class="operator">|</span>〈username〉[，〈username〉] ...&#125;</span><br><span class="line">&#123;CASCADE <span class="operator">|</span> RESTRICT&#125;;</span><br><span class="line"></span><br><span class="line">#eg</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">ON</span> Staff</span><br><span class="line">CASCADE</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一些说明：</p>
<ul>
<li><p><code>GRANT OPTION FOR</code>指撤销 允许转授 的这种特权</p>
</li>
<li><p><code>ALL PRIVIEGES</code>指该用户被授予的对指定对象所拥有的所有特权</p>
</li>
<li><p><code>CASCADE</code>的作用是删除与当前被撤消的权限有依赖关系的视图或删除依赖于<code>REFERENCES</code>权限的外键约束；如果有这样的依赖关系，<code>RESTRICT</code>将不允许执行<code>REVOKE</code>语句</p>
</li>
<li><p>其他用户授予该用户的特权不受影响</p>
  <img data-src="https://s2.loli.net/2022/03/29/HAcK2Nrinv83DBR.png" alt="image-20220329112258945" style="zoom:67%;" /></li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="x3D-x3D-4、角色-x3D-x3D"><a href="#x3D-x3D-4、角色-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;4、角色&#x3D;&#x3D;"></a>&#x3D;&#x3D;4、角色&#x3D;&#x3D;</h2><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/367873840">MySQL角色(role)功能介绍 - 知乎 (zhihu.com)</a></p>
<ul>
<li><p>概念：&#x3D;&#x3D;操作权限的集合&#x3D;&#x3D;，eg.学生、老师。一个用户可以有不同的角色</p>
  <img data-src="https://s2.loli.net/2022/03/28/QPHZD64NiTeCOM5.png" style="zoom:67%;" />
</li>
<li><p>数据库预定义角色：指数据库建立时，系统自动创建的角色。如CONNECT（允许进入数据库）、RESOURCE（允许创建数据库对象）、DBA</p>
</li>
<li><p>与角色相关的SQL语句</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#角色的创建</span><br><span class="line"><span class="keyword">CREATE</span> ROLE <span class="operator">&lt;</span>角色名<span class="operator">&gt;</span> </span><br><span class="line"></span><br><span class="line">#eg</span><br><span class="line"><span class="keyword">CREATE</span> ROLE R1;</span><br></pre></td></tr></table></figure>

  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#角色的删除</span><br><span class="line"><span class="keyword">DROP</span> ROLE <span class="operator">&lt;</span>角色名<span class="operator">&gt;</span> </span><br></pre></td></tr></table></figure>

  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#给角色授权，跟给普通用户的授权是一样的</span><br><span class="line"><span class="keyword">GRANT</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]...</span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span>对象名   #一个对象</span><br><span class="line"><span class="keyword">TO</span> <span class="operator">&lt;</span>角色<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>角色<span class="operator">&gt;</span>]...</span><br><span class="line"></span><br><span class="line">#eg</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">INSERT</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student </span><br><span class="line"><span class="keyword">TO</span> R1;</span><br></pre></td></tr></table></figure>

  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查看角色的授权</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> grants <span class="keyword">for</span> <span class="string">&#x27;dev_role&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Grants <span class="keyword">for</span> dev_role@<span class="operator">%</span>                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> `dev_role`@`<span class="operator">%</span>`      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> `db1`.<span class="operator">*</span> <span class="keyword">TO</span> `dev_role`@`<span class="operator">%</span>` <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------------------+</span></span><br></pre></td></tr></table></figure>

  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#确定当前会话中哪些角色处于活动状态</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">CURRENT_ROLE</span>();</span><br></pre></td></tr></table></figure>

  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 使用 <span class="keyword">set</span> <span class="keyword">default</span> role 命令激活角色</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> ROLE <span class="keyword">ALL</span> <span class="keyword">TO</span> dev1;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.77</span> sec)</span><br></pre></td></tr></table></figure>

  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#将一个角色授予其他的角色或用户，授予者是角色的创建者或拥有在这个角色上的ADMIN OPTION</span><br><span class="line"><span class="keyword">GRANT</span> <span class="operator">&lt;</span>角色<span class="number">1</span><span class="operator">&gt;</span>[,<span class="operator">&lt;</span>角色<span class="number">2</span><span class="operator">&gt;</span>]…</span><br><span class="line"><span class="keyword">TO</span> <span class="operator">&lt;</span>角色<span class="number">3</span><span class="operator">&gt;</span>[,<span class="operator">&lt;</span>用户<span class="number">1</span><span class="operator">&gt;</span>]… </span><br><span class="line">[<span class="keyword">WITH</span> ADMIN OPTION]  #允许转授</span><br><span class="line"></span><br><span class="line">#eg</span><br><span class="line"><span class="keyword">GRANT</span> R1 </span><br><span class="line"><span class="keyword">TO</span> 王平,张明,赵玲;</span><br></pre></td></tr></table></figure>

  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#角色权限的收回，<span class="keyword">REVOKE</span>的执行者是角色的创建者或者拥有在这个（些）角色上的ADMIN OPTION</span><br><span class="line">#可以通过回收角色的权限来修改角色的权限</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="operator">&lt;</span>权限<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>权限<span class="operator">&gt;</span>]…</span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>对象类型<span class="operator">&gt;</span> <span class="operator">&lt;</span>对象名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>角色<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>角色<span class="operator">&gt;</span>]…</span><br><span class="line"></span><br><span class="line">#eg</span><br><span class="line"><span class="keyword">REVOKE</span> R1    #本质上，角色就是权限的集合</span><br><span class="line"><span class="keyword">FROM</span> 王平;</span><br><span class="line"></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">TABLE</span> Student</span><br><span class="line"><span class="keyword">FROM</span> R1；</span><br></pre></td></tr></table></figure>

<blockquote>
<p>指定了WITH ADMIN OPTION则获得某种权限的角色或用户还可以把这种权限授予其他角色</p>
<p>一个角色的权限是指直接授予这个角色的全部权限加上其他角色授予这个角色的全部权限</p>
</blockquote>
</li>
</ul>
<p>》查询用户权限：SELECT FROM USER …</p>
<h2 id="5、视图与权限"><a href="#5、视图与权限" class="headerlink" title="5、视图与权限"></a>5、视图与权限</h2><ul>
<li><p>把要保密的数据对无权存取这些数据的用户隐藏起来，对数据提供一定程度的安全保护</p>
</li>
<li><p>进行存取权限控制时可以给不同用户定义不同的视图，把数据对象限制在一定范围内</p>
</li>
<li><p>间接地实现支持存取谓词的用户权限定义</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#建立视图</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> CS_Student</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#在视图上进一步定义存取权限</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ON</span> CS_Student</span><br><span class="line"><span class="keyword">TO</span> 王平;</span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILIGES</span><br><span class="line"><span class="keyword">ON</span> CS_Student</span><br><span class="line"><span class="keyword">TO</span> 张明;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6、审计"><a href="#6、审计" class="headerlink" title="6、审计"></a>6、审计</h2><ul>
<li><p><strong>概念：</strong>把用户对数据库的<strong>所有操作</strong>自动记录下来放入<strong>审计日志</strong>中，DBA可以利用审计跟踪的信息，找出非法存取数据的人、时间和内容等。 </p>
<blockquote>
<p>审计日志与恢复机制中的日志的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>审计日志</th>
<th>恢复日志</th>
</tr>
</thead>
<tbody><tr>
<td><strong>记录的内容</strong></td>
<td>所有操作</td>
<td>只记录更新操作</td>
</tr>
<tr>
<td><strong>记录的组织方式</strong></td>
<td>按操作的对象</td>
<td>按时间顺序</td>
</tr>
</tbody></table>
</blockquote>
</li>
<li><p><strong>作用</strong>：调查可疑的活动；监视并收集某类数据库活动的信息</p>
</li>
<li><p><strong>可选性</strong>：DBA可以根据应用对安全性的要求，灵活地打开或关闭审计功能以及选择对哪些操作进行审计</p>
<blockquote>
<p>审计很费时间和空间，主要用于安全性要求较高的部门</p>
</blockquote>
</li>
<li><p><strong>审计事件</strong>：服务器事件、系统权限（对系统拥有的结构或模式对象进行操作的审计）、语句事件、模式对象事件</p>
</li>
<li><p><strong>审计功能</strong>：审计分析和报表功能、审计日志管理功能（审计日志必须先转储后删除；只允许审计员查阅和转储审计记录；…）、提供专门视图等等</p>
</li>
</ul>
<h2 id="7、数据加密与统计数据库的安全"><a href="#7、数据加密与统计数据库的安全" class="headerlink" title="7、数据加密与统计数据库的安全"></a>7、数据加密与统计数据库的安全</h2><ul>
<li><p>数据加密</p>
<ul>
<li>作用：通过将明文转换为密文来防止数据库中数据在存储和传输中失密</li>
<li>两种加密方法：替换、置换（更改明文顺序）</li>
</ul>
</li>
<li><p>统计数据库的安全性</p>
<ul>
<li><p>统计数据库允许用户查询<strong>聚集类型</strong>的信息（例如合计、平均值等），但是不允许查询单个记录信息。</p>
</li>
<li><p>统计数据库中的安全性问题：可能存在着隐蔽的信息通道，使得可以从合法的查询中推导出不合法的信息。</p>
</li>
<li><p>解决办法：</p>
<ul>
<li>规定任何查询至少涉及N个以上的记录</li>
<li>规定两个查询的相交数据项不能超过M个</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>绪论</title>
    <url>/2022/06/23/%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p><strong>DB：数据库</strong>，是按照一定结构组织并长期存储在计算机内的可共享的大量数据的有机集合。</p>
<p><strong>DBMS：数据库管理系统</strong>，是管理和维护数据库的系统软件，是数据库和用户之间的一个接口，其主要作用是在数据库建立、运行和维护时对数据库进行统一的管理控制和提供数据服务。</p>
<span id="more"></span>

<p><code>DBMS的功能：</code>数据定义、数据操作、数据组织和管理、数据库运行管理（核心工作）、数据库的建立和维护、数据接口</p>
<p><strong>DBA：数据库管理人员</strong>，其职责包括决定DB中的信息内容和结构；决定DB的存储结构和存取策略；定义数据的安全性要求和完整性约束条件；监控数据库的使用和运行。</p>
<p><strong>DBS：数据库系统</strong>，是实现有组织地、动态地存储大量关联数据、方便多用户访问的计算机软件、硬件和人组成的系统。</p>
<p><code>DBS的特点：</code>①数据的高度结构化；②数据的高共享性；③程序与数据的高独立性；④数据控制力度大（DBMS统一管理和控制数据）<br>$$<br>DBS &#x3D; 计算机系统(硬件、软件平台、人)+DBMS+DB\<br>或\<br>DBS &#x3D; 硬件 + 软件（OS、DB、DBMS、语言及开发工具、DB应用程序）+ 人（DBA、设计者、用户）<br>$$</p>
<p><img data-src="https://s2.loli.net/2022/03/04/7zNQasLYrVqw1px.png"></p>
<h2 id="2、信息模型"><a href="#2、信息模型" class="headerlink" title="2、信息模型"></a>2、信息模型</h2><p>也称概念模型，主要用于数据库设计</p>
<p>表示方法：ER图</p>
<p>基本成分：实体集、属性、联系</p>
<p><img data-src="https://s2.loli.net/2022/03/04/oMmlnGpIqh5iDXO.png"></p>
<h2 id="3、数据模型"><a href="#3、数据模型" class="headerlink" title="3、数据模型"></a>3、数据模型</h2><p>三要素：数据结构、数据操作、数据的完整性约束</p>
<p>三种基本数据模型：层次模型、网状模型、关系模型</p>
<p><strong>3种基本数据模型的比较</strong></p>
<table>
<thead>
<tr>
<th>特点\模型</th>
<th>层次模型</th>
<th>网状模型</th>
<th>关系模型（&#x3D;&#x3D;最重要&#x3D;&#x3D; ）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据结构</strong></td>
<td>树结构</td>
<td>图结构</td>
<td>表结构</td>
</tr>
<tr>
<td><strong>存储方法</strong></td>
<td>按先根顺序存储及用左孩子右兄弟链式存储</td>
<td>链接法</td>
<td>文件</td>
</tr>
<tr>
<td><strong>数据操作</strong></td>
<td>增删改查。按层次顺序查询、按层次路径查询。且每次操作只能取一个记录</td>
<td>操作时必须说明做什么、如何做</td>
<td>增删改查。集合操作，操作对象和操作结果都是关系，即若干元组的集合。存取路径对用户隐藏（安全的同时效率低），用户只需指出干什么。</td>
</tr>
<tr>
<td><strong>数据完整性约束</strong></td>
<td>父子约束、一致性约束、数据的型和值需保持树形结构等</td>
<td>父子约束、主从约束</td>
<td>实体完整性、参照完整性和用户定义的完整性</td>
</tr>
<tr>
<td><strong>联系表示的特点</strong></td>
<td>适合1：n</td>
<td>可以间接表示m：n</td>
<td>便于表示m：n</td>
</tr>
<tr>
<td><strong>联系的方式</strong></td>
<td>通过指针（或路径）</td>
<td>通过指针（或路径）</td>
<td>通过表格自然联系及创建联系</td>
</tr>
<tr>
<td><strong>使用与效率</strong></td>
<td>较难使用、效率较高</td>
<td>使用复杂、效率较高</td>
<td>容易使用，效率较低</td>
</tr>
<tr>
<td><strong>数据操作语言</strong></td>
<td>过程化</td>
<td>过程化</td>
<td>非过程化及过程扩展</td>
</tr>
<tr>
<td><strong>理论基础</strong></td>
<td>无</td>
<td>无</td>
<td>关系理论</td>
</tr>
<tr>
<td><strong>优缺点</strong></td>
<td>①数据结构较简单、查询效率高；②提供良好的完整性支持；③不易表示多对多的联系；④数据操作限制多，独立性较差</td>
<td>①较为直接地描述现实世界；②存取效率较高；③结构较复杂，不易使用；④数据独立性较差</td>
<td>①有坚实的理论基础；②结构简单、易用；③数据独立性及安全性好；④查询效率较低</td>
</tr>
</tbody></table>
<h2 id="4、三级模式结构"><a href="#4、三级模式结构" class="headerlink" title="4、三级模式结构"></a>4、三级模式结构</h2><p><strong>模式</strong>：（也称概念模式&#x2F;逻辑模式）是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公用数据结构。</p>
<p><strong>子模式</strong>：（也称外模式&#x2F;用户模式）是数据库用户所见和使用的局部数据的逻辑结构和特征的描述，是用户所用的数据库结构。子模式是模式的子集，它主要描述用户视图的各记录的组成、相互联系、数据项的特征等。</p>
<p><strong>内模式</strong>：（也称存储模式）是数据物理结构和存储方法的描述，是整个数据库的最低层结构的标识。</p>
<p>三级模式结构示意如下图所示：</p>
<p><img data-src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205081008688.png" alt="image-20220508100815575"></p>
<h2 id="5、二级映像功能"><a href="#5、二级映像功能" class="headerlink" title="5、二级映像功能"></a>5、二级映像功能</h2><p><strong>映像1：子模式&#x2F;模式映像</strong>，是指由模式生成子模式的规则，它定义了各个子模式和模式之间的对应关系。（不唯一）</p>
<p><strong>映像2：模式&#x2F;内模式映像</strong>，是说明模式在物理设备中的存储结构，定义了模式和内模式之间的对应关系。（唯一）</p>
<p><strong>三级模式结构和二级映像的作用：保证了数据库系统的数据能够具有较高的逻辑独立性和物理独立性</strong></p>
<blockquote>
<p>数据冗余：</p>
<p><img data-src="https://s2.loli.net/2022/05/14/pExd5HsrKunezmM.png" alt="image-20220514221005579"></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>关系范式</title>
    <url>/2022/06/27/%E5%85%B3%E7%B3%BB%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="六、关系范式"><a href="#六、关系范式" class="headerlink" title="六、关系范式"></a>六、关系范式</h1><h1 id="UNIT-14-规范化与函数依赖"><a href="#UNIT-14-规范化与函数依赖" class="headerlink" title="UNIT 14  规范化与函数依赖"></a>UNIT 14  规范化与函数依赖</h1><h2 id="14-1-规范化的概念"><a href="#14-1-规范化的概念" class="headerlink" title="14.1 规范化的概念"></a>14.1 规范化的概念</h2><ul>
<li>&#x3D;&#x3D;规范化&#x3D;&#x3D;是将属性分配给一个实体的过程，用以减少数据冗余和减少更新异常。这个过程实际上就是将一个低一级范式的关系模式，通过&#x3D;&#x3D;模式分解&#x3D;&#x3D;转换为若干个高一级范式的关系模式的集合的过程。这个转换过程是通过分析和消除属性间的数据依赖关系来实现的</li>
<li>属性可分为主属性和非主属性。 <ul>
<li>2NF, 3NF考察非主属性和键的关系，</li>
<li>BCNF考察主属性和键的关系。</li>
</ul>
</li>
<li>属性间的依赖关系包括&#x3D;&#x3D;函数依赖和多值依赖&#x3D;&#x3D;。 <ul>
<li>1NF, 2NF, 3NF, BCNF考察了函数依赖关系；</li>
<li>4NF考察了多值依赖。</li>
</ul>
</li>
</ul>
<h2 id="14-2-不好的数据库设计中的异常"><a href="#14-2-不好的数据库设计中的异常" class="headerlink" title="14.2 不好的数据库设计中的异常"></a>14.2 不好的数据库设计中的异常</h2><ul>
<li><p><strong>数据冗余</strong></p>
</li>
<li><p><strong>修改复杂</strong>：如果更改表所对应的某个实体实例或者关系实例的单个属性时，需要进行多行更新，那么就说这个表存在更新异常</p>
</li>
<li><p><strong>插入异常</strong>：无法插入某个实体实例（因为缺少某些属性的值）</p>
</li>
<li><p><strong>删除异常</strong>：如果删除表的某一个实体实例或关系实例时，导致丢失另一个不同实体实例或关系实例的信息。</p>
<blockquote>
<p>出现更新异常的原因：在这单个模式中存在某些不好的数据依赖，如函数依赖，多值依赖</p>
</blockquote>
<p>  <img data-src="https://s2.loli.net/2022/04/19/JGpYa7H8OQqsRkj.png" alt="image-20220419183844031"></p>
</li>
</ul>
<h2 id="14-3-函数依赖"><a href="#14-3-函数依赖" class="headerlink" title="14.3 函数依赖"></a>14.3 函数依赖</h2><ul>
<li><p>&#x3D;&#x3D;定义：&#x3D;&#x3D;</p>
<ul>
<li>设R（U）（也可写作R&lt;U, F&gt;）是属性集U上的关系模式。 X，Y是U的子集。若对于R（U）的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称X函数确定Y或Y函数依赖于X，记作X→Y。</li>
<li>👉若R的任意关系有：对X中的每个属性值，在Y中都有惟一的值与之对应，则称Y函数依赖于X。</li>
</ul>
<p>  👉函数依赖是语义范畴的概念，只能通过&#x3D;&#x3D;语义&#x3D;&#x3D;确定</p>
<p>  👉函数依赖要求对关系模式的所有关系都成立，不能只看当前给出的表</p>
</li>
<li><p>&#x3D;&#x3D;函数依赖与属性间的关系：&#x3D;&#x3D;</p>
<ul>
<li>若X，Y是1—1关系，则存在 X→Y或Y → X 。如学号与借书证号</li>
<li>若X，Y是 m—1关系，则存在 X→Y 但 Y  <img data-src="https://s2.loli.net/2022/04/19/G9gCR1yLKodJeq7.png" alt="image-20220419184951354">  X。如学号与姓名</li>
<li>若X，Y是 m—n关系，则X，Y间不存在函数依赖关系。如姓名与课程</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;平凡、非平凡的函数依赖&#x3D;&#x3D;（一般考虑非平凡的函数依赖）</p>
  <img data-src="https://s2.loli.net/2022/04/19/wIWre3JHfdxbFOV.png" alt="image-20220419185438861" style="zoom:80%;" />
</li>
<li><p>&#x3D;&#x3D;部分函数依赖&#x3D;&#x3D;</p>
</li>
</ul>
<img data-src="https://s2.loli.net/2022/04/26/U1Q6YHJzyajN73o.png" alt="image-20220426103558789" style="zoom:80%;" />

<ul>
<li><p>&#x3D;&#x3D;传递函数依赖&#x3D;&#x3D;</p>
<p>  <img data-src="https://s2.loli.net/2022/04/19/r6nXLRBCqNv3scD.png" alt="image-20220419190030879"></p>
</li>
</ul>
<h2 id="14-4-候选键的形式定义"><a href="#14-4-候选键的形式定义" class="headerlink" title="14.4 候选键的形式定义"></a>14.4 候选键的形式定义</h2><ul>
<li>候选键（键）：<img data-src="https://s2.loli.net/2022/04/19/7S6ycDlKYeqQ1wP.png" alt="image-20220419190148283" style="zoom:80%;" /></li>
<li>主键：选定候选键中的一个作为主键，一个关系的主键是唯一的</li>
<li>&#x3D;&#x3D;主属性:&#x3D;&#x3D; 包含在任何一个<strong>侯选键</strong>（不是主键）中的属性</li>
<li>&#x3D;&#x3D;非主属性：&#x3D;&#x3D;不包含在任何一个候选键中的属性</li>
<li>全键：整个属性组为键。例：R(顾客，商品，日期)</li>
</ul>
<h2 id="14-5-范式：2NF、3NF和BCNF"><a href="#14-5-范式：2NF、3NF和BCNF" class="headerlink" title="14.5 范式：2NF、3NF和BCNF"></a>14.5 范式：2NF、3NF和BCNF</h2><h3 id="1、范式"><a href="#1、范式" class="headerlink" title="1、范式"></a>1、范式</h3><ul>
<li><p>范式：关系数据库中符合某一级别的关系模式的集合。所谓“第几范式”，是表示关系的某一种级别，R为第几范式就可以写成 R ∈ xNF。</p>
<p>  <img data-src="https://s2.loli.net/2022/04/19/qMThucJCAGmdkby.png" alt="image-20220419190723383"></p>
</li>
<li><p>&#x3D;&#x3D;第1范式&#x3D;&#x3D;（First Normal Form，简写为1NF）：如果一张表不含有多值属性（有时称为重复字段）和内部结构（比如记录类型）的列， 则称该表为第1范式。&#x3D;&#x3D;消除多值属性和复合属性&#x3D;&#x3D;</p>
<blockquote>
<p>😢1NF中可能存在很多更新异常</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;第2范式&#x3D;&#x3D;（Second Normal Form，简称2NF）：若R∈ INF，且每一个非主属性完全函数依赖于键，则R ∈2NF。&#x3D;&#x3D;消除非主属性对键的部分依赖&#x3D;&#x3D;</p>
<blockquote>
<p>👉如果存在部分依赖，就要将部分依赖的属性从原关系<strong>移</strong>出，移到一个新关系中，同时将这些属性的决定方也<strong>复制</strong>到新关系中。</p>
<p>😢2NF可以消除一些1NF中存在的更新异常，但不能彻底消除更新异常</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;第3范式&#x3D;&#x3D;（Third Normal Form，简称3NF）:若R∈2NF，且每一个非主属性不传递函数依赖于键，则R∈3NF。&#x3D;&#x3D;消除非主属性对键的传递依赖&#x3D;&#x3D;</p>
<blockquote>
<p>👉如果存在传递依赖，就要将传递依赖的属性从原关系<strong>移</strong>出，移到一个新关系中，同时将这些属性的决定方也<strong>复制</strong>到新关系中。</p>
<p>😢3NF可以消除一些2NF中存在的更新异常，但不能彻底消除更新异常</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;BCNF范式&#x3D;&#x3D; (Boyce-Codd Normal Form ， 简称BCNF）: R∈INF，且&#x3D;&#x3D;每一个决定因素都包含键&#x3D;&#x3D;， 则R∈BCNF。&#x3D;&#x3D;只包含两个属性的一定是BCNF&#x3D;&#x3D;</p>
<blockquote>
<p>👉并非所有的3NF都是BCNF</p>
<p>👉如果一个模式属于BCNF，则在函数依赖的范畴内彻底消除了更新异常，但不一定彻底消除了更新异常（因为可能有多值依赖）</p>
</blockquote>
</li>
</ul>
<h3 id="2、例子："><a href="#2、例子：" class="headerlink" title="2、例子："></a>2、例子：</h3><p><img data-src="https://s2.loli.net/2022/04/19/baomCzFL86RX3Yv.png" alt="image-20220419192440920"></p>
<p><img data-src="https://s2.loli.net/2022/04/19/X2PYxjvlK4S58Ns.png" alt="image-20220419192454380"></p>
<p><img data-src="https://s2.loli.net/2022/04/19/1cmvZfPVOstly29.png" alt="image-20220419192518038"></p>
<p><img data-src="https://s2.loli.net/2022/04/19/QdVkBKPzwmTn5cA.png" alt="image-20220419192535685"></p>
<p><img data-src="https://s2.loli.net/2022/04/19/aWdBPgkZGYq6Up8.png" alt="image-20220419192546331"></p>
<p><img data-src="https://s2.loli.net/2022/04/19/2lkKzULxM6N3Vqg.png" alt="image-20220419192600245"></p>
<h3 id="3、规范化过程"><a href="#3、规范化过程" class="headerlink" title="3、规范化过程"></a>3、规范化过程</h3><p><img data-src="https://s2.loli.net/2022/04/19/fhsZzE8HUnFqdPT.png" alt="image-20220419192859741"></p>
<blockquote>
<p>👉使用规范化方法设计数据库的逻辑结构时，并不是要使得到的数据库模式都达到最高范式，而是还需要平衡查询效率和更新代价。如果为了提高查询效率而进行了一些反规范化设计，则需要采取措施处理可能出现的更新异常。</p>
</blockquote>
<h2 id="14-6-多值依赖"><a href="#14-6-多值依赖" class="headerlink" title="14.6 多值依赖"></a>14.6 多值依赖</h2><p><img data-src="https://s2.loli.net/2022/06/05/nkGdT754vgjfIJE.png" alt="image-20220605194741769"></p>
<p><img data-src="https://s2.loli.net/2022/06/05/iYPhvOfSeFM8glu.png" alt="image-20220605194802850"></p>
<h1 id="UNIT-15-数据依赖公理与无损分解"><a href="#UNIT-15-数据依赖公理与无损分解" class="headerlink" title="UNIT  15  数据依赖公理与无损分解"></a>UNIT  15  数据依赖公理与无损分解</h1><h2 id="15-1-公理及其推论"><a href="#15-1-公理及其推论" class="headerlink" title="15.1 公理及其推论"></a>15.1 公理及其推论</h2><ul>
<li><p><strong>逻辑蕴含：</strong>设F是关系模式R的函数依赖集，X、Y 是R的属性子集，如果从F的函数依赖中能够推出X$\rightarrow$Y，则称F逻辑蕴涵X$\rightarrow$Y。</p>
</li>
<li><p><strong>Armstrong公理(阿式公理）：</strong></p>
<p>  对R&lt;U, F&gt;（也可写作R(U)，是属性集U上的关系模式）有</p>
<ul>
<li><p><strong>A<del>1</del>自反律</strong>：若Y⊆X ，则X$\rightarrow$Y。 由此可以得到所有的平凡函数依赖都是成立的。</p>
<blockquote>
<p>平凡的函数依赖：$X\rightarrow Y，但Y\subseteq X, 则称X\rightarrow Y是平凡的函数依赖$</p>
</blockquote>
</li>
<li><p><strong>A<del>2</del>增广律：</strong>若X$\rightarrow$Y，则XZ$\rightarrow$YZ。 即函数依赖两边增加相同属性也成立</p>
</li>
<li><p><strong>A<del>3</del>传递律</strong>：若X$\rightarrow$Y、Y$\rightarrow$Z，则X$\rightarrow$Z。即由已知函数依赖可以推导出新依赖</p>
</li>
</ul>
</li>
<li><p><strong>公理的推论：</strong></p>
<ul>
<li><strong>合并规则</strong>：若X$\rightarrow$Y 、 X$\rightarrow$Z，则X$\rightarrow$YZ。 $因为X\rightarrow XY,XY\rightarrow YZ$</li>
<li><strong>分解规则：</strong>若X$\rightarrow$YZ，则X$\rightarrow$Y,X$\rightarrow$Z。 $因为YZ\rightarrow Y,YZ\rightarrow Z$</li>
<li><strong>伪传递规则</strong>：若X$\rightarrow$Y 、WY$\rightarrow$Z，则WX$\rightarrow$Z。 $因为WX\rightarrow WY$</li>
<li><strong>复合规则</strong>：若X$\rightarrow$Y 、W$\rightarrow$V，则XW$\rightarrow$YV。</li>
</ul>
</li>
<li><p><strong>公理系统的特性：</strong>正确性（按阿氏公理推出的依赖都是正确的）、完备性（能推出所有的依赖）</p>
</li>
</ul>
<h2 id="15-2-闭包的概念及其计算"><a href="#15-2-闭包的概念及其计算" class="headerlink" title="15.2  闭包的概念及其计算"></a>15.2  闭包的概念及其计算</h2><h3 id="1、闭包的概念"><a href="#1、闭包的概念" class="headerlink" title="1、闭包的概念"></a>1、闭包的概念</h3><ul>
<li><p>&#x3D;&#x3D;函数依赖集F的闭包F^+^&#x3D;&#x3D;定义为F所逻辑蕴含的函数依赖全体，它包括</p>
<ul>
<li><p>F中的函数依赖，由属性语义决定；</p>
</li>
<li><p>由F推出的非平凡的函数依赖；</p>
</li>
<li><p>由F推出的平凡的函数依赖：A→φ、 A→A、AB→A、….这一类函数依赖与F无关，对R中任何属性都成立</p>
<blockquote>
<p>👉F^+^的计算很麻烦，可能会非常大</p>
</blockquote>
</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;属性集X的闭包&#x3D;&#x3D;：设F是属性集合U上的一个函数依赖集，X⊆U。X<del>F</del>^+^&#x3D;{A|X$\rightarrow$A能由F用阿氏公理导出} 。X<del>F</del>^+^称为属性集X关于F的闭包，也可简写为X^+^。 X<del>F</del>^+^是由X从F中推出的所有函数依赖右部的集合。</p>
<p>  例子：R(A,B,C)中，F&#x3D;{A→B，B→C}，则A<del>F</del>^+^&#x3D;ABC，B<del>F</del>^+^&#x3D;BC，C<del>F</del>^+^&#x3D;C</p>
<blockquote>
<p>👉属性集闭包的计算比F的闭包要容易地多，因此一般计算的是属性集闭包而不是F的闭包</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;定理4.6：&#x3D;&#x3D;$$X\rightarrow Y能从F中用阿氏公理导出的充要条件是：Y⊆X_F^+$$。因此判断X$\rightarrow$Y在不在F^+^中，只需要判断Y是否属于X<del>F</del>^+^</p>
</li>
</ul>
<h3 id="2、闭包的计算-迭代"><a href="#2、闭包的计算-迭代" class="headerlink" title="2、闭包的计算(迭代)"></a>2、闭包的计算(迭代)</h3><img data-src="https://s2.loli.net/2022/04/26/joB6LkeCd4OyDfJ.png" alt="image-20220426102507298" style="zoom: 67%;" />

<img data-src="https://s2.loli.net/2022/04/25/mASyBoQ6zsOd1pv.png" alt="image-20220425144440930" style="zoom:80%;" />

<img data-src="https://s2.loli.net/2022/04/25/5ZDPU2QBCMgYNVS.png" alt="image-20220425144608482" style="zoom: 80%;" />

<blockquote>
<p>&#x3D;&#x3D;判断闭包结束的方法：&#x3D;&#x3D;</p>
<ul>
<li>X^(i+1)^&#x3D;X^i^ </li>
<li>当发现X^i^中包含了所有的属性，即X^i^等于U</li>
<li>当F中的函数依赖的右边再也找不到X^i^中未出现过的属性</li>
<li>在F中未用过的函数依赖的左边已没有X^i^的子集</li>
</ul>
</blockquote>
<h3 id="3、属性集闭包的作用"><a href="#3、属性集闭包的作用" class="headerlink" title="3、属性集闭包的作用"></a>3、属性集闭包的作用</h3><ul>
<li><p><strong>测试超键：</strong>如果X^+^包含所有R的所有属性，那么X是R的超键（不一定是候选键，因为可能有多余的）</p>
<blockquote>
<p><strong>超键：</strong>能唯一区分任意两行数据的属性或属性集。包含超键的多个属性都是超键</p>
<p><strong>候选键</strong>（简称键，也称候选码）：某一属性（或属性集）的值可唯一地表示每一个元组。候选键本身是超键，但其任何真子集都不再是超键。候选键包含的属性为主属性</p>
</blockquote>
</li>
<li><p><strong>检测函数依赖：</strong>判断X-&gt;Y 是否成立，只需判断Y⊆X^+^ 。计算X^+^，然后判断这个属性集闭包是否包含Y</p>
</li>
<li><p><strong>计算F的函数依赖集闭包F^+^：</strong>计算所有可能的属性子集的属性集闭包，综合得到函数依赖集闭包*</p>
</li>
</ul>
<img data-src="https://s2.loli.net/2022/04/26/ObCDxVqJYtAsl2B.png" alt="image-20220426105302299" style="zoom:80%;" />



<h2 id="15-3-函数依赖集的等价"><a href="#15-3-函数依赖集的等价" class="headerlink" title="15.3  函数依赖集的等价"></a>15.3  函数依赖集的等价</h2><ul>
<li><p><strong>定义：</strong>如果F^+^ &#x3D; G^+^ ，就说函数依赖集F覆盖G或F与G等价。</p>
</li>
<li><p><strong>性质：</strong>①若G⊆F，则G^+^⊆F^+^；    ②(F^+^)^+^&#x3D;F^+^</p>
</li>
<li><p><strong>定理4.9：</strong>F与G等价的充分必要条件是F⊆G^+^且G⊆F^+^。</p>
</li>
<li><p>&#x3D;&#x3D;判断方法：&#x3D;&#x3D;</p>
<p>  <img data-src="https://s2.loli.net/2022/04/26/KAzek56rPo9C3hX.png" alt="image-20220426105724444"></p>
</li>
<li><p><strong>例子：</strong></p>
  <img data-src="https://s2.loli.net/2022/04/25/sRbvVpyP136ZNtc.png" alt="image-20220425150223057" style="zoom:80%;" /></li>
</ul>
<h2 id="15-4-最小函数依赖集Fm"><a href="#15-4-最小函数依赖集Fm" class="headerlink" title="15.4  最小函数依赖集Fm"></a>15.4  最小函数依赖集F<del>m</del></h2><ul>
<li><p><strong>定义：</strong>若F满足下列条件，则称其为一个最小函数依赖集F<del>m</del>。</p>
<ul>
<li><p>F中每个函数依赖的右部都是单属性；(即<strong>右部没有多余属性</strong>)</p>
</li>
<li><p>对于F的任一函数依赖X→A，F — {X→A}与F都不等价，即<strong>无多余函数依赖</strong>；</p>
</li>
<li><p>对于F中的任一函数依赖X→A和X的真子集X’，(F-(X→A))U{X’→A}与F都不等价,即<strong>左部无多余属性</strong>。</p>
<blockquote>
<p>⚠注意：F<del>m</del>不是惟一的。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>每个F都与F<del>m</del> 等价</strong></p>
</li>
<li><p>&#x3D;&#x3D;F<del>m</del>的计算（算法4.2）：&#x3D;&#x3D;</p>
<ul>
<li><strong>分解：</strong>使F中任一函数依赖的右部仅含有单属性。</li>
<li><strong>最小化左边的多余属性：</strong><br>  方法：对F中任一XY→A，在F中求X^+^， 若A⊆X，则Y为多余的。</li>
<li><strong>删除冗余的函数依赖：</strong><br>  方法：对F中任一X→A，&#x3D;&#x3D;在F – {X→A}中&#x3D;&#x3D;求X^+^， 若A⊆X^+^，则X→A为多余的。</li>
</ul>
<p>  <img data-src="https://s2.loli.net/2022/06/05/Vk2X54DqueIgUJc.png" alt="image-20220605102019406"></p>
</li>
<li><p><strong>例子1：</strong></p>
<p>  <img data-src="https://s2.loli.net/2022/06/05/Mv3D9tE2lCJAKYd.png" alt="image-20220605102147172"></p>
</li>
<li><p><strong>例子2</strong>：</p>
<p>  <img data-src="https://s2.loli.net/2022/06/05/dWjYyIfEGcq2nBx.png" alt="image-20220605102402476"></p>
</li>
</ul>
<h2 id="15-5-等价模式分解的定义"><a href="#15-5-等价模式分解的定义" class="headerlink" title="15.5  等价模式分解的定义"></a>15.5  等价模式分解的定义</h2><ul>
<li><p>&#x3D;&#x3D;模式分解：&#x3D;&#x3D;将一个关系模式（五元组R（U，D，dom，F））分解成一组等价的关系子模式，包括属性的分解、关系的分解、函数依赖的分解三个方面。</p>
<blockquote>
<p>👉R是关系模式的名称，U是属性集，D是域，dom是U到D的映射，F是函数依赖集</p>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">STUDENT(U,D,dom,F)</span><br><span class="line">U&#123;sno,name,age&#125;　　<span class="operator">/</span><span class="operator">/</span>理解为表的字段集合</span><br><span class="line">D&#123;<span class="type">char</span>,<span class="type">int</span>&#125;　　<span class="operator">/</span><span class="operator">/</span> 理解为表中字段的类型集合</span><br><span class="line">dom&#123;dom(sno)<span class="operator">=</span>dom(name)<span class="operator">=</span><span class="type">char</span>,dom(age)<span class="operator">=</span><span class="type">int</span>&#125;　　<span class="operator">/</span><span class="operator">/</span> 理解为每个字段具体的取值</span><br><span class="line">F&#123;sno<span class="comment">--&gt;name,sno--&gt;age&#125;　　// 理解为表字段的关系</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>模式分解有很多种方法，有好坏之分</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;等价模式分解的要求：属性、关系、依赖&#x3D;&#x3D;</p>
<ul>
<li><p><strong>分解后子模式的属性集与原模式属性集相同</strong></p>
<blockquote>
<p>如果关系模式R(A)被分解为关系模式R<del>1</del>(A<del>1</del>), R<del>2</del>(A<del>2</del>),…, R<del>n</del>(A<del>n</del>),  且A &#x3D; A<del>1</del> ⋃ A<del>2</del> ⋃… ⋃ A<del>n</del>，则该分解是属性等价的分解</p>
<p>👉属性等价是最容易满足的条件</p>
</blockquote>
</li>
<li><p><strong>无损连接性</strong>：查询时的连接操作是否会丢失某些信息或多出某些信息。 </p>
<blockquote>
<p>如果关系模式R(A)被分解为关系模式R<del>1</del>(A<del>1</del>), R<del>2</del>(A<del>2</del>),…, R<del>n</del>(A<del>n</del>), 且R&#x3D; R<del>1</del> ⋈ R<del>2</del> ⋈ … ⋈ R<del>n</del>，则该分解是无损连接的分解</p>
<p>如果要具有无损连接性，则必须满足属性等价且具有冗余属性（<code>这个冗余属性应和函数依赖结合考虑</code>），但满足属性等价且有冗余属性的分解不一定具有无损连接性，例子：</p>
<img data-src="https://s2.loli.net/2022/04/25/vOFjr8IW5GBhleP.png" alt="image-20220425153433324" style="zoom: 50%;" />
</blockquote>
</li>
<li><p><strong>保持函数依赖</strong>：分解后的模式满足的函数依赖集是否能蕴含分解前的依赖集</p>
<blockquote>
<img data-src="https://s2.loli.net/2022/04/25/qCfhVvyYjDJcP5l.png" alt="image-20220425153531696" style="zoom:67%;" /></blockquote>
</li>
</ul>
</li>
<li><p>例子：</p>
  <img data-src="https://s2.loli.net/2022/04/25/j9AmzyD6BlWCnN8.png" alt="image-20220425154123589" style="zoom:80%;" />

  <img data-src="https://s2.loli.net/2022/04/25/g4XmCRl8Fy19qwc.png" alt="image-20220425154134781" style="zoom:80%;" /></li>
</ul>
<h2 id="15-6-无损连接性"><a href="#15-6-无损连接性" class="headerlink" title="15.6  无损连接性"></a>15.6  无损连接性</h2><ul>
<li><p>&#x3D;&#x3D;概念：&#x3D;&#x3D;R&lt;U，F&gt;，若R的分解ρ&#x3D;{R<del>1</del>, R<del>2</del>….R<del>k</del>}对R中任何一个关系r，有：r &#x3D; Π<del>R1</del>(r) ⋈ Π<del>R2</del>(r) ⋈ … ⋈ Π<del>Rk</del>(r)，则称分解ρ具有无损连接性</p>
<blockquote>
<p> Π<del>R1</del>(r) 表示关系r在模式R<del>1</del>的属性上的投影</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;判断分解是否具有无损连接性&#x3D;&#x3D;</p>
  <img data-src="https://s2.loli.net/2022/04/25/PC2613TjuMZmyal.png" alt="image-20220425154534993" style="zoom:80%;" />

  <img data-src="https://s2.loli.net/2022/04/25/TwJHi9BX6D8Lg7Z.png" alt="image-20220425154559720" style="zoom:80%;" />

  <img data-src="https://s2.loli.net/2022/04/25/h7ibSVUkmKfnqlI.png" alt="image-20220425154954642" style="zoom:80%;" />

  <img data-src="https://s2.loli.net/2022/04/25/nOEwXzsNcbW8TFH.png" alt="image-20220425155541795" style="zoom: 80%;" />

  <img data-src="https://s2.loli.net/2022/04/25/dyglfmAaVetrUqN.png" alt="image-20220425155623036" style="zoom: 80%;" />

  <img data-src="https://s2.loli.net/2022/05/31/2k6WrVuzDolyKJ7.png" alt="image-20220425155553454" style="zoom:80%;" /></li>
</ul>
<hr>
<blockquote>
<p>&#x3D;&#x3D;特殊情况（只有两个子模式）&#x3D;&#x3D;：</p>
<img data-src="https://s2.loli.net/2022/04/25/A5p4T9EfUoG1IWh.png" alt="image-20220425155902720" style="zoom:80%;" />

<img data-src="https://s2.loli.net/2022/04/25/AuR1ZMPwoak9WeG.png" alt="image-20220425155950975" style="zoom:80%;" />

<img data-src="https://s2.loli.net/2022/04/25/woP8IJCkZ9chieF.png" alt="image-20220425160036787" style="zoom: 80%;" />

<img data-src="https://s2.loli.net/2022/04/25/hP6KGEtWgXnMJov.png" alt="image-20220425160223865" style="zoom:80%;" />

<img data-src="https://s2.loli.net/2022/04/25/tlIirfqhawMRQek.png" alt="image-20220425160107664" style="zoom:80%;" />

<img data-src="https://s2.loli.net/2022/04/25/eO4lZwEg8jhoXQC.png" alt="image-20220425160241463" style="zoom:80%;" />
</blockquote>
<h2 id="15-7-函数依赖保持性"><a href="#15-7-函数依赖保持性" class="headerlink" title="15.7  函数依赖保持性"></a>15.7  函数依赖保持性</h2><ul>
<li><p>&#x3D;&#x3D;Π<del>Z</del>(F)的定义：&#x3D;&#x3D;设F是关系模式 R的函数依赖集，Z是R的一个属性集合，则称Z所涉及到的&#x3D;&#x3D;F^+^&#x3D;&#x3D;中所有的函数依赖为F在Z上的投影，记为**Π<del>Z</del>(F)**，有：Π<del>Z</del>(F)&#x3D;{X→Y|X→Y∈F^+^且XY⊆Z}</p>
<blockquote>
<p>例如F&#x3D;{A→B,C→B,B→D,D→C}，设Z&#x3D;CD，则Π<del>CD</del>(F)&#x3D;{C→D,  D→C}（&#x3D;&#x3D;考察的是F^+^&#x3D;&#x3D;）</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;函数依赖保持性的定义&#x3D;&#x3D;：设关系模式R的一个分解ρ &#x3D; {R<del>1</del>,R<del>2</del>,…,R<del>k</del>}，F是R的函数依赖集，如果F等价于Π<del>R1</del>(F)∪Π<del>R2</del>(F)∪…∪Π<del>Rk</del>(F)，则称分解ρ具有函数依赖保持性。</p>
</li>
<li><p><strong>例子：</strong></p>
  <img data-src="https://s2.loli.net/2022/04/25/a4Io1rjNhXJuHnO.png" alt="image-20220425161014159" style="zoom:80%;" />

  <img data-src="https://s2.loli.net/2022/04/25/9EKBxPi2UXthy6H.png" alt="image-20220425161051699" style="zoom:80%;" />

  <img data-src="https://s2.loli.net/2022/04/25/Xprh7kqT6Mlj4BU.png" alt="image-20220425161138947" style="zoom:80%;" /></li>
</ul>
<h2 id="15-8-模式分解的算法（重点：3NF分解）"><a href="#15-8-模式分解的算法（重点：3NF分解）" class="headerlink" title="15.8  模式分解的算法（重点：3NF分解）"></a>15.8  模式分解的算法（重点：3NF分解）</h2><img data-src="https://s2.loli.net/2022/05/31/ehvC5WJd6LVlGHB.png" alt="image-20220425161643651" style="zoom:80%;" />

<img data-src="https://s2.loli.net/2022/04/25/bJ87MfZP4CLY5r1.png" alt="image-20220425161939694" style="zoom:80%;" />

<img data-src="https://s2.loli.net/2022/04/25/5md4WqKs7ALzfSx.png" alt="image-20220425162252537" style="zoom:80%;" />

<blockquote>
<p>&#x3D;&#x3D;BCNF范式&#x3D;&#x3D; (Boyce-Codd Normal Form ， 简称BCNF）: R∈INF，且&#x3D;&#x3D;每一个决定因素都包含键&#x3D;&#x3D;， 则R∈BCNF。&#x3D;&#x3D;只包含两个属性的一定是BCNF&#x3D;&#x3D;</p>
</blockquote>
<img data-src="https://s2.loli.net/2022/05/31/L1vhbSIQRmkeJ5c.png" alt="image-20220425163039378" style="zoom:80%;" />
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>关系数据库</title>
    <url>/2022/06/23/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="2fb805a0bd5b5c948b1cb6c6e393f74fc31e9906a0c853b2db4f7ae37bcc7bd6">4630436162ade97ba2718b7d0c4b3b6351ade09e539dfebeb5402828e29e64b0761016e52c83ee143be9a5bc90a976e2ce7bd4414cecba87f31f8f630f8358faf93b63e2f4db9923ecb99d84d347b52ef7cedaac6353f41bd6b43e6faec0e92ae6b1e9c75fb1ed04ff1ee326cdf297545372c172113be879360b55e6b9282e0e90b217b4e9e3b0fcb1fc1afdd4f263181e51b00a99f2c1353d8f8d3ab9a8d9791af72cdede615bb5623498c3a4ca208826b6ec6e852de947fdb79c2ea69f86f6d67154fce7626a349dfe5d987d1dffee9a991b1b75e0aba3182bd8013a23d23ed400b6b578d45b6eaf33ec7bbcf37d3f945c4ded18b409f01dcadbd0f1da73940fb4aee3953accc197197639210b4c08889c29ab36f6a677471a4f7499d5a5e23c07b2940f5ade7ba94085f0c8f8c36021aaaa46390281b942b50bced7e7cd06e80a43c38550f9147064470e3172d0056b496aaf8ce749e35477f1c8defd7f929ceb7f1c2c49bbb23ceeb2b8932884c09db3c58e00aee2f2c327dc4a76f211a889187e094a0231c2e3e211cc80168636ce34308a7b23c6941cf8f6a76f500c6c4a27c3d973266173890b1bf2907f4a8edb0f65bece9e5502217496a3b39d02d07d7d486a6629aaf411e574e5def21548aab7fdcfe045f90be1a9229ee92fad8995a75e20ce3d68a9e2c9b13c25687c5f2870b9495f1fed53ca0d78ba09925f80908d5ffcbc4e882a3acb6a160414006025304f671e6f4fd392ccf09ffdaeafc7d184d8f000bc0431f12be9e129fa6d04d439efd3354c488404657a8a3c58f0db643243a396033c91890a63068e36dd98b292799a748b2678fffc32bc46ea8b636b3af488e59dc41fb65b7d7ef23bdd4dfcef854e38073024b7ada01421f65a4151af682b3f561149dd4b620736a0fd52c4eb8fe06d32d4fdf4677f85711b1678e93ae64d3ebd0961a9e19a9a7f234ad63c4798cae46cb0ec5c57a686a8384b76cd8597979cb827caa6c2f22e07ca9bd9ec761069fe19cd959044db80a628eda5dfc1f8ce4f3b4b8d0b1e707aba8a11d46c8ab19bbd9d1027fa41264756f3537edb78c9299e05728a122e868fa1616bdbba4195376d0dd2bde6dd812f928a6f812f17253e44ea1b019720bfcbd9c6a2b87d6ec001b6a75a11c94bca38d524cb6be47ed72b2206627fdd33831bdffad0d8c15aa29ecdbdf6abf699e2bed4de29ed0208e674ef38c2cb36f6e8b3b8d3d65fb44221b4627bcc11722ceccc38a2899c314e90cfb1a5b9cd73eda13b4d5979e851054abeec03bb88f5635b4c695ac86d3ef0de4c7e45e2d8fef1a1ac4b636abb1834170474330a9ab959228af41b6b06568cacfe17e89cffc37d59973a5874d61880bd9df723f81d0652b6ef720dec314424abab9a667a0f0c936d11d7a8197b850649a3f35eadfff8bb04c554a3bcb2016dc1c8a220720775412f1ac2865ff6ccbb15384bea1befb30abace690e3d431f2bc35d93edc8b0aeb11ebb0c0abffac9726cee7187114c3118302b903f52f484b3d0f8d4169b341bc88f8de85c03ed332783596cf12ec1eb529e1a60f1077ec549f4cdb36bb429d95f2af4b6b2932cea94f34404984ad89125260aaecbb212ab861f0b86875a46ef8fa12a0b9a64f36e1ca9010e755bcc7d6bad5d22e34ffbf32f11b135391495e7592170d91e9fc6f4d01f9243d518b85f41157e8b8160ba772d1ad7508e93e28e14998d6acd2f61ffe859bb326ab88bba8ebe267d6c6b6be900e8eb1dc87e262531fdcc06ad177e0954746640758fa9544779e26658a9e265ad8c951fc6d1259ed356149aeb39c29089e6b00f0396b46a70e7d1fb281dc607f556eb2cdb4f5d13585e114feb5ff2512c808cb2d520f24b59fb6ac66ce9c8a1daec31652b7d06d61096498edfddd80a309aa8e1c1a75a0fe378900772733fa151984af29db7bd0a66bd6fd0c4b33be2874d3c7cb46882b961b432babc28f87ba5e60df2a0532d6db191c6f1c8f41731669ecc0fbf94ae508a7a1d9c711a172f2b3566e310efa5635a2b1142a32a8b241b8eb34992908212edc81e3de75beca11bbd13dfe9b040b2f09331b071cc315bd87bf9efd926bfc3328ec123caf45f45fab759e70c63582350466349200faa6afcb58dcc42ff3a6b7ca4fcf15e6fcc7e6bbe7d5ec7f2a99418fb9a7166760f76747a9251a3d09b3a303f1e59afdc0d360ceaa4cccce7579e0993a67f9f884bdff464040b33c75057641af8ecfcfea14ff217d53b77983b71d6c22d62d02582f7ca7875c65c175b3c72367c8ae16535e51311b102d659d906a4a7eb8427a9774eac96937a90d18957a1d3afba0a0489c6385ed3850f60bd20872d4a3718513f657174bcdadc480466d207da336d386dce2830ad5ec8fba06db7d4aa488d4ab9b04cec8a9432234c994a49cda4d6d526f248c2afb59ae3799fc9fc2d10c2edcead90a9b493641d19fc9bbbe9c295fc6676fd173132422eb8737d5633b565edce2152b10efe4b5c138e38df7f4a4fa9e47038e202a20aa9b04b7222453a1638d0b2f8ef17f1a799a234fcbae619815a7db84d1c1a97262eff457384198fd3b70c0dfd33f6f4286a9abdf11d086e543c1345d7b52e92da0747ec4e8bc42ec5fa4d7e5fdd65aad070b300b084d994514e03344d747a942bc5e44de5b2b6f42a19b874fa09eba0e150dc82d0f1eab970ff5f0b53c20fbff3884f41f179c61db1845a7622cedb67520806b9f9a7088f75e08ac07ee2dfb4372c7d87c7d54bc955b4d639a312fe635a26b99807913caa473201b2e929d62ad2b75b058bb3bd444b9cf5b31f1e7050ff762957042f47b5483ee2eb68a36e262a7f91c0229d7b15859c25305466a1e5d2d38368c72503db5398b7029012fe15daff8d47c6c53f45911b1ca1a16173fa74665e83a08bb83511fab4aaffc3f9de27ce7f551703ce7a90ba518a69cd09af7d880b14b1d0b24d1eac3d569e9e9c2355707c75c55358fb659c0ac98113d963ea706dac417ed13fdac8481c33ce8ce69d10ec3b1c1d34030ac2fe19d34e28bcecb37b4cb167cb4f38bad572b738749c37b164e4f336b0763867dc6aa11fb95d5c5ae149264e3aa3b1c756d7a34801fa6287c84794f20b64a8de5ae2f99753747238fa6a92429f10537c53048c137080e2ae1b8e05b45c8cf24c362f13b268c66385c389f22078372a8c75e31de3959185a9dad10f7b065c4e63e460f6e76ba270014e5ee4793d327a24746782ee63d1e7abb88b7a29e14347f2cad0c3f24f9ac023ec28ad904b9a0453eab1ad9943ddf5df132c2de23833c6ac8c0f0dc35ac7f3b9803e3bd28a0f8e7cc594d450255b8972a38fa023f947efb7b72ca6c9560af7be1af73ba4ea79915a96b505e20224b769632e961f5f70acd0d11944e11fc58d3fd21d190ac1c1c354ddffa6624ea0635a3f9c1a07c284d51e5b9af0893cea2247607ba2ff81ccd7527930b082a39d1cd1b363da42a5e83c740523e143c45b605758514415de1de6a89ec4a9e441f7d9b730b70623fccea9677ecdf2aeb32935779c63863a97fdcfab5da0cb47094763f35fda4802567f9ed7b18afe2d92fe6850924b5e3e2823a31e964a588f69a3fd55c49fe2ca42b90a3be1b7ea492a50e1bca496f41af6e27f8f9c0829e0286675377e95aeaff6357b798346e24be6956e479c21813454b3e4c09c7b92a638df2a75d054bce97d651fbaa97df885ce19ceb503e7f826f31704460fa17370cfc1dc9b423ca7c7866ac262759421bdba8e18a97f1851b61ea95fff5fe5d96317ecfbbf9db5f3ad035b2c2bad2fcf14c4f864013493332cdbdffd44fdcb4f7cdc2660f4e98ceee55af76be6bc095924d9ceb2dcc82683128c37c18b3e566171b9e170a066c535f3c2128226e77c65b19a2876a96d6008ebe066f2757a189620e3544c4da19cb140c7b9e9c79b1b7a903417e88caf528a6bf99217eb7b20970b8519ebc95d4ba342ed8d333319c0147372a79bc165124e3df7cb733db003188723f72e0fc32c0f83fb17c86928c145466ee4cb7820f9b3d4027925b7220fe23017524cdc12c6cfdfc6b90130c4e6e202f3042a582d359aa9b699aae7ce1cea4e2f5468aff2e0d06286e1272b22de3813f7db1a107c2efc78f8571afa8a614aef5c49b0b822a9e299677c97de8dfc37a71734577846f99892484346069daaee3441b527781be7a7dab52b4c8e962ff06c67f7f6109f478f3240139c14900b826690113e5950717e12032613f001ef5402af689c3dbf9840910c98cead252a66c2e6c32a5822bf99d0d7d18248994ed456884efd163357205c0f5d10031eb26aaa2ac7dad2e6c95389f95287e03d0dcd69bef32852dc2ca6fefc72dda4227d2ac97db3038167190ff00cda2667d7df0ed71afa041980499945b63c3f55aa6cb986a1850217b5d051a6f9eaf898180e8fd2e3cef793f348a5e669d5b2d91f73be6eeeaa3537ce087c40bed8f145e84f199f2b20f2c0b09f9956dbf7b75c4b7aefc04f64545d70ab5c09368e14c3dacf0122bd4c66a6efacd692823bb54f6506682e01b4eb395287db96f3dda8e4c4162fdb45dbbbfbc6f8aa41fad136ae1308b515d27e590df7ad20585edb6d2c7ff10281bf6fc5f09e0dc827f065805777cbe81f6197b8461450061aedf11f419534c879de7081761f75652cba7d2b9e9856ec3d9d607ce13e24749ac69b2840fc3926afa828e81ca2be00aa9441befa9f9879b4b172f2f590deb03e5b784ad3f22935a79e7c58f65eadf64752a1e8df18c4d093e52943ae3707631013f5a54cf6ae48008e9c7e5c1e0853dca194139008c35f4d59a8f700e9d90c0c1514268b46397e0f573db5d308711e445509412c6421b9dcd8943f2646eeda53305e4a93e0baea97614d8280388b692284705ee3bfe1c41903e200a2b69b4614e0dac2d77f505744702e9bd33de4c2666a22a2ca5312f8fe7bca16dbdee2d84e73e4ee15100fe5b5cfc5aaf5b437649989ec9404bfaacc58b9ac9084c25b9397da8c96883f34a28f14936dca324caf5581088c81c3a7d711552f69e43e85fe54e2c8e68555151d4532f754bfd6116e822b30d6967a808a7ea0b05aebef6527665d93504758f762239b3805836054f49c2226731ffb67836cc51738f8c20d94c2db4074502fb0de896e44d019641e07c5caf215023c44e0d293f479f7d3be719969432049a832f6b57edac09132256bee33dd21c00146f0c3a151a6cc42667d76fbc6c64de9c618eb96ed23061a74b02e18c456f1cf706f864b8db8628d5e7c20c61c0c9d683f3d1871239c23a6b893596e6fb39efebf525721eb553ea6e01df5549eed5e45c367a1fe1b06f248361815cba8746e12abeafb28470cea282b519e2be57d6e1381e64ab52a01528a41bdb0213be880966c129a239d475aa81e146378e8a4b2963ad99014eda11209fb92f68840726f834e727e5c38057d6f5e482f4887da5dac18610659e1199dc106f9a04807c462592163c57d602372c73c947d16d9043d145d3b21a1771cce3ad6b06e43e2d221682b3d4c240e9d91d75b4efa4a6fcd15c32fd88fd8c685a7cd8fea9f616739a405ba67746f3210b897a73a842b15451b73d722fe448edb861c59e8b16eba26e627729c90039b78dfc1ac11ea07f7941f533f69cc47d8bd0edcea8c0e63cd4d3e898b797930d6566a0d12efa2111b665998f483e4c71235a4bffb6c5050645635551d6254fdd781f74db882b100dde8de17bf3a0877fe493a5afb8d32000d6f6ba1ea374fcd0b3db84c7e2593661c2844298d278e0d4ea2f8c5163a04a4a870abf1a3493eb3b7edfc43a7b805c9d30537c4c4fff8e354e708a4c9677800d3db6ce31a32b3e311e7b612e2ee8182df7b4cd3fbcaefacf94f17a961c28cd3f1737caf5742d94aa2eb5e501d7fcf77f5817f69e0412c0c4c2f197be60c56f4d6b4016af5d919956d76d1a8622cf44d8e19c368713bad860d30e4ae878a164bbcea107604c4f22d7de9bc25dcd17aca6feb5c98aa9bc66c07a2ade66ea2689ba44c9e3733e7383b84d9b2d217e02bcab2507f259342a791b2ab9d481ea073c0d3a10c3b2e0c68645b4faafe76261172903b22a86df282d4a8cfb901996347ebea7481be8beee21a79540e71b760c7c4de815a9ec28eefc6cb6c720705043b4ebe9b1b7c821d06ab25b3564cf1a7a56fc4c7cc76ca698497956725e30b288c84680ffc725f50ca284a6f29a3e81124cff2a76e545b44836e3e7895996f9f70038d7cf7488a2926a6216052e9e02cfeb79cc3b5420d6a4c9b99e564dd78fa166074be49a642667205781f6bccc0dbf43107e86994bb460251ae32401e817f9c8c05542011db6e0b6d6fe4747dabdfdbf03b8f4cc0885d0769d4c8045a0f0e621d24c57bb7bdf874f268086eba9f02c634269770fdaf4d94ed1f148484ae5fa5ee7ca7f1f36ab835b3ea0dcdcb04922295e05bc71b76a882d698e704e14dca0a4424d7646aaf14c3b3e67f7dec8badf937f09da031de72c1dd406c4ea44d4eda95fe2650257a22360fa8420eb74dafe55d7504a5a7f83f259e24b38cfc38591e235e3fd36e0d8fb89455aededc943658013806dadacf370446d0e79c668584df34b3cbfce6ebaeba996917e43f6502fa3835c88d3e84cc7b3db3cad97a65482fad8f3830793c1fb3e85b45b5b80e102f3cb91c6a21326138a6f4058ab737d5940adac8053dcf11cadb93578adde5e70b9861e1970cc8df22d6ef085e67cf8ee41cb3860ef1119af09d4a6f14c0e7a72bcb19afc1405d096720c601fbcd4a7aded36f8458ec6cdb83bf27a04ab5f12f806b68f56e051d19a8d7241ea1ebf6e6026b06c87eb8dc27fa3b5b2e09aa9e4d9787a44d1c8beb7ad34c48f67aad56697527132a0c0b2cf0026c85186705f0b7d81058987603c9a66baf60620a407289a9c01710e541262fd5df637b7f84e5daf54342f62ddc071c45a77bb6080afd84e72862e61a165f418c4e2943e8c3b01c819d4c95adc22459d7baa63d972574819ab111844e3c3ec55bdbf4d6ae591be6571242be4fd8d5fa8ecdcd46dc19b2a462326f533d344ce6e5af5e305fcfb549f549bcedd8671721bba67761ac07246f2194f6b867e4831a57fbd5d796b0681ad022f5450e9597387d138b02a65cafa95ebdfda5f3f5996dd12b7a6954b3c8989a60ef8a17fbcb94798bd0aa08fed16347b2ed4ab8d80a3d39f488c26460f6a9878ed3823d2c992e7421addb79a5c2f12b9da6afc455d88e3c5c2be51a43b8fc8b1109101152b50b9ce69c8eb78ac7341147e61ff38d8ff7ee41888572891475132464f1ba7cc72fe66aaa3782e8f09c75d6615522bc3120d4cae62737bc7aa56a0ca48c332a8540d19b84999dff7839859e403d394fbc0b54c3a2212735dbf9f509968cb43577f4531f4af122f9e5d75082496cf2c75924b0bda8e71ad9d18a4ad3695cd25eda3b005942795a32ff9a86a5b603e77f66f0eedf51d227c46ca4507f901ea0f286923ca4992673e6b1d4c358f2811360b49e7c0ae71ea904f153807755854f9c26d343147f64da384f7701a0677902561e626e210e6871ae302af4e6c9a54ccbe6dd4b3ca7524dd9a1087ee387bb38bc566a97e1d8696dc2fb6b0ff7cc648cfd8329976ba70b6f4bfdd7cad39e0185e299a8974f456d3102bf11f9bb1a7d5aa500339ab2bc059c4bdb45ee26a7af6580d49a4c4d4638b33e504f362dfb3db241b0b3429b9106f8467e59e29391ac76a2d8afe28643eeebfa221e83eccb60da052c77fc3ccef6e26eef3396dc22bed815e73971214fe245ec43328a83791e279252163dba3d963a9f540f63738210d389e79f4e19004cc17c13e341d47e29c9f6ba655b1899dce6a4aae39b2478425080ba208e96eed523e5cd552773bbbcd26f76f29f1f468a5786473f623fcaf5f91712d8db7b63a6251833c946df16aaf80afb05d302d73cc22795e09877adc3dac97b5afe3fe154b9e733cf4c64243c6415979affa01f67c32b51c78e0692607e78d5770d2658ed92e048d612765b1571bdeb9f8a26e88a6825a357d9be369f4c48ea48a62917e3c90720870a8720ed8a9bc526d005914a120543fc66b138e4f9392cf47720b89fe2026fea90ae7821dfdb18a277d8b6e2bd77644a8151425bcb62d903e4420a125dfdc71fd9a0a82982c415d98b19d95ec0af902cff9dc5ee934f59959a04251a9aff6297ad08472d5b6e60e044558cc3e1080302979e0f4ac35929f9771defa00bfeeb53fb8fd7bd19e97e8d1866204c383ca69fa05cb39454f50fc08b077dc65edfcafdb7022c7d28642d302a6566375983324dd67463fc8dd3a6442390a6ae5bb973d5db997702632ac0b28420c1ec197e78860f7568adf3e570a1bed9de98ab36c0cf72c82c422f74ba9dc3d82e74eebe5fb38d7fcbb82638e456f72d302fbab17b56e82d6c884137ab1f224cba3894c7266fdcc0587b26ec994f0d224183e998165d2c28fcf34a82eb64f1f22afe0075a8357e50e166accc3d72adcfcd31a8e2f012ae21e0b601cfb5557afa968d7f4da7f67d36e4a6ebe52f4772ba999de6eaa00dfbabd761c97f4b71899d45f90583853b23232f708316de164c0a6401f2fab10d1fb93052e19ba4eef2d182014c87a12064c272fc6f1211bde59b667adb5dee2c0bae538f6b68b7bed07b4e0db32b1a345b4e51c94920ca963aa907e7afeeca73888db11f1e70b4e850c0e05586790cdcbdecf616d18866eee48e4e3d5011ff819d84b5015816942f30cdf66028aaf5f3021b09faa1747a8b29ee06b3a686ec050bfbb51155ed7d7e69e8729adcba5cfec38dc138a791e77bd20253a7ee6e086d33dc60b4af0a42490a45551b3d03366d58e0e2d1866ea3839983f1ad026e1461dc706e4a69bcf0040df4ca6b166f7dd72f08606f306993c6b5f403523ca277947d24ef244f1b3905367f61c110cb888d1c6ff080cb4c05c5a6d7bc9ff0ad30194ed55bb5dfcb6be15c4365961ce7dc97435127be3513397b79bea02ecfca0fd68cff148b3d92dbffc0ef1ae1e6a4e3ce6ce0c4b33cecb96f6afde89aaae91a0feb92c0e463f32c3c1ef64c7b2f317cdad84a1fef1e6ac7b77140fb8f38881fc19e171170ce7789254d6def8ffb15bfe1dcd09237e285d597f34eedfbb9b0498e2523c07da2d4f274771ee984ba0a51787d3d194ff08da4e0f545ffeb78605d006a661aae1c34c3734911bb386e6fdfb8f3d06871918a9e085bf90595c28d794057097f04370cef67464a06e88e580d44d466734620f91d1ab9a7e9ad9660c3c04eff0d5319631e5f9425d9bb49215f5c4abe4ad4f897ba44ceab07fb006f3c6b20ca45511a4e242e8ad848f0a2a139f2849b4d18b4a2440c393ebc4eb6887eab5f53fd0627de8f0fd18ed6284bd91e405f96f8b1465df50437f576fce7560fc13b9c0d7ed593a0fc0869a46f997aaf9e681a5b20f64e8de94d005fb40952692886f96f49d21650a12374752ae69a41bd48154a88b251e79d8d2c1b7284b80d7e1f98f9beeb4d88ec7ab6a3daef9dd5a3998b7337f56ea78cb5c70f009c381d8f2b5b998eb11a801a58614084eded9d6091bcb0c7f78316ac7dea61bea642625966c60fb95ca57bbdf72a06c700652f657891aea1dc894454571ca023ea7fb51e76877e5a003a3a60ebf104ebd6c66d4d0bdb1f989c18a6df947d5e371c3d95dfba5586944eaf967ef51e610de85755d48dda5580f85fd2d15711a1ceabb9d7441e1af20b48afac1af92bdad2eae332cd7a32fd786541ef0bdf3ba3a69ad052f6862925f6b88bf93d3c1b9ae925e6d659c873b5acb243c8245ace1945595f37766d61e536c450d9eb5ee8dcc0a5e763ee171d128ae85c460c6074e28037640a2593c07ace1ece2d8afc82e47c8e748c58cb9aaf7fb26e5216b64c181a376bbfde08ee1c69d5f09771ec497a4d4f0f9ee957ecba7e08ba25c0c47f3a3bedb05593b1681bbf50810b5bd71d6e1e1a8523cc83b9eb92c9d1671b6aeaa6599a946d77d893d6780f41a7d6af2ed8e7105fb2333a8e4b07ed879e71aad3bcb968b8f225bea9427e724a52e6149500add02e406c82d429e549377bf9502e5e592e890341801387d9cf6360984e35e5f0f3a2503b85ec59c6bc6ce6e068e25efd0e8c6ccdb7648337102fd29156e6f6a2c53d96f2f5e2f0e17011eb6d476de5ebc55387eda831c04d169c705f722c763ec3808e900b9a9c4e928b4167d750236e2b729d3e76e71351ecf838fc828948217589d835c4c027a69b933316ff710687bef964051e0559c6699c398be1976db5be4d3375c82b182ae30de47c0389ffbb87c5f6f78884e0787d9ee0103da3ebea1a99c33cdf66b490fd7c1ce2618a24535b023b9958f2a76e12d4ca5d19ae3a4c31388230088a9232feb466ec653d9cf52ab8a9c1cc7d910e068286ca75eec106adb264c200e2cccd58c408a5d971ad5286e9dde4bcb82261092040e3aa38c983c37c53fbb86ed5334c45f37e95bcd0941b96023d48f67f8ce9a73a954f54f63d104019bd587f3746604e9d8f33a6c2f1aba6dbd5801a0ae3bfba871464df9d9e9862d81fe6b2b4dd2391454e4cc8044e9f8c72de122375c4ebcf87ec782000b618ca8e3486618c56ea88b46fb77c8d0eed3993aa4c88247abe0b5e714634f09d69e59ecafebd2e86efca3cda0fb338ac45783538d57aed449514dd27ac7086a6807dc84ce881902b8f5a8e2267cacff83e21f5f9f7e06913de6d2309bebb23bc7a5516ff65c957c1e99053d471f0853f5681a4758ad7689680f5c68421a3669679d77317b491254499192c4e61f125288898197701e355d30570231ef348af846868649c02df5101de6b1ff971e4adc0f1a6cd3faf5c07ee7839e355378194b3235391e2549766d962d633f2eca23f77959664c274efaa1bf03460d76bb6d938084971484139f64a5d565f3abad2ab98062f32f810741b6fc08847dac95b0559409f65e60479d0d2c1a1ea6c2944ce0aab6813e07d967720474be71404f3712db7e194512ff21358ea2103c55b2daa801b87f08ca46e22365f97ac51c2ccec69d3d50733997ce65c0d7a6fcb383b49ae166650dd101515c4d389f030e127215d49b465cd204eb0d40b76d24bfaac7c178db35cd24425b06823083ac98c28c91a6c24a8f49c680c0c86ea9b881e50ceb06e574152d19a0eefcfae880a3f097f1e3c8e86461281d7fb73ca87c6abc9e4b27e78fd50363aabc2e48d4b25a6e9cc811cbeb46bc0ba619a23c0dfc504ab964a7502ef4ab1cd0888edc06de9f0786a83ca265d0e33bc240904c8af69c30e77ff2769b40e294b0416dc2bd1ac47d6d3064cc826c486e7712ff0a09bb0898539d6e446e4babb38853eaddf8c09e075125e396af679a3a402d488e6b507556d15e58446ca5af4468e8037c3ddc58b87430f00d43ea6f5a0aa4df3454e70cff31e8b2ab2c669c23a6fcb5f8fb483ae83397503c1acc2a190f6ed26fef71486c5e3943a403c86b5b9a2de812109b5b175751f12690f8d5b5b5e422568dc75bfda6ddd30e303af2fd3ec3cd1bbed4e4734dca3262cf8e0eb26c5d57b59991f914deeedc02a8f7999c6046cd17b7dda0ba539d73fc202ca966ebc71187688c40b803fa882e49a4002f62519b31aba2c6b55dd35a535ff6564d865f97c74c55b23c97bb352c70303da376f65629d570769a391dda27918c0a32f05ce94b09e0cb5fa61f926b9a2861440f605041fd6136b29b0189a9fcf7d9dd8a1249eae9d85476f2026348e499856c2080b8098a16d5971dcb42667d9e23556bc63ccdf9a37ad5cfa282e468196e0667e83d3c0b5eecaddbd89aec9be8dbe097ab3d18f771e0048b8077b12f30bc651f4ed6f7ab307eb15604b392780d060b1186c9c79abd2fac62fcd5ac47024bed885d8b5b70fb6bcb6746f9468cba154850862319af33cb289b9e5659370ee87578f905e4178c321756d23f8324167e7b3851fe90e524c17642175a39aadc4eb9e6752c99ee6d4edc779e9bebe6b1b2a74fee2a33b73528e55853b9a09541fcbd45d05d03867df88714dfcc67e04af950e44010718f6d26b520edc820424462d7514e1792c77f327273a6bc3817f4d7243864c331e46672cc85570aa0722334e8c1e6039407cb44171d2fa886aaf9196d6e02f57b8da0ead5bdffff384883ae42fb3882b2a045e870d641be71e21c4e53f98dfd74c733c27c37798c82e416dd0d09f4d75c360a86ce9cc973eb1e054cb30509da5809e41051aa230f83650a89d96c08b98c3a1bda6d1edcad72251026ac0654d78f3b95ad624b007ba91e0dfdc525d4bae5d87543520a699634e982442b83ad32fa7d92f29e0c71edc6425d17138016ebb8d4f955e5ecd1342bb6266246ed8cadbd2833e68f1bd07cd505820894cb316f7bb9c4416746baf632681167f18b941d7d026e2f0f81e487e2258a5bf3d2901dc52d93faeafdbc610998ad3ed5598efc0515c9319d2bd1f03b3747f3dead2177c1c1e89f3b298de118221951a7e6fe8662accd43bbee1a883e6021939160a600c50b50985368187181b89614e295856dc9f84257e2712026ca8e7c8b31f7d53ffca5ac50ed4e2fb11ab4f62a190a4c2e2b921ed7d30131377e58bc8e2ac3c1ef9077a400bb9c6cec51f06da7f9026f625b6b9c455f50aff43def11909a5151083c5d8a00e336fe144f2762939adc8a400ccefe8394b6ce0f12316f5a61adb1ca9bfdd25e6f03e081d32789a1e8a5f9787e900339dbc3ce5ee1bdc89c832e30b9d2d86cc30fc78e6c0198e261cb3061ca921fc12b3934d94e75cc1004d27645fcec919fae95f1b1d530f5401451ec06b4f85c081e5fe92441632a4f536d86fbf0b9a944f0f552fa900228d614dd56d0cd569e82b251c9697aaa2e02c538e54d13a2519e8a8c102ca12a148427cb5f45355a61921830fec1fa448abe478c060052c7f59b73fad714f9a973e13a05f36d616f17bdaeca5f5ec6fd5522262f30847e1916448d4ba66c7118c19a0ebd7d2af6fb7e7aac5ddc1e8f3a06d96024b0bb14eeda2d3ec14b9df48abdaa4553ca708d6bd696180dd39444d0acdddae86775897b6bdde6a90844739445d0814f9e1ece6041a6c88e88ba0f6347786832f2965a0ade5aa23d763306d0d2052d0121c4072194d7dd5d1af1d2598a781f58ae78e3eb26d3369d52e7a8546bd3c62990f4de452c5f454ab5c01e3f516626f7d87ec7efffd3758b084c9015eda22fda51d8bf73a3ceaab230e657d35c4ce89e172a431e8f38682cc5fb38247a14d75d6e9ddba65c8bd3a63eefa7964d13ded193e06b3e77eeab119e3e2bc276ffa77895604a24f0eb1b1d7b3293936018aee4b37697190156444b5e56ff8d7355fee88c550ba3c57532682ccbba02479d98bc1de77b42b9829537d5cc784b91eb09da33d985c33c50f3968dc239aa722a2b247d3250d04cb33bc93e8f42f4174cc1535dd459815a4a389543480d0d71ce09c8be58056dede9abbc15383d666ccc3065bc6ffba462545800334ed65649090d1225e9f71b7094eb01deecdd0bccc98a901d5358a1f4623c4d654b210e9c2e799f1c5b584239d9711e1af21fbdeb0790afa3096f73c22fc293b0270262f574192fe451b44caab788225cb76d162e2ac176ac69a5781bce916dbcc8c355bccccc7c1a4f4ff75bac43126447c1c8ab50c98f0d475d47c147f1a63ae2cd659a674e4b4148b9dc4696b019528a1c67af59fd6025b5a67a8616ba3c6c3a77f45af4c74a92a3d804a15cd816726f971f1995d4f9bed9dfcf8d5c4ea13d4d1f7f302fc3f39661bf53509a0dd57c7ce5e7e8d2d630090478a2d064f7abb1200d0fd1d195689f18b198a096a2e83c18ab77ea755bb33feaf1741cebd8d4e995ad2db88131a0489c24ad23795a416ad1af4aae30bb8e76a6a103c966c674f47525b9810c853dd248f9d5a8096b1de0c38e4a58b4e101d6b36c6c9142db4d8a9e49f2929b8c1a46540b6d833262d6cfa02862d65d4a6a5eaea4ec51188ce3b5c99323777523e941245fc1ee49375bbf3496db825ddea1dd2d8f1d3ef0b84c77314828bcae2ea6117bb6c41b40725cc7d072f26d684a5aa1915333f127483f1f61d6804201fbc031b06d12cbe7d3b599c73b0e3f14229099248eefca8a13f3c13ec696a548936273ea63e6cf6103c1de35e22499ec0d9ac8fd3e0e7fab8c3065a04e982300e635ad5078bb400a2fa646a953dca9e3ae2c5c09935d2131cbd14ad6deec0c3c26356119b3e007b13a39b6da3a5aa5f8e5781fd57829d32f32735b383cbf74547c036972e9617729fd5866875ae6ee0d5d6881eb0da355b1967dfd44c8ca82dd9af5557046c1efb90af3358526e083969554c777cf119daa320cb4d06e4309084ddab2e272e20643723d7762e41e15119b49e31f1701c731ed2fa064c355af26b449fef50e76e843f6cb074dc601f0fcf41ea2c6e0489c2727ee61365d74fa31f5920d4f4e171db25475b9777433bff2bd94b303faa53b2574e0ea67f0bb0170f5f247e7d35516c9b0a3a5630bf5bf3d40ba213c0e659b1ca43eef75917876c070c6d4beda96b0c5eba8da2f05686e9c9bb345d2a1d6adaedaa670f2e10b0c5710b39427bb3392e295c5136f531807c968cfd71ad67f0e492ecc8ce1077df1bfd59e90d651e6638ffdcb7b3af5e9c8ba873404ec12b29fdf81b88e5c943d922d1f0005df92f1010753c2bf4edb332afb36c848888eec27adba64063f1217727fbe2c52e81ab6d39ecc2a4eef3b8bee0ed26daf233604e</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看文章</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>并发控制</title>
    <url>/2022/06/27/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="七、并发控制"><a href="#七、并发控制" class="headerlink" title="七、并发控制"></a>七、并发控制</h1><h1 id="UNIT-16-事务管理"><a href="#UNIT-16-事务管理" class="headerlink" title="UNIT 16  事务管理"></a>UNIT 16  事务管理</h1><h2 id="16-1-事务的定义与特性-、事务管理"><a href="#16-1-事务的定义与特性-、事务管理" class="headerlink" title="16.1  事务的定义与特性 、事务管理"></a>16.1  事务的定义与特性 、事务管理</h2><ul>
<li><p><strong>事务产生的原因：</strong>保证数据库状态的一致性</p>
</li>
<li><p><strong>事务（transaction）：</strong>用户定义的一个数据库操作序列，这些工作要么全做要么全不做，是一个不可分割的工作单位。</p>
<blockquote>
<p>事务是数据库系统工作的一个不可分割的基本单位，既是保持数据库完整性约束或逻辑一致性的单位，又是数据库恢复及并发控制的基本单位。</p>
</blockquote>
</li>
<li><p><strong>SQL定义事务的语句：</strong></p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION	#事务开始语句</span><br><span class="line"><span class="keyword">COMMIT</span>	  #事务提交语句，此时系统将事务所有对数据库的更新写入磁盘的物理数据库中，事务正常结束</span><br><span class="line"><span class="keyword">ROLLBACK</span>  #事务非正常结束，此时系统将数据库的所有已完成的更新操作全部撤销，将事务回滚至事务开始处并重新开始执行</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>事务的三个阶段</strong>：事务初态、事务执行、事务完成</p>
<p>  <img data-src="https://s2.loli.net/2022/05/03/JaiEyIGlmXsYBVF.png" alt="image-20220503192133312"></p>
</li>
<li><p><strong>事务的五个状态</strong>：活动状态、失败状态、中止状态、局部提交状态、提交状态</p>
<p>  <img data-src="https://s2.loli.net/2022/05/03/tp4Q7wbhBX3OHZe.png" alt="image-20220503192208460"></p>
</li>
<li><p>&#x3D;&#x3D;事务的四个特性：ACID&#x3D;&#x3D;  </p>
<ul>
<li><p><strong>原子性（Atomicity）：</strong>事务包含的一组更新操作是原子不可分的，即更新操作对于数据库而言，要么全做，要么全不做，不能部分地完成</p>
</li>
<li><p><strong>一致性（Consistency）：</strong>指事务对数据库的每一个插入、删除、修改等更新操作，都必须遵守一定的完整性约束，系统一旦查出数据库的完整性受到破坏，则撤销该事务并清除该事务对数据库的任何影响。一个成功的事务把数据库从一个一致的状态转换到另一个一致的状态。</p>
</li>
<li><p><strong>隔离性（Isolation）：</strong>指两个或多个事务可以同时运行而不互相影响，一个事务内部的操作及其使用的数据对并发的其他事务是隔离的、不可见的。</p>
</li>
<li><p><strong>持久性（Durability）：</strong>指一个事务成功完成之后，其工作的结果就会永远保存在数据库中，是永久有效的，即使随后系统发生故障也能保持或恢复。</p>
<blockquote>
<p>破坏事务ACID特性的因素有：①多个事务的并行运行（并发控制）；②事务的运行过程中被强行停止（故障恢复）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="16-2-事务并发导致的不一致性"><a href="#16-2-事务并发导致的不一致性" class="headerlink" title="16.2  事务并发导致的不一致性"></a>16.2  事务并发导致的不一致性</h2><ul>
<li><p><strong>并发控制：</strong>保证事务的隔离性，从而保证数据库中数据的一致性</p>
<p>  当事务操作相同的数据且这些操作是冲突的，则会破坏事务的隔离性</p>
</li>
<li><p><strong>事务并发导致的不一致性</strong></p>
<p>  包括丢失修改（lost update）、不可重复读（non-repeatable read）、读脏数据（dirty read）、幻像（phantom）</p>
</li>
</ul>
<img data-src="https://s2.loli.net/2022/05/02/NdQICqbpTUw6HBh.png" alt="image-20220502105703368" style="zoom:67%;" />

<img data-src="https://s2.loli.net/2022/05/02/fezlxuHdRMWCi6q.png" alt="image-20220502105416862" style="zoom:67%;" />

<img data-src="https://s2.loli.net/2022/05/02/VcifCBzhLoZUyKa.png" alt="image-20220502105434043" style="zoom:67%;" />

<img data-src="https://s2.loli.net/2022/05/02/tcUNXbLw6fxdQ8m.png" alt="image-20220502105958563" style="zoom:67%;" />

<blockquote>
<p><strong>不可重复读和幻象的区别：</strong>不可重复读的重点是修改；同样的条件，第1次和第2次读取的值不一样。幻读的重点在于新增或者删除；同样的条件， 第1次和第2次读出来的记录数不一样。从控制角度来看，不可重复读只需要锁住满足条件的记录，幻读要锁住满足条件及其相近的记录。</p>
</blockquote>
<ul>
<li><p><strong>出现不一致性的原因：</strong>不同事务间冲突操作的无序执行，违反了隔离性原则</p>
</li>
<li><p><strong>并发控制的方法</strong></p>
<ul>
<li><p><strong>时间戳：</strong>对事务规定一定的顺序</p>
</li>
<li><p><strong>加锁：（主要技术）</strong>对于共享的资源DB进行控制</p>
</li>
</ul>
</li>
</ul>
<h2 id="16-3-封锁及封锁协议"><a href="#16-3-封锁及封锁协议" class="headerlink" title="16.3  封锁及封锁协议"></a>16.3  封锁及封锁协议</h2><h3 id="1、封锁的定义"><a href="#1、封锁的定义" class="headerlink" title="1、封锁的定义"></a>1、封锁的定义</h3><ul>
<li><strong>概念：</strong>事务T在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其<strong>加锁</strong>。加锁后事务T就对该数据对象有了一定的<strong>控制</strong>，在事务T释放它的锁之前，其他事务对该数据的操作受到<strong>一定限制</strong>。</li>
</ul>
<h3 id="2、基本的封锁类型"><a href="#2、基本的封锁类型" class="headerlink" title="2、基本的封锁类型"></a>2、基本的封锁类型</h3><ul>
<li><strong>排它锁</strong>（Exclusive Locks，简称X锁，也称写锁）</li>
<li><strong>共享锁</strong>（Share Locks，简称S锁，也称读锁）</li>
</ul>
<img data-src="https://s2.loli.net/2022/05/10/VBJL7PADZoWzqOy.png" alt="image-20220510101032697" style="zoom:50%;" />

<p><img data-src="https://s2.loli.net/2022/05/03/Pc2ldCGzSiN7U5q.png" alt="image-20220503200409098"></p>
<h3 id="3、封锁协议包含的内容"><a href="#3、封锁协议包含的内容" class="headerlink" title="3、封锁协议包含的内容"></a>3、封锁协议包含的内容</h3><ul>
<li>什么操作需要申请何种锁？—-排它锁、共享锁</li>
<li>何时加锁？—-事务开始前、操作前</li>
<li>何时解锁？—-操作结束后、事务结束前</li>
</ul>
<h3 id="4、封锁协议的分类"><a href="#4、封锁协议的分类" class="headerlink" title="4、封锁协议的分类"></a>4、封锁协议的分类</h3><ul>
<li><p>&#x3D;&#x3D;一级封锁协议&#x3D;&#x3D;</p>
<p>  事务T在<strong>修改</strong>数据R之前，必须先对R加<strong>X锁</strong>，直到<strong>事务结束才释放</strong>。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）</p>
<p>  &#x3D;&#x3D;一级封锁协议不加S锁&#x3D;&#x3D;</p>
  <img data-src="https://s2.loli.net/2022/05/10/CvwZySBr9LxhmEX.png" alt="image-20220510103651090" style="zoom:67%;" />
</li>
<li><p>&#x3D;&#x3D;二级封锁协议&#x3D;&#x3D;</p>
<p>  <strong>在一级封锁协议的基础上</strong>，加上事务T在<strong>读取</strong>数据R之前必须先对其加<strong>S锁</strong>，<strong>读完后即可释放S锁</strong></p>
  <img data-src="https://s2.loli.net/2022/05/10/cPYrELMTeukGNoH.png" alt="image-20220510103811156" style="zoom:67%;" />      
</li>
<li><p>&#x3D;&#x3D;三级封锁协议&#x3D;&#x3D;</p>
<p>  <strong>在一级封锁协议的基础上</strong>，加上事务T在<strong>读取</strong>数据R之前必须先对其加<strong>S锁</strong>，<strong>直到事务结束才释放</strong></p>
  <img data-src="https://s2.loli.net/2022/05/10/7r8VxWoZYlmIzQc.png" alt="image-20220510103942568" style="zoom:67%;" />
</li>
<li><p>&#x3D;&#x3D;一二三级封锁协议的一致性保证&#x3D;&#x3D;</p>
  <img data-src="https://s2.loli.net/2022/05/02/N162xhCXYOvqiBE.png" alt="image-20220502113625070" style="zoom:80%;" /></li>
</ul>
<h3 id="5、并发调度的可串行性"><a href="#5、并发调度的可串行性" class="headerlink" title="5、并发调度的可串行性"></a>5、并发调度的可串行性</h3><ul>
<li><p><strong>调度的正确性</strong>：</p>
<ul>
<li><p>能将数据库置于一致状态的调度一定是正确的调度</p>
</li>
<li><p>将所有事务串行起来的调度策略一定是正确的调度（因为每个事务都会保证一致性状态，故事务串行一定会保证一致性）</p>
</li>
<li><p>与串行调度等价的调度是正确的调度</p>
</li>
</ul>
</li>
<li><p><strong>并发事务的正确性准则：</strong>多个事务的并发执行是正确的，当且仅当其结果与<strong>某一次序串行地执行</strong>它们时的结果相同，我们称这种调度策略为<strong>可串行化的调度</strong>。</p>
  <img data-src="https://s2.loli.net/2022/05/02/48u6gehbtD5PVnT.png" alt="image-20220502114421860" style="zoom:67%;" />

  <img data-src="https://s2.loli.net/2022/05/02/rGFxKEV5iQNSPs4.png" alt="image-20220502114251187" style="zoom:67%;" /></li>
</ul>
<h2 id="16-4-两段锁协议"><a href="#16-4-两段锁协议" class="headerlink" title="16.4 两段锁协议"></a>16.4 两段锁协议</h2><ul>
<li><p><strong>概念：</strong>所有事务必须分两个阶段（获得阶段和释放阶段，亦即扩展阶段和收缩阶段）对数据项加锁和解锁。</p>
<ul>
<li><p><strong>获得封锁：</strong>在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁； </p>
</li>
<li><p><strong>释放封锁：</strong>&#x3D;&#x3D;在释放一个封锁之后，事务不再申请和获得任何其他封锁。&#x3D;&#x3D;</p>
<p>  例子：</p>
  <img data-src="https://s2.loli.net/2022/05/10/ZMBYK4H9SIQCOit.png" alt="image-20220510105713156" style="zoom:67%;" /></li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li><p>&#x3D;&#x3D;两段锁协议是可串行化的充分条件，而不是必要条件&#x3D;&#x3D;</p>
</li>
<li><p>一次封锁法遵守两段锁协议，但两段锁协议不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生<code>死锁</code>。</p>
<p>  例子：</p>
<p>  <img data-src="https://s2.loli.net/2022/05/10/gYxvJR9oVeKG5US.png" alt="image-20220510105806932"></p>
</li>
<li><p>三级封锁是两段锁的一种，因为三级封锁都是事务结束再释放锁，事务结束后显然事务不会再申请和获得任何其他封锁。</p>
</li>
</ul>
</blockquote>
<ul>
<li><p><strong>活锁和死锁</strong></p>
<ul>
<li><p><strong>活锁（饥饿）</strong>：某一个事务无限等待。解决方法：先来先服务</p>
</li>
<li><p><strong>死锁：</strong>两个或多个事务都已封锁了一些数据对象，然后又都请求对已被其他事务封锁的数据对象加锁，从而出现死等待。</p>
</li>
<li><p><strong>解决死锁</strong>：</p>
<ul>
<li><p><strong>预防：</strong>破坏死锁产生的四个必要条件（互斥、请求和保持、不可剥夺、循环等待）。几个方法：静态申请法，一次性申请所有资源，资源的利用率不高；延迟进程的执行，能够获得所有资源时才允许执行，并发度不好；有序资源分配法，给资源编号</p>
</li>
<li><p><strong>避免</strong>：类似os中的银行家算法，在资源分配之前进行检查，防止死锁的发生</p>
</li>
<li><p><strong>诊断与解除</strong></p>
<ul>
<li><p><strong>死锁的诊断：</strong></p>
<ul>
<li><p><strong>超时法</strong>：超过规定的时间就认为发生死锁。</p>
<blockquote>
<p>不足：可能误判死锁，也可能不能及时发现死锁</p>
</blockquote>
</li>
<li><p><strong>等待图法：</strong>以<code>事务</code>为结点，边表示事务等待的情况，若T1等待T2，则 T1→T2。系统周期性地检测事务等待图，若图中存在回路，则出现死锁。</p>
</li>
</ul>
</li>
<li><p><strong>死锁的解除</strong>：选择一个处理死锁代价最小的事务，撤销。对撤销的事务所执行的数据修改操作必须加以恢复。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="16-5-封锁的粒度"><a href="#16-5-封锁的粒度" class="headerlink" title="16.5  封锁的粒度"></a>16.5  封锁的粒度</h2><ul>
<li><strong>封锁的粒度</strong>：指封锁对象的大小，封锁的粒度包括整个数据库、关系、元组、索引</li>
</ul>
<img data-src="https://s2.loli.net/2022/05/02/dKOgEQJji3fncZ1.png" alt="image-20220502143147735" style="zoom:67%;" />

<ul>
<li><p><strong>封锁粒度的选择</strong>：选择封锁粒度时应该同时考虑并发度和开销两个因素。&#x3D;&#x3D;封锁粒度越大，并发度越小，系统开销越小。&#x3D;&#x3D;</p>
</li>
<li><p><strong>多粒度封锁</strong></p>
<ul>
<li><p><strong>概念：</strong>在一个系统中同时支持多种封锁粒度供不同的事务选择。</p>
<blockquote>
<p><code>多粒度封锁协议</code>允许多粒度树中的每个结点被独立地加锁。对每个结点的加锁意味着这个结点的所有后裔结点也被加以同样类型的锁。</p>
</blockquote>
</li>
<li><p><strong>显式封锁：</strong>应事务的要求直接加到数据对象上的封锁</p>
</li>
<li><p><strong>隐式封锁：</strong>该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁</p>
</li>
<li><p><strong>判断能否对一个数据对象加锁：</strong></p>
<ul>
<li><p>检查<strong>该数据对象</strong>有无显式封锁与之冲突； </p>
</li>
<li><p>检查其<strong>所有上级结点</strong>，看本事务的显式封锁是否与该数据对象上的隐式封锁冲突； </p>
</li>
<li><p>检查其<strong>所有下级结点</strong>，看上面的显式封锁是否与本事务的隐式封锁冲突。</p>
<blockquote>
<p>不需要检查下级结点的隐式封锁，因为有隐式封锁肯定可以向上找到显式封锁</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;意向锁&#x3D;&#x3D;</p>
<ul>
<li><p><strong>概念：</strong>如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁；对任一结点加锁时，必须先对它的（所有）上层结点加意向锁。</p>
</li>
<li><p><strong>意向共享锁（简称IS锁）</strong>：如果对数据对象加IS锁，表示它的后裔结点拟加S锁 </p>
</li>
<li><p><strong>意向排它锁（简称IX锁）</strong>：如果对数据对象加IX锁，表示它的后裔结点拟加X锁 </p>
</li>
<li><p><strong>共享意向排它锁（简称SIX锁）</strong>：如果对数据对象加SIX锁，表示先加S锁，再加IX</p>
<p>  eg.  对某个表加SIX锁，表示该事务要读整个表（所以要对该表加S锁），同时会更新个别元组（所以要对该表加IX锁）</p>
  <img data-src="https://s2.loli.net/2022/05/10/iOJKRkQElyd7TzM.png" alt="image-20220510113003330" style="zoom:67%;" />

<blockquote>
<p>加锁是从上往下的</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><img data-src="https://s2.loli.net/2022/05/03/mzDWoftL9S6kxRs.png" alt="image-20220503201553550"></p>
<blockquote>
<p>IS锁和IX锁是相容的，因为最终会转化到下层结点，如果最终S锁和X锁加到了同一个对象上，那么在这个对象上的这两个锁是不相容的；如果没有加到同一个对象上，那么IS锁和IX锁就不会出现问题。</p>
</blockquote>
<h2 id="16-6-隔离级别（四种）"><a href="#16-6-隔离级别（四种）" class="headerlink" title="16.6  隔离级别（四种）"></a>16.6  隔离级别（四种）</h2><ul>
<li><p><strong>未提交读（读未提交， read uncommitted）</strong>：事务隔离的最低级别，一个事务可以读到另外一个事务未提交的数据，不允许丢失修改，接受读脏数据和不可重复读现象。</p>
</li>
<li><p><strong>提交读（读已提交， read committed）</strong>：SQL Server 默认级别。若事务还没提交，其它事务不能读取该事务正在修改的数据。不允许丢失修改和读脏数据，接受不可重复读现象。</p>
</li>
<li><p><strong>可重复读（repeatable read）</strong>：事务多次读取统一数据对象的结果一致。不允许丢失修改、读脏数据和读不一致，接受幻影读现象。</p>
</li>
<li><p><strong>可串行读（serializable）</strong>：事务隔离的最高级别，保证可串行化，不允许丢失修改、读脏数据、读不一致以及幻影读现象的发生。</p>
</li>
<li><p>隔离级别允许不同类型的行为：</p>
<table>
<thead>
<tr>
<th align="center"><strong>隔离级别</strong></th>
<th align="center">丢失修改</th>
<th align="center"><strong>脏读</strong></th>
<th align="center"><strong>不可重复读取</strong></th>
<th align="center"><strong>幻像</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>未提交读</strong></td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center"><strong>提交读</strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center"><strong>可重复读</strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center"><strong>可串行读</strong></td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
</tbody></table>
</li>
<li><p><strong>设置隔离级别的语法</strong></p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> transaction isolation level</span><br><span class="line">&#123;</span><br><span class="line">	read committed <span class="operator">|</span> </span><br><span class="line">	read uncommitted <span class="operator">|</span></span><br><span class="line">	repeatable read <span class="operator">|</span></span><br><span class="line">	serializable read</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="16-7-数据库恢复"><a href="#16-7-数据库恢复" class="headerlink" title="16.7 数据库恢复"></a>16.7 数据库恢复</h2><ul>
<li><p><strong>概念</strong>：把数据库从<strong>错误状态</strong>恢复到某一个已知的<strong>正确状态</strong>（亦称为一致状态或完整状态）的功能。</p>
</li>
<li><p><strong>目标：</strong>在故障发生时，确保事务的原子性和持久性</p>
</li>
<li><p><strong>特点：</strong>因为DB与内存用户工作区之间的数据交换是通过缓冲区进行的，而这个交换一般是以缓冲区是否满来触发的。因此，有可能提交事务的数据仍在缓冲区而没有写到DB中，而未提交事务的数据却写到了DB中。所以，故障恢复时，可能既要REDO已经提交了的事务，又要UNDO未提交的事务，以保证事务的原子性</p>
</li>
<li><p><strong>技术</strong></p>
<p>  DBMS提供备份机制、日志机制、检查点机制来协助数据库故障恢复;</p>
<p>  &#x3D;&#x3D;基本原理：数据冗余。&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;数据转储：&#x3D;&#x3D;DBA定期地将整个数据库复制到磁带或另一个磁盘上保存起来的过程。这些备用的数据文本称为后备副本或后援副本。</p>
<p>  <strong>数据转储的分类：</strong></p>
<ul>
<li>按照转储时的状态可以分为<strong>静态转储和动态转储</strong>。静态转储是指在系统中无运行事务时进行的转储操作。动态转储是指转储期间允许对数据库进行存取或者修改，但此时需要把转储期间各事务对数据库的修改记录在日志文件中，从而将来可以恢复</li>
<li>按方式不同可以分为<strong>海量转储和增量转储</strong>。海量转储是指每次转储全部数据库。增量转储是指每次只转储上一次转储后更新的数据库。</li>
</ul>
<p>  <img data-src="https://s2.loli.net/2022/05/03/oEV9AIyQY7LlmZD.png" alt="image-20220503193938217"></p>
</li>
<li><p>&#x3D;&#x3D;登记日志文件&#x3D;&#x3D;：记录事务对数据库的<code>更新</code>操作</p>
<p>  <strong>日志文件的格式：</strong>以记录为单位的日志文件和以数据块为单位的日志文件。</p>
<ul>
<li><p>以记录为单位的日志文件：一个日志记录包括每个事务的开始标志（BEGIN TRANSACTION）、结束标志（COMMIT 或 ROLLBACK）、每个更新操作</p>
</li>
<li><p>以数据块为单位的日志文件：包含事务标识和被更新的数据块</p>
</li>
</ul>
  <img data-src="https://s2.loli.net/2022/05/02/aeJHjWo2fNvlnSM.png" alt="image-20220502151104445" style="zoom:67%;" />

<p>  <strong>登记日志文件的原则：</strong></p>
<ul>
<li>登记的次序按并发事务执行的时间次序</li>
<li>必须先写日志文件，后写数据库&#x3D;&#x3D;（日志先写原则）&#x3D;&#x3D;</li>
</ul>
</li>
<li><p><strong>系统故障的恢复实现策略</strong></p>
<ul>
<li><p><strong>系统故障导致的数据库不一致</strong><br>  （1）未完成的事务对DB产生影响<br>  （2）已完成的事务在缓冲区的内容未写入DB</p>
</li>
<li><p><strong>恢复功能</strong><br>  （1）UNDO未完成的事务<br>  （2）REDO已完成的事务</p>
</li>
<li><p><strong>恢复步骤</strong><br>  （1）正向扫描日志文件，建立UNDO和REDO队列；（不需要redo日志中所有已完成的事务）<br>  （2）反向扫描日志文件，对每个UNDO事务的更新执行逆操作；<br>  （3）正向扫描日志文件，对每个REDO事务的更新重新执行。</p>
</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;检查点技术：&#x3D;&#x3D;</p>
<p>  当事务正常运行时，数据库系统按一定的时间间隔设检查点。一旦系统需要恢复数据库状态，就可以根据最新的检查点的信息，从检查点开始执行，而不必从头开始执行那些被中断的事务。</p>
<p>  系统在检查点做的动作主要如下：</p>
<ul>
<li>暂时中止现有事务的执行</li>
<li>在日志中写入检查点记录，并把日志强制写入磁盘</li>
<li>把主存中被修改的数据缓冲区强制写入磁盘</li>
<li>重新开始执行事务</li>
</ul>
<p>  例子：</p>
<p>  <img data-src="https://s2.loli.net/2022/05/03/hbQXdSE3r46sk52.png" alt="image-20220503195636843"></p>
<p>  <img data-src="https://s2.loli.net/2022/05/03/f4wAEDbW2xU6ZtX.png" alt="image-20220503195650256"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库设计</title>
    <url>/2022/06/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="五、数据库设计"><a href="#五、数据库设计" class="headerlink" title="五、数据库设计"></a>五、数据库设计</h1><h2 id="1、ER图中的基本概念"><a href="#1、ER图中的基本概念" class="headerlink" title="1、ER图中的基本概念"></a>1、ER图中的基本概念</h2><h3 id="现实世界、ER模型、关系模型中的概念对应"><a href="#现实世界、ER模型、关系模型中的概念对应" class="headerlink" title="现实世界、ER模型、关系模型中的概念对应"></a>现实世界、ER模型、关系模型中的概念对应</h3><img data-src="https://s2.loli.net/2022/04/13/f43azBqyCJXxniM.png" alt="image-20220413170050668" style="zoom:67%;" />

<h3 id="实体类型和实体实例"><a href="#实体类型和实体实例" class="headerlink" title="实体类型和实体实例"></a>实体类型和实体实例</h3><ul>
<li><p>实体类型：一个属性集</p>
<blockquote>
<p>实体类型可以是物理上的，如staff；也可以是概念上的，如work experience</p>
</blockquote>
</li>
<li><p>实体实例：对应于实体类型下的一个取值，实体实例是可区别的</p>
<blockquote>
<p>例子：</p>
<p>学生是一个实体类型，可以用（学号，姓名，性别，年龄，所属系）这个属性集来描述学生，每一个学生，如学生i，是学生实体的一个实体实例；</p>
</blockquote>
</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><p>属性（attribute）：实体类型&#x3D;&#x3D;或联系类型&#x3D;&#x3D;所具有的某一特性</p>
</li>
<li><p>属性域（attribute domain）：单个属性或多个属性所允许的值的集合</p>
</li>
<li><p>&#x3D;&#x3D;简单属性&#x3D;&#x3D;（simple attribute）：由单个部分组成的属性，可独立地存在</p>
</li>
<li><p>&#x3D;&#x3D;复合属性&#x3D;&#x3D;（composite&#x2F;component attribute）：共同描述一个性质的一组简单属性。  eg. 地址（可以分为省市县等等）、姓名（last name， first name）</p>
<blockquote>
<p>复合属性的处理：把复合属性拆分成多个属性，还是放在原来的表里</p>
</blockquote>
</li>
</ul>
<hr>
<ul>
<li><p>&#x3D;&#x3D;单值属性&#x3D;&#x3D;（single-valued attribute）：在一个实体实例中只有单独一个值</p>
</li>
<li><p>&#x3D;&#x3D;多值属性&#x3D;&#x3D;（multi-valued attribute）：在一个实体实例中可以取多个值的属性。eg.  电话、爱好等等</p>
<blockquote>
<p>多值属性的处理：用单独的表来处理</p>
</blockquote>
</li>
<li><p>导出属性（derived attribute）：由相关的一个属性或一组属性的值导出，在同一个实体类型中该属性并不是必要的。  eg.  年龄（可以根据生日来计算）</p>
<blockquote>
<p>导出属性的处理：大部分情况下不保存，用的时候直接计算</p>
</blockquote>
</li>
</ul>
<hr>
<ul>
<li>候选关键字（candidate key）：能唯一标识每个实体实例的最小属性组</li>
<li>主关键字（primary key）：实体类型中被选来唯一标识每个实体实例的候选关键字</li>
<li>复合关键字（composite key）：包括两个或更多属性的候选关键字。eg.  SC表，学号和课程号构成复合关键字</li>
</ul>
<h3 id="联系类型"><a href="#联系类型" class="headerlink" title="联系类型"></a>联系类型</h3><ul>
<li><p>联系类型（relationship type）：实体类型间的一组有意义的关联</p>
</li>
<li><p>联系实例（relationship occurrence）：一个可唯一标识的关联，涉及参与该联系的每个实体类型的一个实例</p>
<blockquote>
<p>联系类型和联系实例是型和值的关系</p>
</blockquote>
</li>
<li><p>联系类型的度（degree of a relationship type）：参与联系的实体类型的个数。度为2的联系称为二元联系；度为3的称为三元联系；度为3或更高的联系，称为多元联系</p>
<blockquote>
<p>例如：学生选课，学生和课程，二元联系</p>
</blockquote>
</li>
<li><p>递归联系（recursive relationship）：是这样一种联系类型，其同一个实体类型参与的次数大于1，并且每次参与具有不同角色.递归联系也称为一元联系。</p>
<blockquote>
<p>例如：学生选班干</p>
</blockquote>
</li>
</ul>
<h3 id="简单E-R图"><a href="#简单E-R图" class="headerlink" title="简单E-R图"></a>简单E-R图</h3><h4 id="（1）联系类型的图形化表示："><a href="#（1）联系类型的图形化表示：" class="headerlink" title="（1）联系类型的图形化表示："></a>（1）联系类型的图形化表示：</h4><ul>
<li><p>一元联系（递归联系）：</p>
  <img data-src="https://s2.loli.net/2022/04/13/KusxJgkM6jNB3vY.png" alt="image-20220413183610740" style="zoom:67%;" />
</li>
<li><p>二元联系：每个联系类型都表现为连接相关联实体类型的一条线，在线上标明该联系的名字,通常用一个动词或动词短语。箭头表示联系的方向。</p>
<p>  <img data-src="https://s2.loli.net/2022/04/13/lzYsi72DWPxHgoj.png" alt="image-20220413182921721"></p>
</li>
<li><p>三元联系：用菱形表示度大于2的联系，联系名放在菱形内部</p>
  <img data-src="https://s2.loli.net/2022/04/13/DcAMZWVklYqTdU1.png" alt="image-20220413183338386" style="zoom:67%;" />

<blockquote>
<p>四元联系与三元联系类似</p>
</blockquote>
</li>
<li><p>两个实体之间存在多于一种联系时课使用角色名</p>
  <img data-src="https://s2.loli.net/2022/04/13/AEn5ze4rsiGZUQ6.png" alt="image-20220413183823327" style="zoom:67%;" /></li>
</ul>
<h4 id="（2）属性的图形化表示"><a href="#（2）属性的图形化表示" class="headerlink" title="（2）属性的图形化表示"></a>（2）属性的图形化表示</h4><ul>
<li><p>&#x3D;&#x3D;实体的属性：&#x3D;&#x3D;在一个实体类型中显示其属性时，将实体类型的矩阵分为两个部分：上部分是实体的名字，下部分列出实体属性的名字。</p>
<ul>
<li>对于主关键字属性,第一个列出，并在其名字后面标记{PK}，</li>
<li>在部分主关键字属性的名字后标记{PPK}</li>
<li>对于候选关键字属性的名字后面标记{AK}</li>
<li>简单属性和单值属性没有必要标记</li>
<li>对于复合属性，在其名下以右缩进形式列出子属性名</li>
<li>对于多值属性，在属性名后面注明它的取值范围</li>
<li>对于导出属性，在属性名前加上前缀“&#x2F;</li>
</ul>
<p>  例子：</p>
  <img data-src="https://s2.loli.net/2022/04/13/OvTZMpQCNzlRu9t.png" alt="image-20220413184441872" style="zoom:67%;" />
</li>
<li><p>&#x3D;&#x3D;联系的属性&#x3D;&#x3D;：采用与实体类型相同的符号，但用&#x3D;&#x3D;虚线&#x3D;&#x3D;将表示联系属性的矩形与联系类型名连接起来</p>
  <img data-src="https://s2.loli.net/2022/04/13/8plaIBwcOfkeZ1T.png" alt="image-20220413184614803" style="zoom:67%;" /></li>
</ul>
<h3 id="弱实体类型和强实体类型"><a href="#弱实体类型和强实体类型" class="headerlink" title="弱实体类型和强实体类型"></a>弱实体类型和强实体类型</h3><ul>
<li><p>&#x3D;&#x3D;强实体类型&#x3D;&#x3D;(Strong entity type) （父实体，属主实体(owner entity)，支配实体）：该实体类型的存在不依赖于其他的实体类型</p>
</li>
<li><p>&#x3D;&#x3D;弱实体类型&#x3D;&#x3D;(Weak entity type) （子实体，依赖实体，从属实体）：该实体类型的存在依赖于其他实体类型的存在</p>
<blockquote>
<p>弱实体类型的一个特征是，仅使用该实体类型的属性无法唯一标识每个实体实例。 eg. 两个学生是同班同学，学习经历相同。</p>
</blockquote>
<blockquote>
<p>例子：<img data-src="https://s2.loli.net/2022/04/13/KwhYO63iC9AkLG4.png" alt="image-20220413185233053" style="zoom:67%;" /></p>
</blockquote>
</li>
</ul>
<h2 id="2、-结构化约束"><a href="#2、-结构化约束" class="headerlink" title="2、 结构化约束"></a>2、 结构化约束</h2><ul>
<li><p>概念：ER模型的结构化约束是指参与一个联系的实体类型上存在的约束</p>
</li>
<li><p>&#x3D;&#x3D;多样性&#x3D;&#x3D;：联系上的主要约束称为多样性，包括基数约束和参与约束。指的是在一个特定的联系中，一个参与实体类型的某个实例，可能与另一个参与实体类型发生关联的实例的数目（或范围）</p>
<blockquote>
<ul>
<li><p>基数约束(cardinality constraints)： 描述一个特定联系类型中的一个实体&#x3D;&#x3D;最多&#x3D;&#x3D;可参与联系的实例数目(&#x3D;&#x3D;最大基数&#x3D;&#x3D;) </p>
</li>
<li><p>参与约束（participation constraints）：说明是否所有的实体实例都参与了联系(&#x3D;&#x3D;最小基数&#x3D;&#x3D;) </p>
<ul>
<li>强制参与（mandatory participation）：一个实体类型的所有实例都参与联系。x为1</li>
<li>可选参与（optional participation ）：一个实体类型的部分实例参与约束。x为0</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;看约束：固定n - 1方，看另一方&#x3D;&#x3D;</p>
  <img data-src="https://s2.loli.net/2022/04/13/1wB9IzoaCvGTmSj.png" alt="image-20220413191540919" style="zoom:67%;" />

<p>  某个分支机构的某个职员可以拥有0个或者多个客户</p>
</li>
</ul>
</blockquote>
</li>
<li><p>范围的表示：范围表示为&#x3D;&#x3D;x..y&#x3D;&#x3D;,其中x为最小参与数目（参与约束）(用0表示0,用1表示大于0),y为最大参与数目（基数约束）(用1表示1,用*或N表示大于1)</p>
</li>
<li><p>例子：</p>
<ul>
<li><p>一对一联系的多样性</p>
  <img data-src="https://s2.loli.net/2022/04/13/Pi8boG26YmrvpZf.png" alt="image-20220413190419081" style="zoom:67%;" />
</li>
<li><p>一对多联系的多样性</p>
  <img data-src="https://s2.loli.net/2022/04/13/42ZoVecLI9K8TjC.png" alt="image-20220413190430930" style="zoom:67%;" />
</li>
<li><p>多对多联系的多样性</p>
  <img data-src="https://s2.loli.net/2022/04/13/X3becj8krD4TuYo.png" alt="image-20220413190445972" style="zoom:67%;" />

  <img data-src="https://s2.loli.net/2022/04/13/lBaznOJ2CUfdPcR.png" alt="image-20220413191346428" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
<h2 id="3、ER模型的问题"><a href="#3、ER模型的问题" class="headerlink" title="3、ER模型的问题"></a>3、ER模型的问题</h2><h3 id="连接陷阱"><a href="#连接陷阱" class="headerlink" title="连接陷阱"></a>连接陷阱</h3><p>由于对特定联系含义的错误理解而引起的问题。</p>
<h3 id="扇形陷阱-fan-trap-："><a href="#扇形陷阱-fan-trap-：" class="headerlink" title="扇形陷阱(fan trap)："></a>扇形陷阱(fan trap)：</h3><p>当用模型来表示实体间的联系时，某些特殊实体实例间的道路是不明确的</p>
<img data-src="https://s2.loli.net/2022/04/13/DPqiV6CSAW3krht.png" alt="image-20220413192231143" style="zoom:67%;" />

<img data-src="https://s2.loli.net/2022/04/13/zHBIxnosYPqXZt2.png" alt="image-20220413192245233" style="zoom:67%;" />

<h3 id="深坑陷阱-chasm-trap-："><a href="#深坑陷阱-chasm-trap-：" class="headerlink" title="深坑陷阱(chasm trap)："></a>深坑陷阱(chasm trap)：</h3><p>当一个模型暗示某些实体类型之间存在联系，而这些实体实例间却不存在相应的道路</p>
<img data-src="https://s2.loli.net/2022/04/13/DZjGTJOHfSF2VuY.png" alt="image-20220413192355668" style="zoom:67%;" />

<img data-src="https://s2.loli.net/2022/04/13/vkUdu8rwRaBSiYf.png" alt="image-20220413192412310" style="zoom:67%;" />

<h2 id="4、-增强的ER模型（EER）"><a href="#4、-增强的ER模型（EER）" class="headerlink" title="4、  增强的ER模型（EER）"></a>4、  增强的ER模型（EER）</h2><ul>
<li><p>ER模型的局限性：冗余</p>
</li>
<li><p>&#x3D;&#x3D;超类：&#x3D;&#x3D;其实例构成一个或多个独立子集且各独立子集在数据模型中要显示的实体类型。含有独立子类的实体类型称为超类。例如staff</p>
</li>
<li><p>&#x3D;&#x3D;子类：&#x3D;&#x3D;某实体类型的一个独立实例集合，并需要在数据模型中单独表示。</p>
<blockquote>
<p>eg.  Staff实体类型的实体成员可分为Manager, SalesPersonnel和Secretary,</p>
<p>Staff可以看成超类，Manager, SalesPersonnel和Secretary应看作子类</p>
</blockquote>
</li>
<li><p>超类和子类的联系：</p>
<ul>
<li>子类中的一个实体也是超类的一个实体</li>
<li>超类&#x2F;子类联系是一对一的</li>
<li>有些超类的子类可能重叠（<strong>不相交约束</strong>：相交的、不相交的）。例如，一名职员可以既是经理，又是销售人员</li>
<li>并不是超类中的每个实体都必须是子类中的实体（<strong>参与约束</strong>：强制的、可选的）。例如，有些职员没有明显的一类工作角色，比如说既不是经理，也不是销售人员</li>
</ul>
</li>
<li><p>将超类和子类的概念引入ER模型的主要原因：避免对相似的概念进行重复的描述</p>
</li>
<li><p>属性继承：子类除了拥有其所在子类特有的属性外，同时还具有（继承）超类的所有属性</p>
</li>
<li><p>共享子类：一个子类有不止一个超类时，称这个子类为共享子类</p>
<p>  &#x3D;&#x3D;在UML图中，三角形的尖指向超类&#x3D;&#x3D;</p>
  <img data-src="https://s2.loli.net/2022/04/13/JjODx9q1p4Ngo2s.png" alt="image-20220413195615579" style="zoom:67%;" />
</li>
<li><p>多重继承：超类的属性都被共享子类继承，同时共享子类还可以有自己的附加属性，这种继承称为多重继承</p>
</li>
<li><p><strong>类型层次（自上而下）</strong>：子类也可以有自己的子类。这样构成的子类层次称为类型层次</p>
</li>
<li><p><strong>概化层次（自下而上）</strong>：多个有公共属性的实体可以概化为一个更高层次的超类实体（supertype entity）,或者相反，一个一般化实体可以分解成低层次的子类实体（subtype entity）</p>
</li>
</ul>
<h2 id="5、-特殊化、概化"><a href="#5、-特殊化、概化" class="headerlink" title="5、  特殊化、概化"></a>5、  特殊化、概化</h2><ul>
<li><p>特殊化过程(specialization process)：&#x3D;&#x3D;自上而下&#x3D;&#x3D; 。通过标识实体成员间的差异特征将这些成员间的差异最大化的过程</p>
</li>
<li><p>概化过程(generalization process)：&#x3D;&#x3D;自下而上&#x3D;&#x3D;。通过标识实体成员间的共同特征将这些成员间的差异最小化的过程</p>
  <img data-src="https://s2.loli.net/2022/04/19/YXJewcjOgv5nBGT.png" alt="image-20220419102322804" style="zoom:67%;" />
</li>
<li><p>特殊化&#x2F;概化约束：</p>
<ul>
<li><p>&#x3D;&#x3D;参与约束&#x3D;&#x3D;：确定超类中的每个成员是否都必须是子类中的成员。</p>
<ul>
<li>强制的参与约束（Mandatory）：超类中的每个成员都必须是子类中的成员</li>
<li>可选的参与约束（Optional）：超类中的成员并不一定也是子类中的成员</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;不相交约束&#x3D;&#x3D;：描述子类成员间的联系。子类成员之间是相交（AND）的或者不相交（OR）的</p>
<blockquote>
<p>&#x3D;&#x3D;参与约束和不相交约束是独立的，因此可以组合成4种约束&#x3D;&#x3D;</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<img data-src="https://s2.loli.net/2022/04/19/zRnwamC5L82ekQI.png" alt="image-20220419102930019" style="zoom:67%;" />

<h2 id="6、-聚合与组合"><a href="#6、-聚合与组合" class="headerlink" title="6、  聚合与组合"></a>6、  聚合与组合</h2><ul>
<li><p>&#x3D;&#x3D;聚合(aggregation）&#x3D;&#x3D;：表示实体类型之间的“具有”(has-a)和“属于”**(is-part-of)**联系，这些实体中有一个表示整体，其他的表示部分。如汽车和轮子</p>
<blockquote>
 <img data-src="https://s2.loli.net/2022/04/19/ljstSaZ9Vmc1u3B.png" alt="image-20220419103229323" style="zoom: 67%;" />
</blockquote>
</li>
<li><p>&#x3D;&#x3D;组合（composition）：&#x3D;&#x3D;一种特殊形式的聚合，即整体对部分存在强拥有权，且&#x3D;&#x3D;两者具有一致的生存期&#x3D;&#x3D;</p>
<blockquote>
<p>例如：汽车和轮子，轮子是可以单独存在的；而房子和房间，如果房子没了。那房间也不存在了</p>
</blockquote>
  <img data-src="https://s2.loli.net/2022/04/13/o2piID5CdsX84M9.png" alt="image-20220413202610135" style="zoom:67%;" />
</li>
<li><p>&#x3D;&#x3D;概括&#x3D;&#x3D;：定义了类型之间的一种子集联系，它抽象了类型之间的<strong>is subset of</strong>的语义。如学生和本科生</p>
<p>  例子：</p>
  <img data-src="https://s2.loli.net/2022/04/14/K2ZBMf5Ln4SePD3.png" alt="image-20220414123506992" style="zoom:67%;" /></li>
</ul>
<h2 id="7、-局部视图设计及合并ER图"><a href="#7、-局部视图设计及合并ER图" class="headerlink" title="7、  局部视图设计及合并ER图"></a>7、  局部视图设计及合并ER图</h2><ul>
<li><p>根据局部结构设计分ER图，即局部ER图</p>
</li>
<li><p>合并ER图</p>
<ul>
<li><p>方法：二元合并法或者多元合并法</p>
</li>
<li><p>冲突处理：</p>
<ul>
<li><p>属性冲突：包括属性域冲突和属性取值单位冲突</p>
<p>  解决方法：取尽可能多的包含较多局部ER图要求的数据类型、值域或取值单位，并可考虑今后系统维护的工作量作为取舍</p>
</li>
<li><p>命名冲突：包括同名异义和异名同义。解决方法：重新命名</p>
</li>
<li><p>结构冲突：</p>
<ul>
<li>同一对象在不同应用中具有不同的抽象（解决方法：统一为实体或属性）</li>
<li>同一对象在不同局部ER图中所包含的属性不完全相同，或属性的排列次序不完全相同（解决方法：使该实体的属性取各局部ER图中属性的并集，再适当调整属性的次序）</li>
<li>实体之间的联系在不同局部ER图中呈现不同的类型（解决方法：根据应用的语义对实体联系的类型进行综合或调整）</li>
</ul>
</li>
</ul>
</li>
<li><p>消除数据冗余</p>
<ul>
<li><p>用分析法消除冗余数据（😢其实就是观察法），例如实发工资可以由其他列推算得到，则可以删去实发工资</p>
</li>
<li><p>用规范化消除冗余联系，可以通过求最小依赖集来实现</p>
<p>  <img data-src="https://s2.loli.net/2022/04/14/wFm5a2JVHkYrSqd.png" alt="image-20220414142449087"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>例子:</p>
<p><img data-src="https://s2.loli.net/2022/04/14/WxGbp3khOcZijf7.png" alt="image-20220414124835366"></p>
<p><img data-src="https://s2.loli.net/2022/04/14/CndNF5YtxWcRaJO.png" alt="image-20220414124850694"></p>
<h2 id="x3D-x3D-8、-将ER模型转换为关系模型-x3D-x3D"><a href="#x3D-x3D-8、-将ER模型转换为关系模型-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;8、  将ER模型转换为关系模型&#x3D;&#x3D;"></a>&#x3D;&#x3D;8、  将ER模型转换为关系模型&#x3D;&#x3D;</h2><ul>
<li><p>ER结构与关系结构的对应关系</p>
  <img data-src="https://s2.loli.net/2022/04/13/XP6twnef4rG2bgH.png" alt="image-20220413203447160" style="zoom:67%;" />
</li>
<li><p>&#x3D;&#x3D;将ER模型转换为关系模型的9步算法&#x3D;&#x3D;</p>
  <img data-src="https://s2.loli.net/2022/04/13/zPa9jNSdThUeH1B.png" alt="image-20220413203911206" style="zoom:67%;" /></li>
</ul>
<h4 id="（1）强实体的转换：直接转换成一张表"><a href="#（1）强实体的转换：直接转换成一张表" class="headerlink" title="（1）强实体的转换：直接转换成一张表"></a>（1）强实体的转换：直接转换成一张表</h4><img data-src="https://s2.loli.net/2022/04/13/Zps7gCADun8rBGI.png" alt="image-20220413204026593"  />

<h4 id="（2）仅参与一个1-1联系的弱实体的转换"><a href="#（2）仅参与一个1-1联系的弱实体的转换" class="headerlink" title="（2）仅参与一个1:1联系的弱实体的转换"></a>（2）仅参与一个1:1联系的弱实体的转换</h4><p><img data-src="https://s2.loli.net/2022/04/13/o4OXdy1nNVpeR9b.png" alt="image-20220413204240217"></p>
<h4 id="（3）参与1-N或M-N联系的弱实体的转换"><a href="#（3）参与1-N或M-N联系的弱实体的转换" class="headerlink" title="（3）参与1:N或M:N联系的弱实体的转换**"></a>（3）参与1:N或M:N联系的弱实体的转换**</h4><p>将参与一个1:N或M:N或多个联系的弱实体W，转换为一张表T，表中包括弱实体的所有的单值属性或复合属性的组成属性。</p>
<ul>
<li><p>若强实体S与弱实体W之间是&#x3D;&#x3D;1:N联系，则T的主键 &#x3D; W的主关键字+S的主关键字&#x3D;&#x3D;</p>
<p>  <img data-src="https://s2.loli.net/2022/04/13/xJ3vpA51YfnkU9P.png" alt="image-20220413205556256"></p>
</li>
<li><p>若强实体S与弱实体W之间是&#x3D;&#x3D;M:N联系，则T的主键&#x3D;一个新创建的具有唯一值的属性X&#x3D;&#x3D;，而实体间的联系在step six处理</p>
<blockquote>
<p>如果采用T的主键 &#x3D; W的主关键字+S的主关键字，会造成冗余</p>
</blockquote>
  <img data-src="https://s2.loli.net/2022/04/13/sBSwXZjvz4D6YlP.png" alt="image-20220413231701028" style="zoom:67%;" />

<blockquote>
<p>父子关系等等可以作为联系的属性</p>
<img data-src="https://s2.loli.net/2022/04/19/2SrvHy1h3oebWnA.png" alt="image-20220419103909683" style="zoom: 33%;" /></blockquote>
</li>
</ul>
<h4 id="（4）-1-1-的联系的转换"><a href="#（4）-1-1-的联系的转换" class="headerlink" title="（4） 1:1 的联系的转换"></a>（4） 1:1 的联系的转换</h4><ul>
<li><p>两方都强制参与：将两个实体组合为一个关系T，然后将联系属性加入到关系T中</p>
  <img data-src="https://s2.loli.net/2022/04/13/nWRxKhXNc5mlqdi.png" alt="image-20220413231857172" style="zoom:67%;" />
</li>
<li><p>一方强制参与：将可选方实体的主关键字作为强制方实体的关系的外部关键字，然后将联系属性加入到强制实体的关系中</p>
<blockquote>
<p>如果放到可选参与方，会造成空间浪费，因为会有空的；强制参与方就不会有空的</p>
</blockquote>
  <img data-src="https://s2.loli.net/2022/04/13/lgyLBaHn9iD2RYU.png" alt="image-20220413232130399" style="zoom:67%;" />
</li>
<li><p>两方都可选参与：若没有进一步的信息，可选任一可选实体当作强制实体，使用方法（2）转换</p>
  <img data-src="https://s2.loli.net/2022/04/13/ThBVvoKfijR7cy9.png" alt="image-20220413232412596" style="zoom:67%;" /></li>
</ul>
<h4 id="（5）1-N-的联系的转换"><a href="#（5）1-N-的联系的转换" class="headerlink" title="（5）1:N 的联系的转换"></a>（5）1:N 的联系的转换</h4><p>对于任意一个1:N联系，一方实体的主关键字作为多方实体关系的外部关键字，该联系的任何属性也安排在多方</p>
<blockquote>
<p>如果放到一方实体的话，则会造成多值</p>
</blockquote>
<img data-src="https://s2.loli.net/2022/04/13/k8dJuPe6AByfCE2.png" alt="image-20220413232534635" style="zoom:67%;" />

<h4 id="（6）-N元联系（涉及N个实体）（包括N-M-的联系）的转换"><a href="#（6）-N元联系（涉及N个实体）（包括N-M-的联系）的转换" class="headerlink" title="（6） N元联系（涉及N个实体）（包括N:M 的联系）的转换"></a>（6） N元联系（涉及N个实体）（包括N:M 的联系）的转换</h4><p>对于任意一个M:N联系或N元联系，&#x3D;&#x3D;生成一个表示该联系的关系R（注意外键），&#x3D;&#x3D;关系R包含该联系的所有属性以及作为R的外部关键字出现的所有属主实体的主关键字</p>
<img data-src="https://s2.loli.net/2022/04/13/PgsECqprb1HOG3Q.png" alt="image-20220413232804774" style="zoom:67%;" />

<img data-src="https://s2.loli.net/2022/04/13/dxnKtID86QFU7T5.png" alt="image-20220413232956311" style="zoom:67%;" />

<blockquote>
<p>同一实体集的实体间的联系，即自联系，也可按上述1:1， 1：n， m：n的3种情况分别处理</p>
</blockquote>
<h4 id="（7）-复合属性、多值属性和派生属性的处理"><a href="#（7）-复合属性、多值属性和派生属性的处理" class="headerlink" title="（7） 复合属性、多值属性和派生属性的处理"></a>（7） 复合属性、多值属性和派生属性的处理</h4><ul>
<li>&#x3D;&#x3D;复合属性&#x3D;&#x3D;：为每个子属性创建一个单独的属性而将复合属性去掉</li>
<li>&#x3D;&#x3D;多值属性&#x3D;&#x3D;：将多值属性生成为一个表示该属性的关系，<strong>并把该属性的属主实体的主关键字作为该关系的外部关键字</strong></li>
<li>&#x3D;&#x3D;派生属性&#x3D;&#x3D;：从关系模式中去掉</li>
</ul>
<img data-src="https://s2.loli.net/2022/04/13/j9uenoirmIlq4Mc.png" alt="image-20220413233231580" style="zoom:67%;" />

<h4 id="（8）-子类不相交的超类-x2F-子类联系的转换"><a href="#（8）-子类不相交的超类-x2F-子类联系的转换" class="headerlink" title="（8） 子类不相交的超类&#x2F;子类联系的转换"></a>（8） 子类不相交的超类&#x2F;子类联系的转换</h4><p>对于每个具有强制参与且不相交子类的超类&#x2F;子类联系– {Mandatory, Or}</p>
<ul>
<li><p>对于每个子类Si，创建一个新表Ti; </p>
</li>
<li><p>将超类的简单属性和复合属性的简单组合属性放入Ti的属性集中；</p>
</li>
<li><p>将Si的简单属性和复合属性的简单组合属性放入Ti的属性集中；</p>
</li>
<li><p>标识主键和候选键。</p>
<p>  &#x3D;&#x3D;超类不创建表（因为是强制参与且不相交，超类中的某个成员一定属于且仅属于某一个子类），各组合的超类&#x2F;子类一个表&#x3D;&#x3D;</p>
  <img data-src="https://s2.loli.net/2022/04/13/1DFPGLpnarTCXv9.png" alt="image-20220413233638204" style="zoom:67%;" /></li>
</ul>
<h4 id="（9）-子类相交的超类-x2F-子类联系的转换"><a href="#（9）-子类相交的超类-x2F-子类联系的转换" class="headerlink" title="（9） 子类相交的超类&#x2F;子类联系的转换"></a>（9） 子类相交的超类&#x2F;子类联系的转换</h4><p>对于每个具有相交子类 或 可选参与且不相交子类的超类&#x2F;子类联系（即除了{Mandatory, Or}之外的三种组合约束）</p>
<ul>
<li><p>对于超类，创建一个新表O; </p>
</li>
<li><p>将超类的简单属性和复合属性的简单组合属性放入O的属性集中；</p>
</li>
<li><p>标识O的主键和候选键；</p>
</li>
<li><p>对于每个子类Si，创建一个新表Ti; </p>
</li>
<li><p>将Si的简单属性和复合属性的简单组合属性放入Ti的属性集中；</p>
</li>
<li><p><strong>将O的主键放入Ti的属性集中，作为Ti的外键</strong></p>
<p>  &#x3D;&#x3D;超类创建一个表，各子类一个表&#x3D;&#x3D;</p>
</li>
</ul>
<img data-src="https://s2.loli.net/2022/04/13/vscW9OjZQRDkaIP.png" alt="image-20220413234448229" style="zoom:67%;" />
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>一、操作系统绪论</title>
    <url>/2022/06/27/%E4%B8%80%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="一、操作系统绪论"><a href="#一、操作系统绪论" class="headerlink" title="一、操作系统绪论"></a>一、操作系统绪论</h1><h2 id="x3D-x3D-重点考察概念-x3D-x3D"><a href="#x3D-x3D-重点考察概念-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;重点考察概念&#x3D;&#x3D;"></a>&#x3D;&#x3D;重点考察概念&#x3D;&#x3D;</h2><p>操作系统的定义，操作系统在计算机系统中的地位，操作系统的主要功能，资源复用、虚化、抽象，操作系统的特征，多道程序设计，并发，中断，系统调用，CPU 的两种工作模式（用户态、内核态），特权指令和非特权指令 </p>
<h2 id="1、操作系统概念、功能及提供的接口"><a href="#1、操作系统概念、功能及提供的接口" class="headerlink" title="1、操作系统概念、功能及提供的接口"></a>1、操作系统概念、功能及提供的接口</h2><p><strong>操作系统的概念</strong>：管理计算机硬件并提供应用程序运行环境的软件。操作系统是配置在计算机硬件上的第一层软件，是对硬件的首次扩充，形成了虚拟计算机&#x2F;扩展机。它位于硬件与其它软件之间，是所有其他软件运行的基础。</p>
<p><strong>操作系统的作用：</strong></p>
<p><strong>用户视角：</strong> 操作系统是用户与计算机硬件之间的接口。为用户使用计算机提供服务。</p>
<p><strong>系统视角：</strong> </p>
<ul>
<li>&#x3D;&#x3D;资源管理器&#x3D;&#x3D; ：管理计算机系统的软硬件资源。<strong>资源复用、资源虚化以及资源抽象</strong> 。<ul>
<li>资源复用：分为时间复用和空间复用。时间复用指的是多个用户或程序轮流使用某个资源，如CPU使用；空间复用指的是多个用户或程序同时使用资源的一部分，如内存使用。</li>
<li>资源虚化：让一个物理设备变成多个相对独立的对应物</li>
<li>资源抽象：对内封装细节，对外通过管理对象与访问接口，如：面向进程而不是CPU，面向文件而不是物理存储介质，面向窗口而不是屏幕</li>
<li>&#x3D;&#x3D;复用与虚拟化解决的是资源不足的问题。资源抽象解决的是资源复杂的问题。&#x3D;&#x3D;</li>
</ul>
</li>
<li>&#x3D;&#x3D;控制程序&#x3D;&#x3D; ：控制程序执行过程，防止错误和计算机的不当使用</li>
</ul>
<p><img data-src="https://s2.loli.net/2022/05/13/msaGykqzLiVtrDT.png" alt="image-20220513191418134"></p>
<p><img data-src="https://s2.loli.net/2022/05/13/HKJvnRhTVw89bdC.png" alt="image-20220513193433159"></p>
<p><img data-src="https://s2.loli.net/2022/05/13/AQW3CRkS6fHpBNw.png" alt="image-20220513192502110"></p>
<p><img data-src="https://s2.loli.net/2022/05/13/LiEpfK6Awz8WFvs.png" alt="image-20220513193123123"></p>
<p>联机命令接口 &#x3D; 交互命令接口，如命令行</p>
<p>脱机命令接口 &#x3D; 批处理命令接口，如*.bat文件</p>
<p>程序接口：如dll文件，调用dll文件即可进行系统调用，只能通过应用程序间接使用</p>
<h2 id="2、操作系统的特征"><a href="#2、操作系统的特征" class="headerlink" title="2、操作系统的特征"></a>2、操作系统的特征</h2><ul>
<li><p><strong>并发性：</strong> 多个事件在同一事件间隔内发生（并行：同一时刻）。并发的实质是一个物理CPU(也可以多个物理CPU) 在若干道程序之间多路复用，并发性是对有限物理资源强制行使多用户共享以提高效率。</p>
</li>
<li><p><strong>共享性：</strong> 系统中的资源可供多个并发执行的进程共同使用。有两种资源共享方式：</p>
<ul>
<li>互斥共享：一段时间只允许一个进程访问。如对摄像头设备的共享使用</li>
<li>同时访问：一段时间允许多个进程访问。如对硬盘资源的共享使用</li>
</ul>
<p>  &#x3D;&#x3D;并发和共享是操作系统的两个最基本特征，二者之间互为存在条件。&#x3D;&#x3D; </p>
</li>
<li><p><strong>虚拟性：</strong> 把一个物理上的实体变为若干个逻辑上的对应物；或把物理上的多个实体变成逻辑上的一个对应物的技术。eg.虚拟存储器</p>
<ul>
<li><p>空分复用技术：如虚拟存储技术</p>
</li>
<li><p>时分复用技术：如虚拟处理器技术</p>
<p>  并发性是虚拟性存在的基础</p>
</li>
</ul>
</li>
<li><p><strong>异步性（或不确定性）：</strong> 多个作业的执行过程是走走停停的，其执行顺序和每个作业的执行时间是不确定的。</p>
</li>
</ul>
<h2 id="3、操作系统的发展与分类"><a href="#3、操作系统的发展与分类" class="headerlink" title="3、操作系统的发展与分类"></a>3、操作系统的发展与分类</h2><p><img data-src="https://s2.loli.net/2022/05/13/3AWQXpLSTGkobFC.png" alt="image-20220513201053867"></p>
<p>批处理技术是指计算机系统对一批作业自动进行处理的一种技术。</p>
<p>分类：</p>
<ul>
<li>联机批处理：采用联机输入&#x2F;输出，即输入&#x2F;输出操作在监督程序控制下，同步进行。 缺点：速度慢 </li>
<li>脱机批处理：外围机：独立于主机，负责把作业任务写入磁带，以及从磁带输出到打印机。主机：负责从磁带上把作业调入内存，或者把结果写回磁带。实现了部分异步能力、减少了CPU的空闲时间、提高了I&#x2F;O速度</li>
</ul>
<hr>
<p>多道程序设计：</p>
<ul>
<li><strong>核心思想：</strong> 将多个作业存放在主存中，这些程序在管理程序的控制下交替运行，共享处理机和系统中的其他资源。即通过安排作业（编码与数据）&#x3D;&#x3D;使得CPU无论何时都有进程执行，从而最大化CPU利用率&#x3D;&#x3D; </li>
<li>没有提供用户与计算机系统的交互</li>
<li>多道程序宏观上并行，微观上串行</li>
<li>多道程序设计的道数不是任意的</li>
<li><strong>优缺点：</strong> <ul>
<li>提高了CPU的利用率</li>
<li>提高了内存和I&#x2F;O设备的利用率</li>
<li>改进了系统的吞吐率</li>
<li>充分发挥了系统的并行性</li>
<li>其主要缺点是: 作业周转时间延长</li>
</ul>
</li>
<li>**多重处理系统:   ** 指配置了多个物理CPU，能真正同时执行多道程序的系统。</li>
</ul>
<hr>
<p>&#x3D;&#x3D;操作系统的三种基本类型：批处理操作系统、分时操作系统、实时操作系统&#x3D;&#x3D; </p>
<p>分时系统：允许多个联机用户同时使用一台计算机系统进行计算的操作系统称分时操作系统</p>
<p><strong>分时技术：</strong> 把处理机的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。</p>
<p>是多道程序设计的自然延伸</p>
<p>采用调度算法，以快速切换作业，好像每个作业同时执行</p>
<p><strong>特征：</strong> </p>
<ul>
<li>多路性：也称同时性，一台计算机与若干台终端相连接，终端上的这些用户可以同时使用计算机。</li>
<li>交互性：用户通过终端采用人机会话的方式直接控制程序运行，同程序进行交互。</li>
<li>独立性：用户彼此之间都感觉不到别人也在使用这台计算机，好像只有自己独占计算机一样。</li>
<li>及时性：用户请求能在很短时间内获得响应。</li>
</ul>
<h2 id="4、操作系统的运行机制与体系结构"><a href="#4、操作系统的运行机制与体系结构" class="headerlink" title="4、操作系统的运行机制与体系结构"></a>4、操作系统的运行机制与体系结构</h2><p><img data-src="https://s2.loli.net/2022/05/13/uCvXRb5ixgc4ep9.png" alt="image-20220513203343485"></p>
<blockquote>
<p>用程序状态字寄存器（PSW， program status word）中的某标志位来标识当前处理器处于什么状态。如0为用户态，1为核心态</p>
</blockquote>
<hr>
<p>内核是操作系统的构件，或称基本单位。 </p>
<p>内核作用：  为进程提供管理 、为进程执行提供良好的运行环境</p>
<p>&#x3D;&#x3D;基本功能:&#x3D;&#x3D;  </p>
<ul>
<li>中断处理：截获中断，转向中断处理例程</li>
<li>短程调度：CPU调度，保存与恢复现场</li>
<li>原语管理：原语是不可中断过程</li>
</ul>
<p>&#x3D;&#x3D;基本属性:&#x3D;&#x3D; </p>
<ul>
<li>内核是由中断驱动的</li>
<li>内核的执行是连续的</li>
<li>内核在屏蔽中断状态下执行</li>
<li>内核可以使用特权指令</li>
</ul>
<p>&#x3D;&#x3D;分类：&#x3D;&#x3D;</p>
<ul>
<li><p><strong>模块结构（整体式结构）</strong>：将内核划分为一个个独立的模块，模块之间相互调用。效率高但是结构不清晰，访问控制困难</p>
</li>
<li><p><strong>层次结构</strong>：一种特殊的模块结构。将内核划分为一系列相互依赖的层次，每个层次也可以分解为一系列更小的模块。</p>
<p>  <img data-src="https://s2.loli.net/2022/03/04/2PkGeSmIBXyOTai.png"></p>
</li>
<li><p><strong>微内核结构</strong></p>
</li>
</ul>
<p><img data-src="https://s2.loli.net/2022/05/13/OzmplexJuwFcj24.png" alt="image-20220513202231353"></p>
<p><img data-src="https://s2.loli.net/2022/05/13/7S4E6d3gHUeNlpI.png" alt="image-20220513202617422"></p>
<h2 id="5、中断和异常"><a href="#5、中断和异常" class="headerlink" title="5、中断和异常"></a>5、中断和异常</h2><p><img data-src="https://s2.loli.net/2022/05/13/ojrdODLXqEezi3G.png" alt="image-20220513205554625"></p>
<p>&#x3D;&#x3D;用户态 → 核心态是通过中断实现的，并且中断是唯一途径&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;核心态 → 用户态的切换是通过执行一个特权指令，将程序状态字（PSW）的标志位设置为“用户态”&#x3D;&#x3D;</p>
<p><img data-src="https://s2.loli.net/2022/05/13/twndlTegkLJ6x9X.png" alt="image-20220513205029547"></p>
<p><img data-src="https://s2.loli.net/2022/05/13/EYTzjIOvW7drqfx.png" alt="image-20220513205136837"></p>
<p><strong>外中断的处理过程：</strong></p>
<p><img data-src="https://s2.loli.net/2022/05/13/oRmXYrNvBUkTgfI.png" alt="image-20220513205420243"></p>
<h2 id="6、系统调用"><a href="#6、系统调用" class="headerlink" title="6、系统调用"></a>6、系统调用</h2><p><img data-src="https://s2.loli.net/2022/05/13/xzmwb1KdrT5MIsp.png" alt="image-20220513213014300"></p>
<p>系统调用是操作系统提供给应用程序（程序员&#x2F;编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。</p>
<p>系统调用与库函数的区别：</p>
<p><img data-src="https://s2.loli.net/2022/05/13/tK9mNhM6OdzepCP.png" alt="image-20220513211951839"></p>
<p>系统调用背后的过程：</p>
<p><img data-src="https://s2.loli.net/2022/05/13/obNKP1RrQt9sBuV.png" alt="image-20220513212751507"></p>
<p>中断、异常和系统调用：</p>
<table>
<thead>
<tr>
<th></th>
<th>产生原因</th>
<th>实现机制</th>
<th>区别</th>
<th>保存地址</th>
<th>处理</th>
</tr>
</thead>
<tbody><tr>
<td><strong>中断</strong></td>
<td>由定时器和I&#x2F;O设备产生（来自硬件设备的处理请求）</td>
<td>中断机制</td>
<td>①由与现行指令无关的中断信号触发的(异步的)；②中断的发生与CPU处在用户模式或内核模式无关，系统不能确定中断发生的时间 ；③一般来说，中断处理程序提供的服务不是为当前进程所需的</td>
<td>保存的是下一条指令的地址，以便在指令结束后检测有没有中断</td>
<td><strong>硬件和软件结合</strong> 。①定时器：定时器是OS回收控制的重要方式，可设置为在指定周期（固定或可变）后中断计算机。防止用户程序陷入死循环，或不调用系统服务并且不将控制返回给操作系统。在将控制交到用户之前，操作系统确保定时器已设置好以便产生中断；②中断装置（发生中断源并产生中断的<strong>硬件</strong> ）：发现中断源、保护现场、启动中断处理程序（IDTR寄存器中存放了中断描述符表在内存的起始地址）；③中断处理程序： 保护未被硬件保护的一些必需的处理状态 （CPU自动保存的只有EIP&#x2F;EFLAGS&#x2F;ESP&#x2F;SS&#x2F;CS） ；识别各个中断源，分析产生中断的原因；处理中断事件；恢复正常操作；④OS必须保证中断前后的同步性，必须保证现场保护的原子性（保护现场的过程不能被中断）</td>
</tr>
<tr>
<td><strong>异常</strong></td>
<td>由程序错误产生，或者由内核必须处理的异常条件产生</td>
<td>中断机制</td>
<td>① 由处理器正在执行现行指令而引起的； ②异常处理程序提供的服务是为当前进程所用的；③异常包括出错、陷入、终止和编程异常等等；④异常通常由意想不到的行为触发</td>
<td>出错保存的是当前指令的地址，陷入保存的是下一条指令的地址</td>
<td>①由硬件检测并处理（如除0）；②硬件自身出错产生的异常：通常会在检测错误之后重新执行该指令，CPU保存运行状态；③有些异常是修复后返回并重新执行出错的指令（如页错误）；有些异常是OS通知相应进程；④异常发生在内核会导致OS崩溃</td>
</tr>
<tr>
<td><strong>系统调用</strong></td>
<td>程序主动请求操作系统服务</td>
<td>通常通过一种特殊的异常来实现</td>
<td>程序主动请求系统服务</td>
<td>保存的是下一条指令的地址</td>
<td>提供给用户态程序执行特权操作的接口；触发事件，切换至内核态；传递系统调用的参数； 保存状态以便完成系统调用后恢复执行</td>
</tr>
</tbody></table>
<h2 id="7、-x3D-x3D-可能的大题：多道程序运行、简答题-x3D-x3D"><a href="#7、-x3D-x3D-可能的大题：多道程序运行、简答题-x3D-x3D" class="headerlink" title="7、&#x3D;&#x3D;可能的大题：多道程序运行、简答题&#x3D;&#x3D;"></a>7、&#x3D;&#x3D;可能的大题：多道程序运行、简答题&#x3D;&#x3D;</h2><h3 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h3><p>计算作业完成时间，CPU或者I&#x2F;O设备的利用率等等</p>
<p>资源利用率：CPU利用率 &#x3D; CPU有效工作时间&#x2F;CPU总的运行时间， CPU总的运行时间 &#x3D; CPU有效工作时间+CPU空闲等待时间。</p>
<p>I&#x2F;O设备的利用率同理。</p>
<p>&#x3D;&#x3D;注意考虑优先级以及是否能够抢占&#x3D;&#x3D;</p>
<p><strong>（1）</strong>在单CPU和两台I&#x2F;O(I1,I2)设备的多道程序设计环境下，同时投入三个作业运行。它们的执行轨迹如下：</p>
<p>Job1：I2(30ms)、CPU(10ms)、I1(30ms)、CPU(10ms)</p>
<p>Job2：I1(20ms)、CPU(20ms)、I2(40ms)</p>
<p>Job3：CPU(30ms)、I1(20ms)</p>
<p>如果CPU、I1和I2都能并行工作，优先级从高到低为Job1、Job2和Job3，优先级高的作业可以抢占优先级低的作业的CPU。试求：(1)每个作业从投入到完成分别所需的时间。(2) 每个作业投入到完成CPU的利用率。(3)I&#x2F;O设备利用率。</p>
<p><strong>答：</strong>画出三个作业并行工作图如下(图中着色部分为作业等待时间)：</p>
<p><img data-src="https://s2.loli.net/2022/05/14/FxBnaZuVIQ8Nhe7.png" alt="img"></p>
<p>(1) Job1从投入到运行完成需80ms，Job2从投入到运行完成需90ms，Job3从投入到运行完成需90ms。</p>
<p>(2) CPU空闲时间段为：60ms至70ms，80ms至90ms。所以CPU利用率为(90-20)&#x2F;90&#x3D;77.78%。</p>
<p>(3) 设备I1空闲时间段为：20ms至40ms，故I1的利用率为(90-20)&#x2F;90&#x3D;77.78%。设备I2空闲时间段为：30ms至50ms，故I2的利用率为(90-20)&#x2F;90&#x3D;77.78%。</p>
<p>2、 若内存中有3道程序A、B、C，它们按A、B、C优先次序运行（不考虑强占）。各程序的计算轨迹为：</p>
<p>A：计算(20)、I&#x2F;O(30)、计算(10) </p>
<p>B：计算(40)、I&#x2F;O(20)、计算(10)</p>
<p>C：计算(10)、I&#x2F;O(30)、计算(20)</p>
<p>如果三道程序都使用相同设备进行I&#x2F;O(即程序用串行方式使用设备，调度开销忽略不计)。试分别画出单道和多道运行的时间关系图。两种情况下，CPU的平均利用率各为多少?</p>
<p><strong>答</strong>：分别画出单道和多道运行的时间图</p>
<p>(1) 单道运行时间关系图</p>
<p>  <img data-src="https://s2.loli.net/2022/05/14/FhG1CTOSvzJu8EM.png" alt="img"></p>
<p>单道总运行时间为190ms。CPU利用率为(190-80)&#x2F;190&#x3D;57.9%</p>
<p>(2) 多道运行时间关系图</p>
<p>  <img data-src="https://s2.loli.net/2022/05/14/vworFI23sGiWeKp.png" alt="img"></p>
<p>多道总运行时间为140ms。CPU利用率为(140-30)&#x2F;140&#x3D;78.6%</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>三、进程调度</title>
    <url>/2022/06/27/%E4%B8%89%E3%80%81%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="三、进程调度"><a href="#三、进程调度" class="headerlink" title="三、进程调度"></a>三、进程调度</h1><h2 id="x3D-x3D-重点：-x3D-x3D"><a href="#x3D-x3D-重点：-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;重点：&#x3D;&#x3D;"></a>&#x3D;&#x3D;重点：&#x3D;&#x3D;</h2><p>调度的层次：低级调度、中级调度、高级调度</p>
<p>引起进程调度的原因</p>
<p>抢占式和非抢占式调度，周转时间，等待时间</p>
<p>&#x3D;&#x3D;调度算法&#x3D;&#x3D;  时间片，进程优先级，高响应比可以不管， 重视多级队列，不超过作业题难度</p>
<p>实时调度概念</p>
<h2 id="1、处理机调度的基本概念"><a href="#1、处理机调度的基本概念" class="headerlink" title="1、处理机调度的基本概念"></a>1、处理机调度的基本概念</h2><p><img data-src="https://s2.loli.net/2022/05/20/PqpV7zcuSgAUL5v.png" alt="image-20220520083413143"></p>
<p><img data-src="https://s2.loli.net/2022/03/14/2GmBQDkHjsiAPy6.png" alt="image-20220314093421092"></p>
<h2 id="2、进程调度的时机、过程和方式"><a href="#2、进程调度的时机、过程和方式" class="headerlink" title="2、进程调度的时机、过程和方式"></a>2、进程调度的时机、过程和方式</h2><p><img data-src="https://s2.loli.net/2022/05/20/Fmr7aO5N9dtszGb.png" alt="image-20220520085145159"></p>
<p><img data-src="https://s2.loli.net/2022/05/20/pcZnNOMo5ugamv8.png" alt="image-20220520085014437"></p>
<h2 id="3、调度算法的评价指标"><a href="#3、调度算法的评价指标" class="headerlink" title="3、调度算法的评价指标"></a>3、调度算法的评价指标</h2><p><img data-src="https://s2.loli.net/2022/05/20/ecKivlW2Lb1jnNF.png" alt="image-20220520090857781"></p>
<ul>
<li><p>CPU利用率指CPU忙碌的时间占总时间的比例。CPU利用率 &#x3D; 忙碌的时间&#x2F;总时间</p>
</li>
<li><p>系统吞吐量指单位时间内完成作业的数量。系统吞吐量 &#x3D; 总共完成了多少道作业 &#x2F; 总共花了多少时间</p>
</li>
<li><p>周转时间：从作业提交给系统开始，到作业完成为止的这段时间间隔。周转时间 &#x3D; 作业完成时间 - 作业提交时间。</p>
</li>
<li><p>平均周转时间 &#x3D; 各作业周转时间之和 &#x2F; 作业数</p>
</li>
<li><p>带权周转时间 &#x3D; 作业周转时间 &#x2F; 作业实际运行的时间 &#x3D; (作业完成时间 - 作业提交时间) &#x2F; 作业实际运行的时间</p>
</li>
<li><p>平均带权周转时间 &#x3D; 各作业带权周转时间之和 &#x2F; 作业数</p>
</li>
<li><p>等待时间：指进程&#x2F;作业处于等待处理机状态时间之和</p>
<p>  <img data-src="https://s2.loli.net/2022/05/20/AlPaLcNSMfE8YC7.png" alt="image-20220520090716035"></p>
</li>
<li><p>响应时间：从用户提交请求到首次产生响应所用的时间</p>
</li>
</ul>
<h2 id="x3D-x3D-4、调度算法-x3D-x3D"><a href="#x3D-x3D-4、调度算法-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;4、调度算法&#x3D;&#x3D;"></a>&#x3D;&#x3D;4、调度算法&#x3D;&#x3D;</h2><p><img data-src="https://s2.loli.net/2022/05/20/JoeG3fn18mzbvIp.png" alt="image-20220520095505721"></p>
<p><img data-src="https://s2.loli.net/2022/05/20/MKsupUYmCxJE7WG.png" alt="image-20220520104630768"></p>
<h3 id="（1）先来先服务（FCFS）"><a href="#（1）先来先服务（FCFS）" class="headerlink" title="（1）先来先服务（FCFS）"></a>（1）先来先服务（FCFS）</h3><p>考虑作业的等待时间</p>
<p><img data-src="https://s2.loli.net/2022/05/20/v8k5tBYWVThbQ4g.png" alt="image-20220520092445844"></p>
<p><img data-src="https://s2.loli.net/2022/05/20/SHnKZd7Wa3vcPmr.png" alt="image-20220520092236752"></p>
<h3 id="（2）短作业优先"><a href="#（2）短作业优先" class="headerlink" title="（2）短作业优先"></a>（2）短作业优先</h3><p>考虑作业的运行时间</p>
<p><img data-src="https://s2.loli.net/2022/05/20/94JzSmAiaP5jBRb.png" alt="image-20220520094247319"></p>
<p><img data-src="https://s2.loli.net/2022/05/20/Bk3YS9dGruoTWOl.png" alt="image-20220520094114612"></p>
<p><img data-src="https://s2.loli.net/2022/05/20/cn1wtYv6B78lpTe.png" alt="image-20220520092954098"></p>
<p><img data-src="https://s2.loli.net/2022/05/20/osPMXSpyvK3NTCZ.png" alt="image-20220520093622737"></p>
<p><img data-src="https://s2.loli.net/2022/05/20/sG3ZJP9DRdKlH2e.png" alt="image-20220520093730231"></p>
<h3 id="（3）高响应比优先"><a href="#（3）高响应比优先" class="headerlink" title="（3）高响应比优先"></a>（3）高响应比优先</h3><p><img data-src="https://s2.loli.net/2022/05/20/my9UwruzFTjLt5N.png" alt="image-20220520095245768"></p>
<p><img data-src="https://s2.loli.net/2022/05/20/zgEpmj17vwMSbo5.png" alt="image-20220520095132854"></p>
<hr>
<h3 id="（4）时间片轮转调度算法（RR）"><a href="#（4）时间片轮转调度算法（RR）" class="headerlink" title="（4）时间片轮转调度算法（RR）"></a>（4）时间片轮转调度算法（RR）</h3><p><img data-src="https://s2.loli.net/2022/05/20/mcwBOxYhr8otI7z.png" alt="image-20220520101410525"></p>
<p><img data-src="https://s2.loli.net/2022/05/20/BeYU9XjykCD24sR.png" alt="image-20220520100727740"></p>
<p><img data-src="https://s2.loli.net/2022/05/20/l8L1IdpDo2h9HfS.png" alt="image-20220520101604794"></p>
<blockquote>
<p>如果RR和优先级结合考虑的话，那么FCFS队列变为优先级队列，同优先级则FCFS。当一个进程正在运行时，如果有更高优先级的进程到来，处理机立即被抢占；如果有同等优先级的进程在等待，执行完当前时间片后让出处理机；如果有低优先级的进程到来或者在等待，则不会被抢占。</p>
</blockquote>
<h3 id="（5）优先级调度算法"><a href="#（5）优先级调度算法" class="headerlink" title="（5）优先级调度算法"></a>（5）优先级调度算法</h3><p><img data-src="https://s2.loli.net/2022/05/20/G5VbhWiEMqUoNQg.png" alt="image-20220520102840867"></p>
<p><img data-src="https://s2.loli.net/2022/05/20/5Jr2HGj3YQd4sFC.png" alt="image-20220520101957020"></p>
<p><img data-src="https://s2.loli.net/2022/05/20/8ZshCGOIJfSFBo1.png" alt="image-20220520102237628"></p>
<p><img data-src="https://s2.loli.net/2022/05/20/if6V8BLPaINGKhn.png" alt="image-20220520102742626"></p>
<h3 id="（6）多级反馈队列调度算法"><a href="#（6）多级反馈队列调度算法" class="headerlink" title="（6）多级反馈队列调度算法"></a>（6）多级反馈队列调度算法</h3><p><img data-src="https://s2.loli.net/2022/05/20/g8Kju6BQw52FMPd.png" alt="image-20220520104355407"></p>
<p><img data-src="https://s2.loli.net/2022/05/20/7T4HiSVvycBFeAL.png" alt="image-20220520103557785"></p>
<hr>
<p>对于实时调度，调度器必须支持<strong>抢占的基于优先权的调度</strong>。可以根据进程的截止期限、任务速率来进行分配优先级</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>二、进程与线程</title>
    <url>/2022/06/27/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="二、进程与线程"><a href="#二、进程与线程" class="headerlink" title="二、进程与线程"></a>二、进程与线程</h1><h2 id="x3D-x3D-重点：-x3D-x3D"><a href="#x3D-x3D-重点：-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;重点：&#x3D;&#x3D;"></a>&#x3D;&#x3D;重点：&#x3D;&#x3D;</h2><p>进程定义，进程控制块（PCB），进程的状态及其变化，进程切换与CPU模式切换，进程调度，上下文切换，</p>
<p>进程队列，进程家族树和进程创建</p>
<p>进程通信机制（共享内存，消息传递） ， 信号与中断的区别。  通信中的同步问题：阻塞&#x2F;非阻塞</p>
<p>线程，线程和进程的区别，引入线程的好处，多线程模型</p>
<h2 id="1、进程的定义、特征、描述和组织"><a href="#1、进程的定义、特征、描述和组织" class="headerlink" title="1、进程的定义、特征、描述和组织"></a>1、进程的定义、特征、描述和组织</h2><p><img data-src="https://s2.loli.net/2022/05/16/OXPfK5pxMcrZldW.png" alt="image-20220516084814747"></p>
<p><strong>概念：</strong> 进程是一个可并发执行的具有独立功能的，是程序关于某个数据集合的一次执行过程，也是操作系统进行资源分配和保护的基本单位 。</p>
<p>从理论角度看，进程是对正在运行的程序过程的抽象；从实现角度看，进程是一种数据结构。</p>
<p>进程与程序的关系：m对n</p>
<table>
<thead>
<tr>
<th></th>
<th>进程</th>
<th>程序（本质就是文本段、代码段）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>状态</strong></td>
<td>动态</td>
<td>静态</td>
</tr>
<tr>
<td><strong>能否长久保存</strong></td>
<td>暂时</td>
<td>永久</td>
</tr>
<tr>
<td><strong>组成</strong></td>
<td>代码段、数据段、PCB</td>
<td>代码段</td>
</tr>
<tr>
<td><strong>能否“再生”</strong></td>
<td>进程可以创建新进程</td>
<td>程序不能形成新程序</td>
</tr>
</tbody></table>
<p><strong>特征：</strong> </p>
<ul>
<li><p><strong>动态性</strong>：进程是程序的一次执行过程，是动态地产生、变化和消亡的</p>
</li>
<li><p>并发性：内存中有多个进程实体，各进程可并发执行</p>
</li>
<li><p>独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位</p>
</li>
<li><p>异步性：进程以各自独立的不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题</p>
</li>
<li><p>结构性：<strong>进程实体由程序段、数据段及进程控制块（PCB）组成</strong>，又称为进程映像</p>
</li>
<li><p>共享性</p>
</li>
</ul>
<p><strong>进程的描述</strong> </p>
<ul>
<li><p>&#x3D;&#x3D;进程实体（进程映像）&#x3D;&#x3D; ：某时刻进程的内容及其状态的集合</p>
<p>  组成：</p>
<ul>
<li>控制块（PCB）：每个进程捆绑一个控制块，用于存储进程的标识信息、现场信息、控制信息</li>
<li>程序块</li>
<li>数据块</li>
<li>核心栈：每个进程捆绑一个核心栈，用于保存进程在核心态工作时的现场保护</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;进程的上下文&#x3D;&#x3D; ：操作系统把进程物理实体和支持进程运行的环境合称为进程上下文</p>
<p>  <img data-src="https://s2.loli.net/2022/03/08/Bm2kuy8A1qFrclS.png" alt="image-20220308204451231"></p>
<blockquote>
<p>所谓的“进程上下文”，就是一个进程在执行的时候，CPU的所有寄存器中的值、进程的状态以及堆栈上的内容，当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。</p>
</blockquote>
</li>
</ul>
<p>&#x3D;&#x3D;进程控制块（PCB）：&#x3D;&#x3D; 是描述和管理进程的数据结构。它是进程实体的一部分。PCB是进程存在的唯一标志。由OS创建和管理。</p>
<p>组成：</p>
<ul>
<li>进程标识信息：包括进程标识符、家族关系、用户标识符（进程的拥有者）</li>
<li>进程现场信息：进程在运行时存放在处理器中的各种信息</li>
<li>进程控制信息：包括进程当前状态、进程队列指针、进程优先级、通信信息、程序和数据地址、资源清单</li>
</ul>
<p>常用组织方式：</p>
<ul>
<li><p>线性方式：PCB顺序存放在一片连续内存中</p>
</li>
<li><p>链表方式：将同一状态的PCB组成一个链表，如就绪队列</p>
<p>  <img data-src="https://s2.loli.net/2022/03/08/E5d48CvRicSFhu7.png" alt="image-20220308151522468"></p>
</li>
<li><p>索引方式：将同一状态的PCB归入一个索引表，再由索引指向相应的PCB</p>
<p>  <img data-src="https://s2.loli.net/2022/03/04/rBc4xuVa5UCjWfO.png"></p>
</li>
</ul>
<h2 id="2、进程的状态与转换"><a href="#2、进程的状态与转换" class="headerlink" title="2、进程的状态与转换"></a>2、进程的状态与转换</h2><p><img data-src="https://s2.loli.net/2022/05/16/o52c8EevKiyhGVw.png" alt="image-20220516090546798"></p>
<ul>
<li><p><strong>三种基本状态</strong></p>
<p>  <img data-src="https://s2.loli.net/2022/05/16/gj96ZM8BfuHdAEG.png" alt="image-20220516085509970"></p>
<p>  M个处理器，N个进程：</p>
<p>  ①M&gt;&#x3D;N：运行态：0 ~ N，<strong>就绪态：0</strong>（有空闲处理器，无就绪进程），阻塞态：0~N</p>
<p>  ②M&lt;N：运行态：0 ~ M，就绪态：0 ~ N-M，阻塞态：0~N</p>
</li>
<li><p><strong>另外两种状态：</strong></p>
<p>  <img data-src="https://s2.loli.net/2022/05/16/FNZCy2cio3bSHsK.png" alt="image-20220516090014634"></p>
</li>
<li><p><strong>状态之间的转换</strong></p>
<p>  <img data-src="https://s2.loli.net/2022/05/16/fqFW2jUAmJcL6Dl.png" alt="image-20220516090418952"></p>
</li>
</ul>
<blockquote>
<p><strong>挂起状态：</strong>把某些进程挂起（suspend），&#x3D;&#x3D;对换到磁盘镜像区中&#x3D;&#x3D; ，暂时不参与进程调度， 起到减轻系统负荷或者进行检查和改正的目的。</p>
<p>原因：</p>
<ul>
<li><p>系统中的进程均处于等待状态，需要把一些阻塞进程对换出去，腾出内存给就绪进程运行</p>
</li>
<li><p>进程竞争资源，系统负荷过重，需挂起部分进程以调整系统负荷</p>
</li>
<li><p>将定期执行的进程对换出去以减轻系统负荷</p>
</li>
<li><p>用户要求挂起自己的进程，以进行检查和改正</p>
</li>
<li><p>父进程要求挂起后代进程，以进行检查和改正</p>
</li>
<li><p>操作系统需要挂起某些进程，以进行检查和改正</p>
</li>
</ul>
<p><strong>七态模型：</strong></p>
<p><img data-src="https://s2.loli.net/2022/03/04/986gRwPzeKnG3Yo.png"></p>
<p><img data-src="https://s2.loli.net/2022/05/20/k36EOZQYuFsGBNq.png" alt="image-20220520082727937"></p>
</blockquote>
<h2 id="3、进程控制"><a href="#3、进程控制" class="headerlink" title="3、进程控制"></a>3、进程控制</h2><p><img data-src="https://s2.loli.net/2022/05/16/2VmzyaKN8WbXTkn.png" alt="image-20220516092854030"></p>
<p><strong>进程控制：</strong>对系统中的所有进程实施有效的管理，即实现进程状态转换</p>
<p><img data-src="https://s2.loli.net/2022/05/16/C2KUzIQlknVs89f.png" alt="image-20220516091105817"></p>
<p><strong>原语的概念：</strong>由若干机器指令构成的，用以完成特定功能的一段程序，这段程序在执行期间不允许中断，只能一气呵成。</p>
<p><img data-src="https://s2.loli.net/2022/05/16/w867Je3mhGfvLct.png" alt="image-20220516091342486"></p>
<p>进程控制相关的原语要做的事情：</p>
<ul>
<li><p>更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境）</p>
</li>
<li><p>将PCB插入合适的队列</p>
</li>
<li><p>分配&#x2F;回收资源</p>
</li>
</ul>
<p><strong>进程的创建和终止：</strong></p>
<p><img data-src="https://s2.loli.net/2022/05/16/DdXkcIGeZi6hUWj.png" alt="image-20220516092101256"></p>
<p><img data-src="https://s2.loli.net/2022/05/16/l6x3gat7U5KHW2u.png" alt="image-20220516092402405"></p>
<blockquote>
<p><strong>僵尸进程：</strong> 子进程已终止，但父进程尚未调用wait()</p>
<p><strong>孤儿进程 ：</strong>子进程还在执行的时候父进程已终止。Linux和UNIX会将init进程作为孤儿进程的父进程。</p>
</blockquote>
<p><strong>进程的阻塞和唤醒</strong></p>
<p><img data-src="https://s2.loli.net/2022/05/16/kLQ4ewEbNZBj7xa.png" alt="image-20220516092526462"></p>
<blockquote>
<p>阻塞是主动过程（进程自己调用阻塞原语），唤醒是被动过程（另一个发现者进程（合作的并发进程）调用唤醒原语）</p>
</blockquote>
<p><strong>进程的挂起与激活：</strong></p>
<p>挂起原语的功能 ：将指定进程挂起😶</p>
<p>过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line"> a[在PCB表中查找PCB]--&gt;b[检查进程状态]</span><br><span class="line"> b[检查进程状态]--&gt;|活动阻塞|c[挂起阻塞]</span><br><span class="line"> b[检查进程状态]--&gt;|活动就绪|d[挂起就绪]</span><br><span class="line"> b[检查进程状态]--&gt;|执行|e[停止执行并保护现场信息]</span><br><span class="line"> e[停止执行并保护现场信息]--&gt;f[挂起就绪]</span><br><span class="line"> f[挂起就绪]--&gt;g[转进程调度]</span><br></pre></td></tr></table></figure>



<p>激活原语的功能：将指定进程激活😶</p>
<p>过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line"> a[在PCB表中查找PCB]--&gt;b[检查进程状态]</span><br><span class="line"> b[检查进程状态]--&gt;|挂起阻塞|c[活动阻塞]</span><br><span class="line"> b[检查进程状态]--&gt;|挂起就绪|d[活动就绪]</span><br><span class="line"> d[活动就绪]--&gt;|可能需要|e[转进程调度]</span><br></pre></td></tr></table></figure>

<p><strong>进程的调度和切换</strong></p>
<p><img data-src="https://s2.loli.net/2022/05/16/Rqatu1ylzhiZfpF.png" alt="image-20220516092621336"></p>
<p><strong>调度和切换的时机问题</strong>：调度和切换并不一定能一气呵成。通常的做法是，由内核置请求调度标志，延迟到敏感性操作完成后再进行进程调度和进程上下文切换。</p>
<p><strong>CPU模式切换：</strong></p>
<p>处理器总处于以下状态中的一种：</p>
<ul>
<li>内核态，运行于进程上下文，内核代表进程运行于内核空间，使用核心栈。 (进程请求系统调用，陷入内核)</li>
<li>内核态，运行于中断上下文，内核代表硬件运行于内核空间，与任何进程无关，中断服务程序正在处理特定中断。 (进程被中断)</li>
<li>用户态，运行于进程上下文，用户进程在运行，使用用户栈。 （进程正常运行)</li>
</ul>
<p>内核可以处于两种上下文：进程上下文和中断上下文。</p>
<ul>
<li>在系统调用之后，用户应用程序进入内核空间，此后内核空间针对用户空间相应进程的代表就运行于进程上下文。</li>
<li>异步发生的中断会引发中断处理程序被调用，中断处理程序就运行于中断上下文。</li>
<li>中断上下文和进程上下文不可能同时发生。</li>
<li>运行于进程上下文的内核代码是可抢占的，但中断上下文则会一直运行至结束，不会被抢占。</li>
</ul>
<p><img data-src="https://s2.loli.net/2022/03/08/kytGVsrFjpeDh5C.png" alt="image-20220308203423763"></p>
<h2 id="5、进程通信"><a href="#5、进程通信" class="headerlink" title="5、进程通信"></a>5、进程通信</h2><p><img data-src="https://s2.loli.net/2022/05/16/vgB2kzlGcLA4IQE.png" alt="image-20220516094111006"></p>
<p><strong>概念：</strong>进程之间的信息交换。为了保证安全，一个进程不能直接访问另一个进程的地址空间</p>
<p><strong>方法：</strong>共享内存、消息传递、信号机制、管道、RPC、Socket等等。其中共享内存和消息传递是IPC的两种<strong>基本模型</strong>。</p>
<p>共享内存：快。仅在建立共享内存区域时才采用系统调用。</p>
<p>消息传递：适合交换少量数据、易实现。常采用系统调用。</p>
<p>&#x3D;&#x3D;共享内存：&#x3D;&#x3D;</p>
<p><img data-src="https://s2.loli.net/2022/05/16/TBisA6XZtbx5CRc.png" alt="image-20220516093334379"></p>
<p>&#x3D;&#x3D;消息传递&#x3D;&#x3D;</p>
<p><img data-src="https://s2.loli.net/2022/05/16/yAuDL9CeaZJc5pK.png" alt="image-20220516093950844"></p>
<blockquote>
<p><strong>同步或异步的通信</strong></p>
<p>同步（阻塞）：发送之后需等待被接收；接收进程需等待有消息可用</p>
<p>异步（非阻塞） ：发送之后可继续其他操作；接收进程收到有效消息或者空消息，继续其他操作</p>
<p>有效的组合：阻塞发送，阻塞接收；非阻塞发送，阻塞接收（如客户机-服务器）；非阻塞发送，非阻塞接收。&#x3D;&#x3D;没有阻塞发送，非阻塞接收，否则发送进程可能死等。&#x3D;&#x3D;</p>
</blockquote>
<p>&#x3D;&#x3D;信号机制：&#x3D;&#x3D;</p>
<p><strong>概念：</strong>软件中断通知事件机制，一种古老且简单的通信机制。通过发送一个<strong>指定信号</strong>来通知进程某个异常事件发生。每个信号都有一个名字和编号，这些名字都以“SIG”开头，如SIGKILL。</p>
<p><strong>信号与中断的相同点及区别</strong></p>
<p>相同点：采用异步通信方式；获得请求时，暂停正在执行的任务转而执行相应的处理程序，处理完毕后返回断点；都可以被屏蔽。</p>
<p>区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>实现</th>
<th>优先级</th>
<th>运行态</th>
<th>及时</th>
<th>其他</th>
</tr>
</thead>
<tbody><tr>
<td><strong>中断</strong></td>
<td>硬件、软件结合</td>
<td>有</td>
<td>核心态</td>
<td>及时</td>
<td>程序并不知道自己被中断。</td>
</tr>
<tr>
<td><strong>信号</strong></td>
<td>软件</td>
<td>无</td>
<td>用户态</td>
<td>有较大时间延迟</td>
<td>由程序接收</td>
</tr>
</tbody></table>
<p><img data-src="https://s2.loli.net/2022/03/08/pgZGS5wv3LhP9DI.png" alt="image-20220308212641169"></p>
<p>&#x3D;&#x3D;管道机制&#x3D;&#x3D;</p>
<p><strong>管道的概念</strong>：连接读写进程的一个特殊文件。&#x3D;&#x3D;本质：共享文件&#x3D;&#x3D;，可借助文件系统的机制实现。用于同一机器的进程间通信</p>
<p><img data-src="https://s2.loli.net/2022/05/16/hNZYEUatvnwJgzr.png" alt="image-20220516093711586"></p>
<p><strong>管道的分类：</strong>匿名管道（半双工、只能用于具有亲缘关系的进程间通信）、有名管道（克服了只能用于具有亲缘关系的进程之间通信的限制）</p>
<h2 id="6、线程概念、多线程模型"><a href="#6、线程概念、多线程模型" class="headerlink" title="6、线程概念、多线程模型"></a>6、线程概念、多线程模型</h2><p><img data-src="https://s2.loli.net/2022/05/16/tyE8R4JhQMmKfNF.png" alt="image-20220516100255832"></p>
<p><strong>引入线程的目的</strong></p>
<ul>
<li><p>在操作系统中引入进程的目的是使多道程序能并发执行，以改善资源利用率及提高系统吞吐量；</p>
</li>
<li><p>在操作系统中再引入线程，则是为了减少程序并发执行所付出的时空开销，使操作系统具有更好的<strong>并发性</strong>。</p>
</li>
</ul>
<p><strong>概念</strong>：</p>
<ul>
<li><p>线程是进程内一个相对独立的、可调度的执行单元。</p>
</li>
<li><p>线程是CPU调度的基本单位</p>
</li>
<li><p>它由线程ID、程序计数器、寄存器集合和栈组成。 </p>
</li>
<li><p>&#x3D;&#x3D;它与属于同一进程的其他线程共享代码段、数据段和其他操作系统资源。&#x3D;&#x3D; </p>
</li>
<li><p>线程自己基本上不拥有资源，只拥有一点在运行时必不可少的资源（如程序计数器、一组寄存器和栈），但它可以与同属一个进程的其他线程共享进程拥有的全部资源</p>
</li>
</ul>
<p><img data-src="https://s2.loli.net/2022/05/16/58qohj4kQFBwfx2.png" alt="image-20220516094855723"></p>
<p><strong>线程与进程的比较：</strong></p>
<blockquote>
<p>线程可以主动让出处理器，进程可以通过wait()来让出处理器</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>调度</th>
<th>拥有的资源</th>
<th>系统开销</th>
</tr>
</thead>
<tbody><tr>
<td><strong>进程</strong></td>
<td>在传统OS中，进程是调度和分配资源的基本单位</td>
<td>进程是拥有资源的基本单位，由一个或多个线程及相关资源构成</td>
<td>大</td>
</tr>
<tr>
<td><strong>线程</strong></td>
<td>引入线程后，线程是调度和分派的基本单位</td>
<td>基本上不拥有资源，只拥有一点在运行时必不可少的资源（如程序计数器、一组寄存器和栈），但它可以与同属一个进程的其他线程共享进程拥有的全部资源</td>
<td>小</td>
</tr>
</tbody></table>
<p><strong>属性</strong></p>
<p><img data-src="https://s2.loli.net/2022/05/16/6248bugjiR3mZAT.png" alt="image-20220516095238427"></p>
<p><strong>实现方式</strong></p>
<ul>
<li><p>用户级线程</p>
<ul>
<li><p>概念：不依赖于操作系统核心，由应用进程利用<strong>用户级线程库</strong>提供创建、同步、调度和管理线程的函数来控制的线程。</p>
</li>
<li><p><strong>用户级线程对OS不可见，OS调度的依然是内核级线程</strong></p>
</li>
<li><p>纯用户级线程之间不能抢占，除非主动放弃处理器</p>
</li>
<li><p>优势：速度快（因为它不需要内核干预）</p>
</li>
<li><p>限制：</p>
<ul>
<li>当一个线程阻塞时，整个进程都必须等待（因为用户级线程对OS不可见）</li>
<li>处理机时间分配对象是进程，每个用户级线程的执行时间相对少一些</li>
</ul>
</li>
</ul>
</li>
<li><p>内核级线程</p>
<ul>
<li><p>概念：依赖于内核，由<strong>操作系统内核</strong> 完成创建和撤消工作的线程。 </p>
</li>
<li><p>一个内核级线程阻塞时不会影响同一进程的其他线程的运行。（因为可以调度其他线程）</p>
</li>
<li><p>处理机时间分配对象是线程，所以有多个线程的进程将获得更多处理机时间。</p>
</li>
<li><p>缺点：系统开销</p>
</li>
</ul>
<p>  <img data-src="https://s2.loli.net/2022/05/16/HQngtqdIwNY4rmL.png" alt="image-20220516095708821"></p>
</li>
<li><p><strong>多线程模型</strong></p>
<p>  <img data-src="https://s2.loli.net/2022/05/16/Ao4CZvHWhyiUd3p.png" alt="image-20220516095905848"></p>
<p>  <img data-src="https://s2.loli.net/2022/05/16/AiIb8h46MvJHq1r.png" alt="image-20220516100022950"></p>
<p>  <img data-src="https://s2.loli.net/2022/05/16/OzZUoPM7pvnby9q.png" alt="image-20220516100112838"></p>
</li>
</ul>
<h2 id="x3D-x3D-7、可能的大题：代码？-x3D-x3D-😫"><a href="#x3D-x3D-7、可能的大题：代码？-x3D-x3D-😫" class="headerlink" title="&#x3D;&#x3D;7、可能的大题：代码？&#x3D;&#x3D;😫"></a>&#x3D;&#x3D;7、可能的大题：代码？&#x3D;&#x3D;😫</h2><h3 id="1、fork-、exec-、vfork-、clone"><a href="#1、fork-、exec-、vfork-、clone" class="headerlink" title="1、fork()、exec()、vfork()、clone()"></a>1、fork()、exec()、vfork()、clone()</h3><p><strong>fork():</strong>  创造的子进程是父进程的完整副本，复制了父亲进程的所有资源</p>
<p><strong>exec():</strong>   fork()函数会调用此系统调用，使用指定的新程序填充进程空间</p>
<p>**vfork()**：创建的子进程与父进程共享数据段,而且由vfork()创建的子进程将先于父进程运行</p>
<p><strong>clone()：</strong>允许子进程有选择的共享父进程资源</p>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">( )</span> &#123; </span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(“fork new process error!\n”);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid ==<span class="number">0</span>)&#123;		<span class="comment">//child process</span></span><br><span class="line">        execlp(“/bin/ls”,”ls”, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LINE J&quot;</span>);	<span class="comment">//只有excelp调用失败时才会执行这条语句</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(“Child Complete”);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="x3D-x3D-2、fork-、getpid-和printf-x3D-x3D"><a href="#x3D-x3D-2、fork-、getpid-和printf-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;***2、fork()、getpid()和printf()&#x3D;&#x3D;"></a>&#x3D;&#x3D;***2、fork()、getpid()和printf()&#x3D;&#x3D;</h3><p>&#x3D;&#x3D;进程家族树：&#x3D;&#x3D;</p>
<p><img data-src="https://s2.loli.net/2022/05/16/sMmaLV4gUexGBfW.png" alt="image-20220516144045281"></p>
<p><img data-src="https://s2.loli.net/2022/05/16/7MbVpWcmZ6Pki5R.png" alt="image-20220516144104234"></p>
<hr>
<p><img data-src="https://s2.loli.net/2022/05/16/cNyvatSV4WY3HA7.png" alt="image-20220516145352414"></p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>七、虚拟内存管理</title>
    <url>/2022/06/27/%E4%B8%83%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="第7章-虚拟内存管理"><a href="#第7章-虚拟内存管理" class="headerlink" title="第7章 虚拟内存管理"></a>第7章 虚拟内存管理</h1><p>虚拟内存的概念 </p>
<p>局部性原理</p>
<p>请求分页系统</p>
<p>TLB刷新问题可以忽略</p>
<p>EAT计算，缺页中断，缺页率</p>
<p>&#x3D;&#x3D;页面分配和替换的算法&#x3D;&#x3D;  重点： 简单时钟及其变形</p>
<p>后面的基本是概念</p>
<p>局部页面替换：重点掌握局部最佳页面和工作集</p>
<p>抖动</p>
<h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><h3 id="（1）局部性原理✳"><a href="#（1）局部性原理✳" class="headerlink" title="（1）局部性原理✳"></a>（1）局部性原理✳</h3><p>CPU访问存储器时，无论是存取指令还是存取数据，单元都趋于聚集在一个较小的连续区域中，<strong>局部性体现为</strong>：</p>
<ol>
<li><strong>时间局部性</strong>：一条指令的一次执行和下次执行， 一个数据的一次访问和下次访问， 都集中在一个较短时间内</li>
<li><strong>空间局部性</strong>：当前执行的指令和将要执行的指令， 当前访问的数据和将要访问的数据， 都集中在一个较小范围内  </li>
<li><strong>顺序局部性</strong>：顺序执行与跳转比例5： 1</li>
</ol>
<p>局部性原理是虚拟内存的理论基础</p>
<h3 id="（2）虚拟内存的定义"><a href="#（2）虚拟内存的定义" class="headerlink" title="（2）虚拟内存的定义"></a>（2）虚拟内存的定义</h3><blockquote>
<p>虚拟内存，也称为虚拟存储器，指具有请求调入和替换功能， 能从逻辑上对内存容量加以扩充的一种存储器系统（是以时间换空间的技术）</p>
</blockquote>
<p><strong>虚拟内存的特征</strong>：</p>
<ul>
<li>离散性：不连续内存分配</li>
<li>多次性：一个作业分多次装入内存</li>
<li>对换性：允许运行中换进换出</li>
<li>虚拟性：逻辑上扩充内存</li>
</ul>
<p><strong>常用技术</strong>：</p>
<ul>
<li>请求分页存储管理</li>
<li>请求分段存储管理</li>
</ul>
<p>与前章区别：</p>
<ul>
<li>非请求分页&#x2F;段：一次性调入</li>
<li>请求分页&#x2F;段：按需调入，不需的换出</li>
</ul>
<h2 id="2、请求分页系统✳"><a href="#2、请求分页系统✳" class="headerlink" title="2、请求分页系统✳"></a>2、请求分页系统✳</h2><blockquote>
<p>请求分页存储管理方法：在分页存储管理的基础上增加了请求调页和页面置换功能 </p>
</blockquote>
<p><strong>支持机构</strong>：</p>
<ul>
<li><strong>物理部件</strong>：内存管理单元（MMU）</li>
<li><strong>页表</strong></li>
<li><strong>缺页中断机构</strong></li>
<li><strong>地址变换机构</strong></li>
<li><strong>请求调页和页面置换软件</strong></li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>作业的程序和数据可按页分散存放在内存中，减少移动开销，有效解决碎片问题</li>
<li>既有利于改进主存利用率，又有利于多道程序运行</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>要有硬件支持，进行缺页中断处理，机器成本增加，系统开销加大</li>
</ul>
<h3 id="（1）内存管理单元MMU"><a href="#（1）内存管理单元MMU" class="headerlink" title="（1）内存管理单元MMU"></a>（1）内存管理单元MMU</h3><blockquote>
<p>MMU：完成逻辑地址到物理地址的转换功能，它接受虚拟地址作为输入，物理地址作为输出，直接送到总线上，对内存单元进行寻址 </p>
</blockquote>
<img data-src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205291534881.png" alt="image-20220529153445797" style="zoom:50%;" />

<p><strong>MMU的主要功能</strong></p>
<ul>
<li>管理硬件页表基址寄存器</li>
<li>分解逻辑地址</li>
<li>管理快表</li>
<li>访问页表</li>
<li>发出缺页中断或越界中断，将控制权交给内核存储管理处理</li>
<li>管理特征位，设置和检查页表中各个特征位</li>
</ul>
<h3 id="（2）页表"><a href="#（2）页表" class="headerlink" title="（2）页表"></a>（2）页表</h3><p>与前一章相同，请求分页系统中使用的主要数据结构仍然是页表，但由于每次只将作业的一部分调入内存， 还有一部分内容存放在磁盘上， 故需要在页表中增加若干项，如下表所示：</p>
<p><img data-src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205291541612.png" alt="image-20220529154142586"></p>
<ul>
<li>页号和物理块号：其定义同分页存储管理 </li>
<li>存在位：用于表示该页是否在主存中 </li>
<li>访问字段：用于记录本页在一段时间内被访问的次数， 或最近已有多长时间未被访问</li>
<li>修改位：用于表示该页调入内存后是否被修改过</li>
<li>外存地址：用于指出该页在外存上的地址</li>
</ul>
<h3 id="（3）缺页中断✳"><a href="#（3）缺页中断✳" class="headerlink" title="（3）缺页中断✳"></a>（3）缺页中断✳</h3><blockquote>
<p>在请求分页系统中， 硬件查页表发现所访问的页不在内存时， 便产生缺页中断， 请求OS将缺页调入内存 操作系统执行缺页中断处理程序根据该页在外存的地址把它调入内存 </p>
</blockquote>
<p><strong>缺页中断的处理过程</strong></p>
<p><img data-src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205291545861.png" alt="image-20220529154500817"></p>
<p>如上图所示，包括以下6步</p>
<ol>
<li><strong>查找页表</strong>：发起对地址的访问，MMU到页表中检查引用情况  </li>
<li><strong>缺页中断</strong>：若不在内存，产生缺页中断，陷入缺页中断程序  </li>
<li><strong>查找外存</strong>：OS在外存中寻找外存中的页面备份</li>
<li><strong>调入内存</strong>：寻找空闲页帧，或依据某种替换算法选择被替换的页帧，将页面调入内存  </li>
<li><strong>修改页表</strong>：修改页表项信息</li>
<li><strong>重新执行</strong>：重新执行产生缺页的指令</li>
</ol>
<p><strong>缺页中断与一般中断的区别</strong></p>
<ol>
<li>缺页中断在指令的执行期间产生和处理</li>
<li>一条指令可以产生多个缺页中断，例如复制指令copy A to B</li>
<li>缺页中断返回时执行产生中断的指令，一般中断返回时执行下条指令</li>
</ol>
<blockquote>
<p>请求分页虚拟存储管理系统的地址变换过程类似于分页存储管理，但当被访问页不在内存时应进行缺页中断处理  </p>
</blockquote>
<h3 id="（4）地址变换"><a href="#（4）地址变换" class="headerlink" title="（4）地址变换"></a>（4）地址变换</h3><img data-src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205291636817.png" alt="image-20220529163638765" style="zoom:50%;" />

<p>地址变换的数据通路如上图所示，而以下是进行地址变换的流程图</p>
<img data-src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205291637270.png" alt="image-20220529163711225" style="zoom:50%;" />

<h3 id="（5）EAT计算✳✳✳感觉很大概率考！"><a href="#（5）EAT计算✳✳✳感觉很大概率考！" class="headerlink" title="（5）EAT计算✳✳✳感觉很大概率考！"></a>（5）EAT计算✳✳✳感觉很大概率考！</h3><img data-src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205291642336.png" alt="image-20220529164207293" style="zoom:50%;" />

<blockquote>
<p>如上图所示，令查找和修改快表的时间为ε，访存（包括查找页表和访问内存）的时间为t，快表命中率为α，页表缺页率为f，处理缺页中断时间为t1</p>
</blockquote>
<h4 id="访问内存时间计算（单次）"><a href="#访问内存时间计算（单次）" class="headerlink" title="访问内存时间计算（单次）"></a>访问内存时间计算（单次）</h4><ol>
<li><strong>若页在主存中且页表项在快表中</strong>：访问时间&#x3D;查快表时间+访问内存时间&#x3D;$\epsilon+t$</li>
<li><strong>若页在主存中且页表项不在快表中</strong>：访问时间&#x3D;查快表时间+查页表时间+修改快表时间<br> +访问内存时间&#x3D;$\epsilon+t+\epsilon+t&#x3D;2(\epsilon+t)$</li>
<li><strong>若页不在主存之中</strong>：访问时间&#x3D;查快表时间+查页表时间+处理缺页中断时间t1+查快表时间+访问内存时间 &#x3D;$\epsilon+t+t_1+\epsilon+t&#x3D;t_1+2(\epsilon+t)$</li>
</ol>
<h4 id="有效访问时间计算（多次平均情况）"><a href="#有效访问时间计算（多次平均情况）" class="headerlink" title="有效访问时间计算（多次平均情况）"></a>有效访问时间计算（多次平均情况）</h4><p>考虑以上三种情况的概率，其中①出现的概率为α、②出现的概率为(1-α)*(1-f)、③出现的概率为(1-α)*f，所以有效访问时间为：<br>$$<br>EAT&#x3D;\alpha*(\epsilon+t)+(1-\alpha)*[(1-f)<em>2(\epsilon+t)+f</em>(t_1+2(\epsilon+t))]\<br>&#x3D;(2-\alpha)(\epsilon+t)+(1-\alpha)ft_1<br>$$</p>
<h2 id="3、页面替换"><a href="#3、页面替换" class="headerlink" title="3、页面替换"></a>3、页面替换</h2><h3 id="（1）页面装入与清除策略"><a href="#（1）页面装入与清除策略" class="headerlink" title="（1）页面装入与清除策略"></a>（1）页面装入与清除策略</h3><p><strong>两种页面装入策略</strong>：</p>
<ul>
<li><strong>请求式调度</strong>：按需装入，但是需要频繁的磁盘I&#x2F;O</li>
<li><strong>预调式调度</strong>：利用局部性原理进行动态预测，预先装入</li>
</ul>
<p>两种页面清除策略：</p>
<ul>
<li><strong>请求式清除</strong>：当一页被选中进行替换且被修改过，则进行写回磁盘，缺点：效率低下</li>
<li><strong>预约式清除</strong>：对所有修改的页面，替换前，提前成批写回，要写回的页仍然在主存，直到被替换算法选中此页从主存中移出，若该页面在刚被写回后，在替换回前，再次被大量修改，则该策略失效</li>
</ul>
<p><strong>页面的两个来源</strong>：</p>
<ul>
<li><strong>文件区</strong>：用于存放文件，采用离散分配方式</li>
<li><strong>对换区</strong>：用于存放对换页面，采用连续分配方式，I&#x2F;O速度比文件区高</li>
</ul>
<p><strong>缺页时的三种情况</strong>：</p>
<ul>
<li><strong>当系统拥有足够的对换区空间</strong>：全部从对换区调入所需页面，以提高调页速度  </li>
<li><strong>当系统缺少足够的对换区空间</strong>：这时凡是不会被修改的文件，都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出，以后再调入时，仍从文件区直接调入，但对于那些可能被修改的部分，在将它们换出时，便须调到对换区，以后需要时，再从对换区调入  </li>
<li><strong>UNIX方式</strong>：与进程有关的文件都放在文件区，故凡是未运行过的页面，都应从文件区调入，对于曾经运行过但又被换出的页面，由于是被放在对换区，因此在下次调入时，应从对换区调入</li>
</ul>
<h3 id="（2）页面分配与替换策略"><a href="#（2）页面分配与替换策略" class="headerlink" title="（2）页面分配与替换策略"></a>（2）页面分配与替换策略</h3><p><strong>两种页面分配策略</strong>：</p>
<ul>
<li><strong>固定分配</strong>：进程保持页框数固定不变，只要有一个缺页中断产生，进程就会有一页被替换</li>
<li><strong>可变分配</strong>：进程分得的页框数可变，如果进程缺页率较高，说明目前局部性较差，可增加分配页框以降低缺页率；反之说明局部性较好，可减少分配页框数</li>
</ul>
<p>两种页面替换策略：</p>
<ul>
<li><strong>全局替换</strong>：替换算法的作用范围是整个系统，可以在运行的进程之间动态地分配页框</li>
<li><strong>局部替换</strong>：替换算法的作用范围局限于本进程，需要为每个进程分配固定的页框</li>
</ul>
<p><strong>三种分配和替换算法的配合</strong></p>
<ol>
<li><strong>固定分配+局部替换</strong>：容易、但是性能差</li>
<li><strong>可变分配+全局替换</strong>：容易，已经应用于若干操作系统中</li>
<li><strong>可变分配+局部替换</strong>：比较复杂，但是性能好</li>
</ol>
<h3 id="（3）页面替换算法✳✳✳必考！"><a href="#（3）页面替换算法✳✳✳必考！" class="headerlink" title="（3）页面替换算法✳✳✳必考！"></a>（3）页面替换算法✳✳✳必考！</h3><h4 id="最佳替换算法（OPT）"><a href="#最佳替换算法（OPT）" class="headerlink" title="最佳替换算法（OPT）"></a>最佳替换算法（OPT）</h4><blockquote>
<p>核心思想：淘汰掉将来不再访问， 或者距现在最长时间后才可能会访问的页面  </p>
</blockquote>
<blockquote>
<p>缺点：因页面访问的未来顺序很难精确预测，但算法具有理论意义，可用来评价其他算法的优劣</p>
</blockquote>
<p>实例如下：</p>
<p><img data-src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205292259528.png" alt="image-20220529225933474"></p>
<h4 id="先进先出算法（FIFO）"><a href="#先进先出算法（FIFO）" class="headerlink" title="先进先出算法（FIFO）"></a>先进先出算法（FIFO）</h4><blockquote>
<p>前提假设：程序按照线性顺序来访问物理空间</p>
</blockquote>
<blockquote>
<p>核心思想：选择调入主存时间最长的页面予以淘汰， 认为驻留时间最长的页面不再使用的可能性较大  </p>
</blockquote>
<p>实例如下：</p>
<p><img data-src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205292301046.png" alt="image-20220529230143996"></p>
<p><strong>特点</strong></p>
<ul>
<li>实现比较简单</li>
<li>对按照线性顺序访问的程序比较合适，对其他特性的程序效率不高</li>
<li>Belady现象：在某些情况下分配给进程的页面数增多，缺页次数反而增加（选择题可能考），其原因是FIFO算法的置换特征与进程访问内存的动态特征是矛盾的， 即被置换的页面并不是进程不会访问的</li>
</ul>
<p><strong>改进</strong>：页面缓冲算法</p>
<ul>
<li>采用FIFO选择被替换页面， 选择出的页面不是立即换出， 而是按照修改与否， 放到相应队列末尾：<ul>
<li>空闲队列：页面未修改则放入空闲队列末尾， 该链表也是可直接装入页面的页框所构成  </li>
<li>修改队列：页面已修改则放入修改队列末尾</li>
</ul>
</li>
<li>需要装入的页面被读进空闲队列队首页框中， 而不用等待淘汰页写回再装入  </li>
<li>当修改页面到一定数量， 就成批写回， 并把所占用页框挂到空闲链上</li>
</ul>
<h4 id="最近最久未使用算法（LRU）"><a href="#最近最久未使用算法（LRU）" class="headerlink" title="最近最久未使用算法（LRU）"></a>最近最久未使用算法（LRU）</h4><blockquote>
<p>核心思想：基于局部性原理：刚被使用过的页面可能还会立即被使用， 较长时间内未被使用的页面可能不会立即使用。进行页面替换时，选择最近一段时间内最长时间未被访问过的页面予以淘汰。为了实现，则赋予每个页面一个访问字段， 用于记录页面自上次访问以来所经历的时间， 同时维护一个淘汰队列  </p>
</blockquote>
<p>实例如下：</p>
<p><img data-src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205292314078.png" alt="image-20220529231452025"></p>
<p>具体实现方法包括：</p>
<ul>
<li><strong>基于计数器的方法</strong>：为每个页表项关联一个时间域字段，为CPU增加一个计数器或者逻辑时钟，每次时钟中断，计数器加1，每当访问一页时，将计数器值复制到相应页所对应页表项的时间域内，当发生缺页中断时，可选择时间域数值最小的对应页面淘汰  </li>
<li>基于栈的方法：用一个特殊的栈保存当前进程所访问的各页面号，每当进程访问某页面， 便将它对应的页面号从栈中移出， 压入栈顶，栈顶是最近访问的页面，栈底是最近最久未使用的页面  </li>
<li>引用位法：每一个页面关联一个bit，初始为0，当页面被引用时，设置为1，需要替换页面时，替换bit&#x3D;0的页面</li>
<li>附加引用位法（老化算法）：每页都有引用位，并为每页设一个8位内存信息，每隔规定时间，时钟定时器触发中断，将控制权交给OS；OS将每个页的引用位转移到8位字节的高位，并将其他位右移1位，抛弃最低位。这8位就表明了最近8个时间周期，页面的使用情况，发生缺页时挑选最小的为LRU页替换</li>
</ul>
<h4 id="二次机会算法"><a href="#二次机会算法" class="headerlink" title="二次机会算法"></a>二次机会算法</h4><blockquote>
<p>核心思想：使用FIFO算法选择一页淘汰时，先检查该页的访问位：</p>
<ul>
<li>如果是0就立即淘汰该页  </li>
<li>如果是1就给它第二次机会， 将其访问位清0，并将它放入页面链的末尾，将其装入时间置为当前时间，然后选择下一个页面</li>
</ul>
</blockquote>
<h4 id="简单时钟算法"><a href="#简单时钟算法" class="headerlink" title="简单时钟算法"></a>简单时钟算法</h4><blockquote>
<p>核心思想：将页面排成一个循环队列， 类似于时钟表面，并使用一个替换指针，当发生缺页时， 检查指针指向的页面：</p>
<ul>
<li>若其访问位为0，则淘汰该页</li>
<li>否则将该页的访问位清0，指针前移并重复上述过程， 直到找到访问位为0的淘汰页为止；最后指针停留在被替换页的下一页上（如下方流程图所示）</li>
</ul>
</blockquote>
<img data-src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205292326018.png" alt="image-20220529232625984" style="zoom:50%;" />

<p>实例如下：</p>
<p><img data-src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205292325259.png" alt="image-20220529232533212"></p>
<p>如上图，此时需要替换入page12，则将指针找到的第一个访问位为0的page21淘汰</p>
<p><img data-src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205292328587.png" alt="image-20220529232811539"></p>
<p>之所以块2、块3均无*标记，是因为时钟已经转过了块1、2、3，将其标志位置为0，然后替换的是块1</p>
<p><strong>算法极端情况</strong>：所有页都被引用，则选择时，需要先把所有页面遍历，清除所有引用位，则退化为FIFO</p>
<p><strong>算法的改进</strong>：考虑修改问题，定义R为访问位，M为修改位，则有以下4种类型：</p>
<table>
<thead>
<tr>
<th>R</th>
<th>M</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>未被访问也未被修改</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>未被访问但已被修改</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>已被访问但未被修改</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>已被访问且已被修改</td>
</tr>
</tbody></table>
<p>进行以下3步骤：</p>
<ol>
<li>从指针当前位置开始扫描循环队列， 寻找R&#x3D;0， M&#x3D;0的页面， 将满足条件的第一个页面作为淘汰页， 本轮扫描不修改“访问位R” （若失败， 则所有队列项中：若R&#x3D;0,M&#x3D;1；若R&#x3D;1, M&#x3D;0&#x2F;1）</li>
<li>若第1步失败， 则开始第2轮扫描， 寻找R&#x3D;0， M&#x3D;1的页面， 将满足条件的第一个页面作为淘汰页， 并将所有经历过页面的访问位R置0（若失败，  则所有队列项中：R&#x3D;1,M&#x3D;0&#x2F;1）</li>
<li>若第2步失败， 则将指针返回到开始位置， 然后重复第1步， 若仍失败则必须重复第2步， 此时一定能找到淘汰页面</li>
</ol>
<h4 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h4><blockquote>
<p>核心思想：根据程序的局部性原理，一般情况下，进程在一段时间内总是集中访问一些页面，这些页面称为活跃页面，如果分配给一个进程的物理页面数太少了，使该进程所需的活跃页面不能全部装入内存，则进程在运行过程中将频繁发生中断  </p>
<p>定义工作集：一个进程当前正在使用的页框集合，用W(T, Δ)表示，即该进程在过去的Δ个虚拟时间单位中访问到的页面的集合，如下方实例所示：</p>
<p><img data-src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205292349087.png" alt="image-20220529234937052"></p>
</blockquote>
<blockquote>
<p>基本思路：找出一个不在工作集之中的页面并置换之</p>
</blockquote>
<p><img data-src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205292350104.png" alt="image-20220529235041046"></p>
<p><strong>特点</strong>：概念上好，但监督驻留页面变化的开销很大，估算合适的窗口Δ大小也是个难题  </p>
<h3 id="4、抖动问题✳"><a href="#4、抖动问题✳" class="headerlink" title="4、抖动问题✳"></a>4、抖动问题✳</h3><p><strong>定义</strong>：由于频繁缺页，导致运行进程的大部分时间都用于页面的换入&#x2F;换出，而几乎不能完成任何有效的工作，则称此进程处于抖动状态。抖动又称为颠簸、颤动  </p>
<p><strong>分为两种</strong>：</p>
<ol>
<li>局部抖动</li>
<li>全局抖动</li>
</ol>
<p><strong>产生原因</strong>：</p>
<ol>
<li>进程分配的物理块太少</li>
<li>替换算法选择不当</li>
<li>全局替换使抖动传播</li>
</ol>
<p><strong>抖动的预防和接触</strong>：</p>
<ul>
<li>采用局部替换策略可以防止抖动传播  </li>
<li>通过挂起进程来解除抖动，所选择挂起进程的判断依据：<ul>
<li>优先级最低：符合进程调度原则</li>
<li>发生缺页中断的进程：内存不含工作集，缺页时应阻塞</li>
<li>最后被激活的进程：工作集可能不在内存</li>
<li>最大的进程：可释放较多空间</li>
</ul>
</li>
</ul>
<p><em>不在重点的一个东西：页面大小选择分析</em></p>
<p><img data-src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205292355923.png" alt="image-20220529235508873"></p>
<p><img data-src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205292355578.png" alt="image-20220529235516534"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>五、死锁</title>
    <url>/2022/06/27/%E4%BA%94%E3%80%81%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h1 id="5、死锁"><a href="#5、死锁" class="headerlink" title="5、死锁"></a>5、死锁</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="（1）死锁产生的原因"><a href="#（1）死锁产生的原因" class="headerlink" title="（1）死锁产生的原因"></a>（1）死锁产生的原因</h3><ul>
<li>竞争资源：多个进程竞争资源，而资源又不能同时满足其需求（如下图1）</li>
<li>进程推进顺序不当：进程申请资源和释放资源的顺序不当（如下图2）</li>
</ul>
<p>图1：竞争资源引起的死锁</p>
<img data-src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205152043664.png" alt="image-20220515204316626" style="zoom:50%;" />

<p>这类图中的<code>Pi</code>表示进程，<code>Ri</code>表示资源，由<code>Ri</code>指向<code>Pi</code>的箭头表示<code>Ri</code>已经被分配给了<code>Pi</code>，而由<code>Pi</code>指向<code>Ri</code>的箭头表示<code>Pi</code>请求<code>Ri</code></p>
<p>图2：进程推进顺序不当引起的死锁</p>
<img data-src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205152048260.png" alt="image-20220515204834225" style="zoom:50%;" />

<p>如上图，当进程的推进路线进入了死锁不可避免区，就会产生死锁</p>
<h3 id="（2）死锁产生的4个必要条件"><a href="#（2）死锁产生的4个必要条件" class="headerlink" title="（2）死锁产生的4个必要条件"></a>（2）死锁产生的4个必要条件</h3><ol>
<li>互斥条件：在一段时间内某资源仅为一个进程所占有</li>
<li>请求和保持条件（占有并等待）：又称为部分分配条件。当进程因请求资源被阻塞时，已分配资源保持不放</li>
<li>不剥夺条件（非抢占）：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走</li>
<li>循环等待条件：死锁发生时存在一个进程资源的循环</li>
</ol>
<h3 id="（3）资源分配图"><a href="#（3）资源分配图" class="headerlink" title="（3）资源分配图"></a>（3）资源分配图</h3><p>用来表示系统资源的分配关系，由一组结点N和一组边E所构成，其中：</p>
<ul>
<li>N包括进程节点P和资源节点R，进程节点用圆圈表示，资源节点用方框表示，每个方框对应着一种资源，方框中的一个点表示一种资源里的一个资源</li>
<li>E包括资源请求边（由P节点指向R节点）和资源分配边（由R节点指向P节点）</li>
</ul>
<p><strong>✳使用资源分配图来初步分析死锁：</strong></p>
<ul>
<li>如果分配图没有环：无死锁</li>
<li>如果分配图包含环：如果每个R节点中都只有一个资源，则一定会死锁；如果有多个资源，则只是存在死锁的可能，并不一定会死锁</li>
</ul>
<h3 id="（4）死锁的解除"><a href="#（4）死锁的解除" class="headerlink" title="（4）死锁的解除"></a>（4）死锁的解除</h3><ol>
<li>系统重启法</li>
<li>进程终止（进程撤销、逐步撤销）</li>
<li>资源抢占</li>
</ol>
<h2 id="处理死锁的基本方法"><a href="#处理死锁的基本方法" class="headerlink" title="处理死锁的基本方法"></a>处理死锁的基本方法</h2><ol>
<li>忽略死锁：被大多数系统采用，因为死锁出现概率低，忽略死锁的代价小</li>
<li>预防死锁：设置某些限制条件，通过破坏死锁产生的四个必要条件之一来预防死锁</li>
<li>避免死锁：在资源的动态分配过程之中，用某种方法防止系统进入不安全状态</li>
<li>检测死锁及解除：系统定期检测是否出现死锁，如果出现则解除之</li>
</ol>
<h3 id="（1）预防死锁"><a href="#（1）预防死锁" class="headerlink" title="（1）预防死锁"></a>（1）预防死锁</h3><p>可以通过破坏产生死锁的四个必要条件之中的一个或几个条件来防止死锁的发生</p>
<h4 id="①破坏互斥条件"><a href="#①破坏互斥条件" class="headerlink" title="①破坏互斥条件"></a>①破坏互斥条件</h4><ul>
<li>主要思路：使资源可以同时访问，而非互斥使用</li>
<li>局限性：互斥对一些资源是固有属性不能改变</li>
</ul>
<h4 id="②破坏请求和保持条件"><a href="#②破坏请求和保持条件" class="headerlink" title="②破坏请求和保持条件"></a>②破坏请求和保持条件</h4><ul>
<li>主要思路：当每个进程申请一个资源时，不能占有其他资源</li>
<li><em>方法1：要求进程一次申请其所需的全部资源，如果有足够的资源则分配给进程，否则不分配，进程等待（静态资源分配法）</em></li>
<li><em>方法2：允许进程仅在没有资源时才可以申请资源，一个进程申请资源并使用，但是在申请更多资源时应释放已经分配的所有资源</em></li>
<li>优点：简单并且易于实现</li>
<li>缺点：资源利用率低，进程延迟运行，可能发生饥饿</li>
</ul>
<h4 id="③破坏不可剥夺条件"><a href="#③破坏不可剥夺条件" class="headerlink" title="③破坏不可剥夺条件"></a>③破坏不可剥夺条件</h4><ul>
<li>主要思路：对一个已经获得某些资源的进程，若新的资源请求的不到满足，则其已经占有的资源都可以被抢占，即这些资源都被隐式释放了（常用于状态已于恢复和保存的资源）</li>
<li>局限性：这种释放有可能造成已有工作的失效，重新申请和释放会带来新的系统开销</li>
</ul>
<h4 id="④破坏循环等待条件"><a href="#④破坏循环等待条件" class="headerlink" title="④破坏循环等待条件"></a>④破坏循环等待条件</h4><p>采取层次分配策略，将资源分为多个层次，并且应用如下规则：</p>
<ul>
<li>当进程得到某一层的一个资源后，只能申请较高层次的资源</li>
<li>当进程释放某层的一个资源时，必须先释放占有的较高层次的资源  </li>
<li>当进程得到某一层的一个资源后，它想申请该层的另一个资源时，必须先释放该层中的已占资源</li>
</ul>
<p>采取层次分配的变种：按序分配策略</p>
<p>首先将系统的所有资源排一个顺序，如系统若共有n个进程，有m个资源，用$r_i$表示第$i$个资源，则这$m$个资源是$r_1,r_2,……,r_m$，并应用如下规则：</p>
<ul>
<li>进程不得在占用资源$r_i$后再申请$r_j(j&lt;i)$</li>
<li>即只能申请编号之后的资源，不许申请编号之前的资源</li>
</ul>
<p>证明：</p>
<p><img data-src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205152149789.png" alt="image-20220515214959740"></p>
<h3 id="（2）避免死锁"><a href="#（2）避免死锁" class="headerlink" title="（2）避免死锁"></a>（2）避免死锁</h3><p>允许系统中存在前3个必要条件，通过合适的资源分配算法，防止系统进入不安全状态 ，确保不会出现第四个必要条件，从而避免死锁。  </p>
<p><strong>【定义】安全状态</strong>：如果系统能按照某种顺序来为每个进程分配其所需的资源直到最大需求，使每个进程都可以顺利完成，则称此时的系统状态为安全状态，称序列为安全序列</p>
<p><strong>【定义】不安全状态</strong>：某一时刻系统中不存在安全序列</p>
<h4 id="①资源分配图算法"><a href="#①资源分配图算法" class="headerlink" title="①资源分配图算法"></a>①资源分配图算法</h4><p>资源分配图的简化：</p>
<ul>
<li>在资源分配图中找到一个既不阻塞又非孤立的进程节点Pi（不阻塞：该节点并未处于等待中，非孤立：有边项链）</li>
<li>将Pi运行完成，删掉其所有的请求边和分配边</li>
</ul>
<p>不断进行上述两个过程，如果能消去图中所有的边，则该图为可完全简化的，否则是不可完全简化</p>
<blockquote>
<p>死锁定理： S为死锁状态的条件，当且仅当S状态的资源分配图是不可完全简化的  </p>
</blockquote>
<h4 id="②银行家算法"><a href="#②银行家算法" class="headerlink" title="②银行家算法"></a>②银行家算法</h4><hr>
<p><em><strong>首先进行初始化</strong></em></p>
<p>假设系统中有n个进程，所需求的资源有m类，则定义以下的数据结构：</p>
<ul>
<li><strong>最大需求矩阵Max</strong>（n行m列）：定义了系统中每个进程对m类资源的最大需求数目</li>
<li><strong>分配矩阵Allocation</strong>（n行m列）：定义了系统中每个进程对m类资源的已经分配的情况</li>
<li><strong>需求矩阵Need</strong>（n行m列）：定义了系统中的每一个进程还需要的各类资源数目</li>
<li><strong>可用资源向量Available</strong>（m列）：定义了系统中的每类资源所剩余的数目</li>
</ul>
<p>资源分配表由以上的数据结构构成，如下图所示：</p>
<p><img data-src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205162323289.png" alt="image-20220516232351253"></p>
<hr>
<p><em><strong>其次进行预分配</strong></em></p>
<p>假设进程Pi对场上的资源做出请求，该请求用请求向量<strong>Requesti</strong>（m列）来表示，对应所分别请求的m类资源的数目，首先进行以下两步检查：</p>
<ol>
<li>如果$Request_i\le Need_i$，则说明该进程请求的不比自己需要的多，可以继续向下，否则报错</li>
<li>如果$Request_i\le Available$，则说明该进程的请求可以被剩余资源所满足，可以继续向下，否则报错</li>
</ol>
<p>经过以上两步检查之后，尝试将资源做出分配满足请求，更新资源分配表，方法如下：<br>$$<br>Available&#x3D;Available-Request_i\<br>Allocation_i&#x3D;Allocation_i+Request_i\<br>Need_i&#x3D;Need_i-Request_i<br>$$</p>
<hr>
<p><em><strong>最后进行安全性检查</strong></em></p>
<p>新定义两个数据结构</p>
<ul>
<li><strong>空闲资源向量Work</strong>（m列）：是一个随着安全性检查改变的向量，指的是安全性检查的过程中，系统的每类资源剩余的数目，其初始定义为Available，之后随着进程的释放会发生改变</li>
<li><strong>完成向量Finish</strong>（n行）：表示某个进程是否可以完成，初始定义为false，随着进程的完成会发生改变</li>
</ul>
<p>安全性检查的过程为：</p>
<ul>
<li>在几个进程之中找到一个未完成的进程$i$，$Need_i$向量小于Work向量，执行之，将其填入安全性检查表，而$Work+Allocation_i$作为新的Work，置$Finish_i&#x3D;true$</li>
<li>重复以上操作，直至将安全性检查表填满，或者遇到无法分配的状况</li>
</ul>
<p>安全性检查表示意图如下：</p>
<p><img data-src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205162322116.png" alt="image-20220516232237019"></p>
<blockquote>
<p>可以证明：只要存在一个序列不是安全序列，那么任意路径都不是安全序列。只要有一个序列是安全序列，那么在算法进行过程中出现的任何分叉点所构成的其它序列就都是安全序列  </p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>六、主存储器管理</title>
    <url>/2022/06/27/%E5%85%AD%E3%80%81%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="第六章-主存储器管理"><a href="#第六章-主存储器管理" class="headerlink" title="第六章  主存储器管理"></a>第六章  主存储器管理</h1><p><img data-src="https://s2.loli.net/2022/04/26/9zCRymrJVXKgWdp.png" alt="image-20220426184538793"></p>
<h2 id="6-1-存储器管理的基本概念"><a href="#6-1-存储器管理的基本概念" class="headerlink" title="6.1 存储器管理的基本概念"></a>6.1 存储器管理的基本概念</h2><p><img data-src="https://s2.loli.net/2022/04/22/9uJisnzPHkCyhqf.png" alt="image-20220422195823004"></p>
<h3 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h3><ul>
<li><p>存储器的层次结构：</p>
  <img data-src="https://s2.loli.net/2022/04/18/kBPG8J9SEaDzYq5.png" alt="image-20220418230644829" style="zoom:67%;" />
</li>
<li><p>&#x3D;&#x3D;内存的概念与作用&#x3D;&#x3D;：内存是用于存放数据的硬件。程序执行时需要先放到内存中才能被CPU处理。</p>
</li>
<li><p>&#x3D;&#x3D;存储单元和地址&#x3D;&#x3D;：每个地址对应一个存储单元</p>
<p>  <img data-src="https://s2.loli.net/2022/04/22/RTVxmjzKpG9QhCs.png" alt="image-20220422194032845"></p>
<blockquote>
<p>按字节编址的意思是一个字节对应一个地址，而一个地址又对应一个存储单元，故一个存储单元是一个字节。</p>
<p>1K &#x3D; 2^10^; 1M &#x3D; 2^20^;1G &#x3D; 2^30^B</p>
</blockquote>
</li>
<li><p>主存储器分为两大部分：</p>
<ul>
<li>系统区：存放操作系统内核程序与数据结构，供操作系统使用</li>
<li>用户区：存放应用程序与数据，往往被划分为一个或多个区域，供用户进程使用。</li>
</ul>
</li>
<li><p>存储器管理的主要目标：为用户提供方便、安全和充分大的存储器，支持大型应用和系统程序及数据的使用。</p>
</li>
<li><p>&#x3D;&#x3D;主存储器管理的四个功能&#x3D;&#x3D;</p>
<ul>
<li>存储空间的分配和回收</li>
<li>（存储器的）抽象与（地址）映射</li>
<li>隔离与共享：进程对存储空间的独占式使用以及共享访问</li>
<li>存储扩充：在逻辑上为用户提供一个比实际物理内存更大的存储空间</li>
</ul>
<p>  <img data-src="https://s2.loli.net/2022/04/22/wZlaXGmOqE3Rgnr.png" alt="image-20220422201759192"></p>
</li>
<li><p>&#x3D;&#x3D;逻辑地址：&#x3D;&#x3D;用户编程时所使用的地址。又称相对地址、虚地址。</p>
<blockquote>
<p>相对地址是指相对于进程在内存中的起始位置</p>
</blockquote>
</li>
<li><p>地址空间：逻辑地址的集合。</p>
</li>
<li><p>&#x3D;&#x3D;物理地址：&#x3D;&#x3D;内存中的地址。又称绝对地址、实地址。</p>
</li>
<li><p>主存空间：物理地址的集合。</p>
</li>
<li><p>地址变换：将逻辑地址转换为物理地址。又称地址映射、重定位。</p>
</li>
</ul>
<h3 id="2、程序的装入（三种方式）"><a href="#2、程序的装入（三种方式）" class="headerlink" title="2、程序的装入（三种方式）"></a>2、程序的装入（三种方式）</h3><blockquote>
<p>为将一个用户源程序变为一个在内存中可执行的文件，通常要经历以下步骤：编译、链接、装入。 </p>
<p><img data-src="https://s2.loli.net/2022/04/22/kSb8GL1XeHc4yZA.png" alt="image-20220422194535038"></p>
</blockquote>
<p>&#x3D;&#x3D;装入的三种方式：&#x3D;&#x3D;（用三种不同的方法完成从逻辑地址到物理地址的转换）绝对装入、静态重定位、动态重定位</p>
<p><img data-src="https://s2.loli.net/2022/04/22/21KBG8SnQRJa3qA.png" alt="image-20220422201910868"></p>
<hr>
<p><img data-src="https://s2.loli.net/2022/04/22/BJuhFYnTjV1ftZq.png" alt="image-20220422194810619"></p>
<p>特点：</p>
<ul>
<li>知道程序驻留在内存中的确定位置，编译之后代码中包含了程序的物理地址。</li>
<li>装入模块之后，程序的逻辑地址与物理地址是完全相同的，不需要对程序和数据进行修改。</li>
<li>只能将目标代码装入到内存中事先指定的位置，不适应多道程序环境的动态特性。</li>
<li>通常在程序中采用符号地址，通过编译器，将符号地址转换为绝对地址</li>
</ul>
<hr>
<p><img data-src="https://s2.loli.net/2022/04/22/xucXk1thRyiBHmq.png" alt="image-20220422194854316"></p>
<p>特点：</p>
<ul>
<li>物理地址 &#x3D; 程序起始地址 + 逻辑地址</li>
<li>地址变换通常是在装入时一次完成的，以后不再改变，故称为静态重定位</li>
<li>不需硬件支持，且要求分配连续存储空间，但程序运行时不能在内存移动，难以实现数据与代码的共享</li>
</ul>
<hr>
<p><img data-src="https://s2.loli.net/2022/04/22/wc1LaQNlAHX7Yev.png" alt="image-20220422194951839"></p>
<blockquote>
<p>多道程序中，重定位寄存器的内容存储在进程PCB中。当进程被调入时，重定位寄存器被重新设置，原有进程的重定位寄存器的内容随进程上下文切换而得到保护</p>
</blockquote>
<h3 id="3、程序的链接：（三种方式）"><a href="#3、程序的链接：（三种方式）" class="headerlink" title="3、程序的链接：（三种方式）"></a>3、程序的链接：（三种方式）</h3><p><img data-src="https://s2.loli.net/2022/04/22/MYpJXOCoErfDwQU.png" alt="image-20220422195515438"></p>
<p><img data-src="https://s2.loli.net/2022/04/22/E1V3ZHSMBhIiuUn.png" alt="image-20220422195557231"></p>
<blockquote>
<p>在装入目标模块时，如果发生一个外部模块调用，就会引起装入程序去寻找相应的外部目标模块，并将其装入内存，同时还要修改目标模块中的相对地址</p>
</blockquote>
<hr>
<p><img data-src="https://s2.loli.net/2022/04/22/mdWYMIwtRxn7y8r.png" alt="image-20220422195610600"></p>
<h3 id="4、内存保护"><a href="#4、内存保护" class="headerlink" title="4、内存保护"></a>4、内存保护</h3><p>概念：防止一个进程破坏操作系统或其他进程</p>
<p>方法</p>
<ul>
<li><p><strong>界限存储器法：</strong>通过对每个进程设置一对界限寄存器来防止越界访问，达到存储保护的目的。两种实现方式：上下界寄存器、基址限长寄存器</p>
</li>
<li><p><strong>存储保护键：</strong>通过保护键匹配来判断存储访问方式是否合法。为每个存储块分配一个保护键，相当于一把锁；进入系统的每个作业赋予一个保护键，相当于一把钥匙。当作业运行时，检查钥匙和锁是否匹配，若二者匹配，则允许访问。否则发出保护性中断信号</p>
</li>
<li><p><strong>环保护机制</strong>：处理器状态分为多个环，分别具有不同的存储访问特权级，通常环的编号越小，特权级越高。</p>
  <img data-src="https://s2.loli.net/2022/04/22/uzQVWwOtlcnBYG1.png" alt="image-20220422200314969" style="zoom:67%;" />
</li>
<li><p><strong>访问权限</strong>：只读、只能执行…</p>
</li>
</ul>
<h2 id="6-2-连续分配管理方式"><a href="#6-2-连续分配管理方式" class="headerlink" title="6.2 连续分配管理方式"></a>6.2 连续分配管理方式</h2><blockquote>
<p>连续分配：指为用户进程分配的必须是一个连续的内存空间</p>
</blockquote>
<p><img data-src="https://s2.loli.net/2022/04/22/8cJ1SPaBdwxyoNH.png" alt="image-20220422212711179"></p>
<h3 id="1、单一连续分配"><a href="#1、单一连续分配" class="headerlink" title="1、单一连续分配"></a>1、单一连续分配</h3><p><img data-src="https://s2.loli.net/2022/04/22/Uk51jlfVH7PoCwc.png" alt="image-20220422212019478"></p>
<h3 id="2、固定分区分配"><a href="#2、固定分区分配" class="headerlink" title="2、固定分区分配"></a>2、固定分区分配</h3><p><img data-src="https://s2.loli.net/2022/04/22/q6tSomYnjTP2Mb7.png" alt="image-20220422212047775"></p>
<p><img data-src="https://s2.loli.net/2022/04/22/IDFb1U9ugJECczh.png" alt="image-20220422212113844"></p>
<h3 id="3、动态分区分配及内外部碎片"><a href="#3、动态分区分配及内外部碎片" class="headerlink" title="3、动态分区分配及内外部碎片"></a>3、动态分区分配及内外部碎片</h3><p><img data-src="https://s2.loli.net/2022/04/22/w18xeFYEnylipuZ.png" alt="image-20220422212138065"></p>
<p><img data-src="https://s2.loli.net/2022/04/22/v5Sokj4dAZJFr6I.png" alt="image-20220422212158090"></p>
<p><img data-src="https://s2.loli.net/2022/04/22/Ybwf3uDgi2MUls4.png" alt="image-20220422212228592"></p>
<blockquote>
<p>动态重定位装入方式，需要修改进程的起始地址，即重定位寄存器</p>
</blockquote>
<h3 id="4、动态分区分配算法"><a href="#4、动态分区分配算法" class="headerlink" title="4、动态分区分配算法"></a>4、动态分区分配算法</h3><p><img data-src="https://s2.loli.net/2022/04/22/RHy9NQuJXAzM7oP.png" alt="image-20220422215829014"></p>
<blockquote>
<p>首次适应和邻近适应一般都不需要对空闲分区队列重新排序，因为虽然空闲分区的大小变小了，但它在内存中的位置并没有发生变化，即在分区队列中的位置一般不会发生改变。</p>
<p>首次适应算法的缺点：低地址端有许多小空闲分区时会增加查找开销。</p>
<p>首次适应和最佳适应在执行时间和利用空间方面都好于最坏适应。</p>
<p>首次适应和最佳适应在利用空间方面能力相当，但首次适应更快</p>
</blockquote>
<p><strong>扩展：可重定位分区分配技术</strong></p>
<img data-src="https://s2.loli.net/2022/04/22/IBYsaClkRcHoE9u.png" alt="image-20220422221246833" style="zoom:67%;" />

<h3 id="5、伙伴系统（Knuth，-1973）"><a href="#5、伙伴系统（Knuth，-1973）" class="headerlink" title="5、伙伴系统（Knuth， 1973）"></a>5、伙伴系统（Knuth， 1973）</h3><ul>
<li><p><strong>算法思想：</strong>伙伴系统采用伙伴算法对空闲内存进行管理。该方法通过不断以1&#x2F;2的形式来分割大的空闲存储块，从而获得小的空闲存储块。当内存块释放时，应尽可能合并空闲块</p>
</li>
<li><p><strong>如何实现：</strong></p>
<ul>
<li><p><strong>内存分配：</strong>设系统初始时可供分配的空间为2^m^个单元。当进程申请大小为n的空间时，设2^i-1^&lt;n≤2^i^，则为进程分配大小为2^i^的空间。如系统不存在大小为2^i^的空闲块，则查找系统中是否存在大于2^i^的空闲块2^i+1^, 2^i+2^…，若找到则对其进行对半划分，直到产生大小为2^i^的空闲块为止。</p>
</li>
<li><p><strong>内存回收：</strong>当进程释放存储空间时，应检查释放块的伙伴是否空闲，若空闲则合并。如果这个较大的空闲块也存在空闲伙伴，此时也应合并。重复上述过程，直至没有可以合并的伙伴为止。</p>
<blockquote>
<p>伙伴：当一个块被分成两个大小相等的块时，这两个块称为伙伴</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>伙伴地址公式：</strong></p>
  <img data-src="https://s2.loli.net/2022/04/22/L7U5PkTdwH3OYEI.png" alt="image-20220422222038028" style="zoom:67%;" />
</li>
<li><p><strong>例子：</strong></p>
  <img data-src="https://s2.loli.net/2022/04/22/3slKQh9UVF61GNY.png" alt="image-20220422222207775" style="zoom:67%;" />

  <img data-src="https://s2.loli.net/2022/04/22/6rAveaZuP2FtsGl.png" alt="image-20220422222218692" style="zoom:67%;" />
</li>
<li><p>伙伴系统可以用<strong>二叉树</strong>来表示</p>
  <img data-src="https://s2.loli.net/2022/04/22/5WgtNnbmEVT7U2q.png" alt="image-20220422222353326" style="zoom:50%;" />
</li>
<li><p><strong>伙伴系统的优缺点：</strong></p>
<ul>
<li>适合于小数据量的内存管理（大数据量的内存管理采用段页式的分配管理）</li>
<li>分配和回收时需要对伙伴进行拆分和合并；存储空间有浪费</li>
</ul>
</li>
</ul>
<h2 id="6-3-内存空间的扩充—-覆盖与交换技术"><a href="#6-3-内存空间的扩充—-覆盖与交换技术" class="headerlink" title="6.3 内存空间的扩充—-覆盖与交换技术"></a>6.3 内存空间的扩充—-覆盖与交换技术</h2><p><img data-src="https://s2.loli.net/2022/04/22/Birx7bMAGERwJ9t.png" alt="image-20220422204051322"></p>
<h3 id="1、覆盖技术："><a href="#1、覆盖技术：" class="headerlink" title="1、覆盖技术："></a>1、覆盖技术：</h3><p><img data-src="https://s2.loli.net/2022/04/22/Alw9ZgyxRfj8Kem.png" alt="image-20220422203902006"></p>
<p><img data-src="https://s2.loli.net/2022/04/22/1fzUj6pA2xSyuPr.png" alt="image-20220422203914236"></p>
<blockquote>
<p>可以理解为A先调用B再调用C。覆盖区的大小由覆盖段中最大的覆盖决定。</p>
</blockquote>
<h3 id="2、交换技术"><a href="#2、交换技术" class="headerlink" title="2、交换技术"></a>2、交换技术</h3><p><img data-src="https://s2.loli.net/2022/04/22/5zmfZlBMkPJbXIC.png" alt="image-20220422203956311"></p>
<p><img data-src="https://s2.loli.net/2022/04/22/o6CZmg17Vk9DtqN.png" alt="image-20220422204018912"></p>
<p><img data-src="https://s2.loli.net/2022/04/22/3mWqcjL49PvEoMu.png" alt="image-20220422204034668"></p>
<h3 id="3、覆盖技术与交换技术的区别"><a href="#3、覆盖技术与交换技术的区别" class="headerlink" title="3、覆盖技术与交换技术的区别"></a>3、覆盖技术与交换技术的区别</h3><ul>
<li>由谁完成：交换技术由操作系统完成；而覆盖技术由程序员给出作业各部分之间的覆盖结构，并清楚系统的存储结构</li>
<li>交换技术主要在不同作业之间进行，而覆盖技术是在同一个作业之间进行</li>
<li>覆盖技术主要用于早期操作系统，而交换技术在现代操作系统中仍然在使用</li>
</ul>
<hr>
<h2 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h2><h2 id="6-4-基本分页存储管理"><a href="#6-4-基本分页存储管理" class="headerlink" title="6.4 基本分页存储管理"></a>6.4 基本分页存储管理</h2><p><img data-src="https://s2.loli.net/2022/04/26/shWHLjUf6P3EOMn.png" alt="image-20220426185513138"></p>
<ul>
<li><p><strong>思想：</strong>把内存分成一个个相等的内存块，再按照页面大小把进程拆分成一个个小部分</p>
<blockquote>
<p>👉&#x3D;&#x3D;页式管理中地址是一维的&#x3D;&#x3D;，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位</p>
</blockquote>
</li>
</ul>
<h3 id="1、分页存储管理的基本概念与实现思想"><a href="#1、分页存储管理的基本概念与实现思想" class="headerlink" title="1、分页存储管理的基本概念与实现思想"></a>1、分页存储管理的基本概念与实现思想</h3><p><img data-src="https://s2.loli.net/2022/04/26/6jOa9wRxq5kZpeE.png" alt="image-20220426184900709"></p>
<blockquote>
<p>页框：page frame</p>
</blockquote>
<h3 id="2、分页的逻辑地址结构"><a href="#2、分页的逻辑地址结构" class="headerlink" title="2、分页的逻辑地址结构"></a>2、分页的逻辑地址结构</h3><p><img data-src="https://s2.loli.net/2022/04/26/fgxcYj4lD6J5t7Z.png" alt="image-20220426185131448"></p>
<blockquote>
<p>为了方便计算页号和页内偏移量，页面大小通常为2的整数幂，一般在512B到64KB之间</p>
</blockquote>
<h3 id="3、页表机制及其相关技术"><a href="#3、页表机制及其相关技术" class="headerlink" title="3、页表机制及其相关技术"></a>3、页表机制及其相关技术</h3><h4 id="（1）页表"><a href="#（1）页表" class="headerlink" title="（1）页表"></a>（1）页表</h4><p><img data-src="https://s2.loli.net/2022/04/26/1Ue85KMBbnET3ug.png" alt="image-20220426185341689"></p>
<blockquote>
<p>页号是隐含在索引中的。且进程页表通常是装在连续的内存块中的。</p>
<p>为了方便页表的查询，常常会让一个页表项占更多的字节，使得每个页面恰好可以装得下整数个页表项（如页面大小为4KB，内存块号需要20位，但页表项的大小为4B，这样一个页框就可以存放1K个页表项）。多余的空间可以用来存放别的东西。</p>
<p>不同的页号可能对应相同的块号，以实现内存共享。</p>
<p>页表一般存放在内存中，也可以在页表中设置存取控制字段，以实现存储保护。</p>
</blockquote>
<hr>
<h4 id="（2）存储分块表"><a href="#（2）存储分块表" class="headerlink" title="（2）存储分块表"></a>（2）存储分块表</h4><ul>
<li><p><strong>作用</strong>：记录内存中各物理块的使用情况及未分配物理块总数</p>
</li>
<li><p><strong>表示方法：</strong>位示图或者空闲存储块链</p>
<ul>
<li><p><strong>位示图：</strong>利用二进制的一位表示一个物理块的状态，1表示已分配，0表示未分配。所有物理块状态位的集合构成位示图。</p>
<p>  <img data-src="https://s2.loli.net/2022/04/26/DmTfiFCbVOxh7Wc.png" alt="image-20220426202759287"></p>
<blockquote>
<p>位示图占用的存储空间为：物理块数&#x2F;8（字节）</p>
</blockquote>
</li>
<li><p><strong>空闲存储块链：</strong>将所有的空闲存储块用链表链接起来，利用空闲物理块中的单元存放指向下一个物理块的指针。</p>
</li>
</ul>
</li>
</ul>
<h4 id="（3）存储空间的分配和回收："><a href="#（3）存储空间的分配和回收：" class="headerlink" title="（3）存储空间的分配和回收："></a>（3）存储空间的分配和回收：</h4><ul>
<li><p><strong>页面分配</strong>：计算进程所需页面数，然后在请求表中登记进程号、请求页面数等。如存储分块表中有足够的空闲块可供进程使用，则在系统中取得页表始址，并在页表中登记页号及其对应的物理块号，否则无法分配。</p>
</li>
<li><p><strong>页面回收</strong>：将存储分块表中相应的物理块改为未分配，或将回收块加入到空闲存储块链中，并释放页表，修改请求表中的页表始址及状态。</p>
<p>  ​</p>
</li>
</ul>
<h3 id="4、地址变换机构"><a href="#4、地址变换机构" class="headerlink" title="4、地址变换机构"></a>4、地址变换机构</h3><h4 id="（1）基本地址变换机构"><a href="#（1）基本地址变换机构" class="headerlink" title="（1）基本地址变换机构"></a>（1）基本地址变换机构</h4><p><img data-src="https://s2.loli.net/2022/04/26/LI2TRfFBOoytP73.png" alt="image-20220426191039460"></p>
<ul>
<li><p><strong>概念：</strong>用于实现逻辑地址到物理地址转换的一组硬件机构</p>
</li>
<li><p><strong>作用：</strong>借助进程的页表将逻辑地址转换为物理地址，也就是将逻辑地址中的页号转换为内存中的物理块号</p>
</li>
<li><p>通常会在系统中设置一个&#x3D;&#x3D;页表寄存器PTR&#x3D;&#x3D;，存放页表在内存中的起始地址F和页表长度M。进程未执行时，&#x3D;&#x3D;页表的始址和页表长度&#x3D;&#x3D;（也就是页表有多少项）放在进程控制块PCB中，当进程被调度时，os内核会把它们放到页表寄存器中。</p>
</li>
<li><p><strong>地址变换过程：</strong></p>
<p>  <img data-src="https://s2.loli.net/2022/04/26/ceUhD6AbCLjO2xR.png" alt="image-20220426190157556"></p>
</li>
<li><p><img data-src="https://s2.loli.net/2022/04/26/gA7iu4MrpZRTPFf.png" alt="image-20220426190052298"></p>
<p>  ​    </p>
</li>
<li><p><strong>例子：</strong></p>
<p>  <img data-src="https://s2.loli.net/2022/04/26/cbvfMPXd7yW89Qs.png" alt="image-20220426190431148"></p>
</li>
</ul>
<h4 id="（2）具有快表的地址变换机构"><a href="#（2）具有快表的地址变换机构" class="headerlink" title="（2）具有快表的地址变换机构"></a>（2）具有快表的地址变换机构</h4><ul>
<li><p><strong>局部性原理：</strong></p>
<p>  <img data-src="https://s2.loli.net/2022/04/26/VUxWraSvYoB4Jhg.png" alt="image-20220426191351742"></p>
</li>
<li><p><strong>快表（TLB， translation look-aside buffer，联想寄存器）</strong>：一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为<strong>慢表</strong>。</p>
</li>
<li><p><strong>引入快表后，地址的变换过程：</strong></p>
<p>  <img data-src="https://s2.loli.net/2022/04/26/S8IdibhkaMsR4BW.png" alt="image-20220426191704882"></p>
<p>  <img data-src="https://s2.loli.net/2022/04/26/8cIa4M9qDkFpbNm.png" alt="image-20220426191721463"></p>
<hr>
<blockquote>
<p>当发生进程调度的时候，快表会invalid或者fflush，或者增加一个进程的标志，以防止命中错误</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>由于成本关系，快表大小一般由64—1024个表项组成。</p>
<p>由于局部性原理，一般来说，快表的命中率可以达到80%~90%。</p>
<p><img data-src="https://s2.loli.net/2022/04/26/slGYgA7d1MCbyvL.png" alt="image-20220426191925850"></p>
<blockquote>
<p>&#x3D;&#x3D;有效内存访问时间：&#x3D;&#x3D;</p>
<img data-src="https://s2.loli.net/2022/04/26/heXDntpmFlMWKsj.png" alt="image-20220426212647995" style="zoom:67%;" />
</blockquote>
</blockquote>
<h4 id="（3）基本地址变换机构和具有快表的地址变换机构的对比"><a href="#（3）基本地址变换机构和具有快表的地址变换机构的对比" class="headerlink" title="（3）基本地址变换机构和具有快表的地址变换机构的对比"></a>（3）基本地址变换机构和具有快表的地址变换机构的对比</h4><p><img data-src="https://s2.loli.net/2022/04/26/jPJtQiqcYAU2IHD.png" alt="image-20220426192036001"></p>
<h3 id="5、两级页表"><a href="#5、两级页表" class="headerlink" title="5、两级页表"></a>5、两级页表</h3><ul>
<li><p><strong>单级页表中存在的问题：</strong></p>
<ul>
<li>页表必须连续存放，因此当页表很大时，需要占用多个连续的页框</li>
<li>没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面</li>
</ul>
</li>
<li><p>解决单级页表必须连续存放的问题：采用多级页表（&#x3D;&#x3D;页目录表，外层页表，顶层页表）&#x3D;&#x3D;</p>
</li>
<li><p><strong>两级页表的原理和地址结构</strong></p>
<p>  <img data-src="https://s2.loli.net/2022/04/26/2jpR47Q8aVzD1gE.png" alt="image-20220426192645889"></p>
<p>  <img data-src="https://s2.loli.net/2022/04/26/W4pJXv9qlIZ3VBw.png" alt="image-20220426192700866"></p>
</li>
<li><p><strong>如何实现地址变换</strong></p>
<p>  <img data-src="https://s2.loli.net/2022/04/26/edxUD4VpF2HsA8n.png" alt="image-20220426192838963"></p>
<blockquote>
<p>也可以引入快表，以减少访存次数</p>
</blockquote>
</li>
<li><p><strong>解决单级页表中不需要让整个页表常驻内存的问题：</strong></p>
  <img data-src="https://s2.loli.net/2022/04/26/p2avYgUiflN5FrV.png" alt="image-20220426193011056" style="zoom:80%;" />
</li>
<li><p>&#x3D;&#x3D;需要注意的几个细节&#x3D;&#x3D;</p>
<p>  <img data-src="https://s2.loli.net/2022/04/26/4xwt1QhX8ZTLqID.png" alt="image-20220426193150942"></p>
<blockquote>
<p>如果没有快表机构，则n级页表需要n+1次访存</p>
</blockquote>
</li>
</ul>
<h3 id="6、反向页表（Invert-Page-Table，-IPT）"><a href="#6、反向页表（Invert-Page-Table，-IPT）" class="headerlink" title="6、反向页表（Invert Page Table， IPT）"></a>6、反向页表（Invert Page Table， IPT）</h3><ul>
<li><p><strong>思想</strong>：为内存中的每一个<strong>物理块</strong>建立一个页表项并按照块号排序，每个页表项包含正在访问该页框的进程标识、页号以及特征位</p>
<blockquote>
<p>整个系统只有一张表，每个物理内存的页只有一个条目对应</p>
</blockquote>
</li>
<li><p><strong>作用</strong>：完成主存页框到访问进程的页号即物理地址到逻辑地址的转换</p>
</li>
<li><p><strong>地址变换过程：</strong></p>
  <img data-src="https://s2.loli.net/2022/04/26/WQYzlCV81HUub2y.png" alt="image-20220426205421650" style="zoom:67%;" />
</li>
<li><p><strong>缺点：</strong></p>
  <img data-src="https://s2.loli.net/2022/04/26/I1FVZMurYnXgqDW.png" alt="image-20220426205905801" style="zoom:67%;" /></li>
</ul>
<h3 id="7、分页存储管理的保护与共享"><a href="#7、分页存储管理的保护与共享" class="headerlink" title="7、分页存储管理的保护与共享"></a>7、分页存储管理的保护与共享</h3><ul>
<li><strong>分页存储管理采用两种方式保护内存：</strong><ul>
<li>地址越界保护：页表长度与逻辑地址中的页号比较</li>
<li>存取控制保护：在页表中增加保护位</li>
</ul>
</li>
<li><strong>分页存储管理的共享方式</strong><ul>
<li>数据共享：允许不同进程对共享的数据页用不同的页号来访问，即只需要页表指向共享的数据页框即可。</li>
<li>代码共享：由于共享代码页面内包含地址，不同逻辑空间若页号不同，则导致无法访问，因此必须赋予相同页号。</li>
</ul>
</li>
</ul>
<h2 id="6-5-基本分段存储管理"><a href="#6-5-基本分段存储管理" class="headerlink" title="6.5 基本分段存储管理"></a>6.5 基本分段存储管理</h2><p><img data-src="https://s2.loli.net/2022/04/26/EUgOtpouZxdRrj7.png" alt="image-20220426194710516"></p>
<blockquote>
<p>与基本分页存储管理的最大区别：离散分配时所分配地址空间的基本单位不同</p>
</blockquote>
<h3 id="1、分段的概念"><a href="#1、分段的概念" class="headerlink" title="1、分段的概念"></a>1、分段的概念</h3><p><img data-src="https://s2.loli.net/2022/04/26/6S8VgteFOHUaKGT.png" alt="image-20220426193521781"></p>
<p><img data-src="https://s2.loli.net/2022/04/26/KaqjebsJzuM8HyA.png" alt="image-20220426193535550"></p>
<h3 id="2、段表"><a href="#2、段表" class="headerlink" title="2、段表"></a>2、段表</h3><p><img data-src="https://s2.loli.net/2022/04/26/upbHoCI6h7faYeZ.png" alt="image-20220426193632599"></p>
<blockquote>
<p>段表一般存放在内存</p>
</blockquote>
<h3 id="3、地址变换机构"><a href="#3、地址变换机构" class="headerlink" title="3、地址变换机构"></a>3、地址变换机构</h3><p><img data-src="https://s2.loli.net/2022/04/26/l9q2p3DKLEj6GrM.png" alt="image-20220426193928129"></p>
<blockquote>
<p>为了提高内存的访问速度，也可以使用快表</p>
</blockquote>
<h3 id="4、分段、分页管理的对比"><a href="#4、分段、分页管理的对比" class="headerlink" title="4、分段、分页管理的对比"></a>4、分段、分页管理的对比</h3><p><img data-src="https://s2.loli.net/2022/04/26/bs3XU8gmfHcN1Dt.png" alt="image-20220426194236685"></p>
<img data-src="https://s2.loli.net/2022/04/26/ywH4ZpnUKe9xPtS.png" alt="image-20220426195041398" style="zoom:67%;" />

<p><img data-src="https://s2.loli.net/2022/04/26/YRG4QD5itvZVHAN.png" alt="image-20220426194640929"></p>
<p><img data-src="https://s2.loli.net/2022/04/26/klur4s6xOcE871I.png" alt="image-20220426194106414"></p>
<h3 id="5、分段保护"><a href="#5、分段保护" class="headerlink" title="5、分段保护"></a>5、分段保护</h3><ul>
<li><strong>地址越界保护：</strong>段号与段表长度的比较，段内位移与段长的比较</li>
<li><strong>存取控制保护：</strong>设置存取权限，访问段时判断访问类型与存取权限是否相符</li>
</ul>
<h2 id="6-6-段页式存储管理"><a href="#6-6-段页式存储管理" class="headerlink" title="6.6 段页式存储管理"></a>6.6 段页式存储管理</h2><p><img data-src="https://s2.loli.net/2022/04/26/Ja58EfCTXBvVmho.png" alt="image-20220426200531616"></p>
<h3 id="1、分页、分段的优缺点分析"><a href="#1、分页、分段的优缺点分析" class="headerlink" title="1、分页、分段的优缺点分析"></a>1、分页、分段的优缺点分析</h3><p><img data-src="https://s2.loli.net/2022/04/26/AoFm2UpIqyGW54c.png" alt="image-20220426195201025"></p>
<h3 id="2、段页式存储管理：先分段后分页"><a href="#2、段页式存储管理：先分段后分页" class="headerlink" title="2、段页式存储管理：先分段后分页"></a>2、段页式存储管理：先分段后分页</h3><blockquote>
<p>分段对用户可见，分页对用户不可见</p>
</blockquote>
<p><img data-src="https://s2.loli.net/2022/04/26/JrxjkvDLqe67gi9.png" alt="image-20220426195338399"></p>
<h3 id="3、段页式管理的逻辑地址结构"><a href="#3、段页式管理的逻辑地址结构" class="headerlink" title="3、段页式管理的逻辑地址结构"></a>3、段页式管理的逻辑地址结构</h3><p><img data-src="https://s2.loli.net/2022/04/26/nBUGbur8LSdHolX.png" alt="image-20220426195806199"></p>
<h3 id="4、段表和页表"><a href="#4、段表和页表" class="headerlink" title="4、段表和页表"></a>4、段表和页表</h3><p><img data-src="https://s2.loli.net/2022/04/26/YVDGOsEfQBhtPnl.png" alt="image-20220426200023173"></p>
<blockquote>
<p>一个进程对应一个段表，一个段又对应一个页表，因此一个进程可以对应多个页表</p>
</blockquote>
<h3 id="5、地址变换机构"><a href="#5、地址变换机构" class="headerlink" title="5、地址变换机构"></a>5、地址变换机构</h3><p><img data-src="https://s2.loli.net/2022/04/26/yCvbqgiJHwY7N4e.png" alt="image-20220426200419461"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>四、进程同步</title>
    <url>/2022/06/27/%E5%9B%9B%E3%80%81%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理复习笔记</title>
    <url>/2022/06/27/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%89%8D%E4%B8%89%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h1><h2 id="x3D-x3D-1、编译和解释-x3D-x3D"><a href="#x3D-x3D-1、编译和解释-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;1、编译和解释&#x3D;&#x3D;"></a>&#x3D;&#x3D;1、编译和解释&#x3D;&#x3D;</h2><ul>
<li>&#x3D;&#x3D;编译方式的特点：&#x3D;&#x3D; <ul>
<li>源程序的执行需要分阶段（目标程序是机器语言：编译、运行，目标程序是汇编语言：编译、汇编、运行）；  </li>
<li>生成了目标代码，且可多次执行</li>
<li><em>编译程序与具体的机器和语言有关</em></li>
</ul>
</li>
<li>&#x3D;&#x3D;解释方式的特点：&#x3D;&#x3D;<ul>
<li>更灵活、交互方便，节省空间</li>
<li>效率低</li>
</ul>
</li>
<li>&#x3D;&#x3D;根本区别：&#x3D;&#x3D; 在解释方式下，并不生成目标代码，而是直接执行源程序本身。</li>
<li>&#x3D;&#x3D;相同点：&#x3D;&#x3D; 都需要进行词法、语法、语义分析</li>
</ul>
<p><img data-src="https://s2.loli.net/2022/03/04/hSwesXfVIFjC4KA.jpg"></p>
<h2 id="2、编译程序的工作过程（词法分析、语法分析等）"><a href="#2、编译程序的工作过程（词法分析、语法分析等）" class="headerlink" title="2、编译程序的工作过程（词法分析、语法分析等）"></a>2、编译程序的工作过程（词法分析、语法分析等）</h2><ul>
<li><p><img data-src="https://s2.loli.net/2022/03/04/xtsWrXz9lhBRA8Y.png"></p>
</li>
<li><p>&#x3D;&#x3D;词法分析&#x3D;&#x3D; （或扫描）</p>
<ul>
<li>词法分析器读入组成源程序的字符流，并将它们组织成有意义的词素的序列。对于每个词素，产生<strong>词法单元</strong> 作为输出</li>
<li>*词法单元：&lt;token-name, attribute-value&gt;*，前者为抽象符号，后者为条目。eg.(id, 1)。分隔词素的空格会被词法分析器忽略掉。词法单元的名字常被称为终结符号，属性值是一个指向符号表的指针，符号表中包含了该词法单元的附加信息。</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;语法分析&#x3D;&#x3D; （或解析）</p>
<ul>
<li>语法分析器使用由词法分析器生成的各个词法单元的第一个分量来创建语法树（内部节点：运算，子节点：该运算的分量）</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;语义分析&#x3D;&#x3D; </p>
<ul>
<li>使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致（<strong>静态语义检查</strong> ，包括类型和运算合法性检查等）</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;中间代码生成&#x3D;&#x3D; </p>
<ul>
<li>中间表示形式应该易生成，易翻译</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;代码优化&#x3D;&#x3D;</p>
<ul>
<li>机器无关的代码优化步骤试图<strong>改进中间代码</strong> ，以便生成更好的目标代码</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;代码生成&#x3D;&#x3D;</p>
<ul>
<li>以源程序的中间表示形式作为输入，并把它映射到目标语言</li>
<li>目标指令可能是绝对指令代码，或可重新定位的指令代码或汇编指令代码</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;符号表的管理：&#x3D;&#x3D; 符号表存放了整个源程序的信息，变量名及其属性。在各个阶段填入、查找</p>
</li>
<li><p>&#x3D;&#x3D;出错处理：&#x3D;&#x3D; </p>
<ul>
<li>语法错误：在词法分析或语法分析时检测出来</li>
<li>语义错误：在语义分析或运行时检测出来（因为语义分析是静态语义检查）</li>
</ul>
</li>
<li><p>在一个特定的实现中，多个步骤可以组合成一趟</p>
</li>
<li><p>错误检查程序及表格管理程序贯穿始终</p>
</li>
<li><p>词法分析、语法分析、语义分析与中间代码生成及部分代码优化工作为前端部分，&#x3D;&#x3D;与目标机有关&#x3D;&#x3D;的代码优化和目标代码生成等为后端部分</p>
</li>
<li><p>示例：</p>
<p>  <img data-src="https://s2.loli.net/2022/03/04/CrcNty2m9qxSUEw.png"></p>
</li>
</ul>
<h2 id="3、编译程序的结构"><a href="#3、编译程序的结构" class="headerlink" title="3、编译程序的结构"></a>3、编译程序的结构</h2><p><img data-src="https://s2.loli.net/2022/04/07/Jxk1GIf8CK2mUir.png" alt="image-20220407152024793"></p>
<h2 id="4、编译程序的组织方式及编译器的两个部分"><a href="#4、编译程序的组织方式及编译器的两个部分" class="headerlink" title="4、编译程序的组织方式及编译器的两个部分"></a>4、编译程序的组织方式及编译器的两个部分</h2><ul>
<li><p><strong>遍&#x2F;趟：</strong>一个编译程序在编译时刻把源程序或源程序的等价物（中间程序）从头到尾扫描一遍并转换成另一紧邻的等价物的全过程</p>
</li>
<li><p><strong>单遍扫描：</strong>效率高但占用空间大，目标程序质量低</p>
</li>
<li><p><strong>多遍扫描：</strong>效率低但占用空间小，目标程序质量高，便于多人合作开发</p>
</li>
<li><p><strong>分析部分（编译器的前端）</strong>：主要由<strong>与源语言有关但与目标机器无关</strong> 的那些部分组成，词法分析、语法分析、语义分析、中间代码生成和部分代码优化工作</p>
<p>  <img data-src="https://s2.loli.net/2022/03/11/ZEPthWCzVc9xrnw.png" alt="image-20220311113450229"></p>
</li>
<li><p><strong>综合部分（编译器的后端）</strong>：主要包括编译中<strong>与目标机器有关</strong> 的那些部分，如与目标机有关的代码优化和目标代码生成等。可以通过改变编译程序的后端来实现编译程序的移植。</p>
</li>
</ul>
<h2 id="5、编译程序的构造"><a href="#5、编译程序的构造" class="headerlink" title="5、编译程序的构造"></a>5、编译程序的构造</h2><ul>
<li><p>构造编译程序可以用机器语言、汇编语言和高级语言</p>
</li>
<li><p>高级语言的&#x3D;&#x3D;自编译性&#x3D;&#x3D; ：一个语言可以用来编写自己的编译程序</p>
<p>  <img data-src="https://s2.loli.net/2022/03/04/LTgXiu1rkyNEzRY.png"></p>
</li>
<li><p><strong>T型图</strong></p>
<p>  <img data-src="https://s2.loli.net/2022/05/15/yE3hexcragFKLtS.png" alt="image-20220515221623573"></p>
</li>
<li><p><strong>自展</strong></p>
<p>  <img data-src="https://s2.loli.net/2022/03/04/9RCBFkyrawcOHZg.png"></p>
</li>
<li><p><strong>编译的移植</strong></p>
<p>  将一个机器（宿主机）上的一个具有自编译性的高级语言编译程序移植到另一个机器（目标机）上</p>
<p>  <img data-src="https://s2.loli.net/2022/03/04/gmYOAdLE9kyGCfD.png"></p>
<p>  <img data-src="https://s2.loli.net/2022/03/04/9MPFq1QcTsGdDtb.png"></p>
</li>
</ul>
<h1 id="第二章-形式语言概论"><a href="#第二章-形式语言概论" class="headerlink" title="第二章 形式语言概论"></a>第二章 形式语言概论</h1><h2 id="1、字母表与符号串"><a href="#1、字母表与符号串" class="headerlink" title="1、字母表与符号串"></a>1、字母表与符号串</h2><h3 id="字母表："><a href="#字母表：" class="headerlink" title="字母表："></a>字母表：</h3><p>符号(symbol)的非空有穷集，记为∑。</p>
<p>eg.Σ&#x3D;{a，b，……，y，z}，Σ&#x3D;{0， 1}，Σ&#x3D;{BEGIN， END}</p>
<h3 id="符号串：-string"><a href="#符号串：-string" class="headerlink" title="符号串： string"></a>符号串： string</h3><p>字母表中的符号所组成的任何有穷序列，通常用小写的字母表示。&#x3D;&#x3D;空串记为ε&#x3D;&#x3D; 。</p>
<ul>
<li><p>符号串相等要看顺序。eg.ab ≠ ba</p>
</li>
<li><p>符号串长度为符号串中符号的个数。 </p>
<p>  |ε|&#x3D;0，|BEGINEND| &#x3D; 2</p>
</li>
<li><p>符号串的子串（subsequence）:必须是连续的，如abc的子串不能是ac</p>
</li>
<li><p>&#x3D;&#x3D;空串是任何一个符号串的子串、前缀和后缀&#x3D;&#x3D; 。</p>
</li>
<li><p>符号串的连接：拼接，&#x3D;&#x3D;ε是连接运算的单位元&#x3D;&#x3D; ，εx &#x3D; xε &#x3D; x</p>
</li>
<li><p>符号串的方幂(x^n^)：符号串与其自身的连接。x^0^  &#x3D; ε，x^1^ &#x3D; x，x^2^ &#x3D; xx。</p>
</li>
<li><p>符号串的逆（x^-1^ ）：符号串的倒置。 ε^-1^ &#x3D; ε，(x^-1^)^-1^ &#x3D; x，x &#x3D; αβ，x^-1^ &#x3D; β^-1^α^-1^ 。</p>
<p>  eg.x &#x3D; abcd, x^-1^ &#x3D; dcba &#x3D; (cd)^-1^ (ab)^-1^ </p>
</li>
<li><p>符号串集合的和与积：</p>
<ul>
<li><p>A+B（或A∪B） &#x3D;{w | w∈A，或 w ∈ B}</p>
</li>
<li><p>A•B（或 AB）&#x3D; { xy |x ∈ A, y ∈ B}</p>
<p>  &#x3D;&#x3D;{ε}是符号串集合乘积运算的零元&#x3D;&#x3D; ，{ε}A &#x3D; A{ε} &#x3D; A</p>
</li>
</ul>
</li>
<li><p>符号串集合的方幂：A^0^  &#x3D; {ε} ，A^1^ &#x3D; A，A^2^ &#x3D; AA</p>
<p>  eg. A &#x3D; {ab,cd}  A^0^ &#x3D; {ε}，A^1^ &#x3D; {ab, cd} , A^2^ &#x3D; {abab, abcd, cdab, cdcd}</p>
</li>
<li><p>符号串集合的闭包和正闭包：</p>
<ul>
<li>闭包 <img data-src="https://s2.loli.net/2022/03/04/V6R7w9UzrQtChun.png"></li>
<li>正闭包<img data-src="https://s2.loli.net/2022/03/04/9S5VGjzHpRnquJt.png"></li>
<li>闭包比正闭包多了一个ε</li>
</ul>
</li>
</ul>
<h3 id="语法描述："><a href="#语法描述：" class="headerlink" title="语法描述："></a>语法描述：</h3><p>可以采用自然语言、语法图、BNF范式、EBNF</p>
<p>eg.标识符的语法描述：</p>
<p>BNF范式（Backus-Naur Form） ：&lt;标识符&gt; ::&#x3D; &lt;字母&gt;|&lt;标识符&gt;&lt;字母&gt;|&lt;标识符&gt;&lt;数字&gt; </p>
<p>扩充的BNF（EBNF：Extended BNF） ：&lt;标识符&gt; ::&#x3D; &lt;字母&gt; {&lt;字母&gt;|&lt;数字&gt;}</p>
<h2 id="2、文法及其分类（主要考2型和3型文法）"><a href="#2、文法及其分类（主要考2型和3型文法）" class="headerlink" title="2、文法及其分类（主要考2型和3型文法）"></a>2、文法及其分类（主要考2型和3型文法）</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>文法G是一个四元组，G[S]&#x3D;（V<del>N</del>，V<del>T</del>，P，S）</p>
<p>V<del>N</del> ：非终结符号集</p>
<p>V<del>T</del>： 终结符号集。V<del>T</del> ∩V<del>N</del> &#x3D; ∅， V &#x3D; V<del>T</del> U V<del>N</del></p>
<p>P ：产生式(production)的有穷非空的集合，是文法的核心</p>
<p>S：开始符号</p>
<h3 id="符号表示的约定："><a href="#符号表示的约定：" class="headerlink" title="符号表示的约定："></a><strong>符号表示的约定：</strong></h3><ul>
<li>终结符号：排在前面的小写字母abc、运算符号、标点符号、数字0~9、黑体字符串，如<strong>id</strong></li>
<li>非终结符号：排在前面的大写字母ABC、字母S（常用来表示开始符号）、小写且斜体的名字，如<em>expr</em></li>
<li>在字母表中排在后面的大写字母如XYZ表示终结符号或者非终结符号</li>
<li>在字母表中排在后面的小写字母如uvwxyz表示终结符号串（可能为ε）</li>
<li>小写的希腊字母，表示文法符号串（可能为ε）</li>
</ul>
<h3 id="文法的分类"><a href="#文法的分类" class="headerlink" title="文法的分类"></a>文法的分类</h3><ul>
<li><p>区别：对产生式规则的形式上施加不同的限制。<strong>从PSG到CSG到CFG到RG，限制逐渐增强，能力逐渐减弱</strong>，生成的语言集逐渐减小，形式越简单，构造的自动机越易实现 。</p>
</li>
<li><p>&#x3D;&#x3D;下半区的左边都是单个的非终结符号&#x3D;&#x3D; </p>
<p>  &#x3D;&#x3D;上半区：不减为1型&#x3D;&#x3D; </p>
<p>  <img data-src="https://s2.loli.net/2022/03/04/FEHy5VxOUkXIvSa.png" alt="image.png"></p>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>0型文法 L<del>0</del> （短语结构文法(phrase structure grammar, PSG)）</strong></th>
<th>α→β ，α∈V^+^  ，β∈V^<em>^             <br />亦即α→β ，α∈V</em> V<del>N</del> V*<br />（必须要有一个非终结符号） ，β∈V *</th>
<th>对应递归可枚举语言类，与图灵机（TM）能力相当，能力最强。</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1型文法 L<del>1</del> (上下文相关文法(context sensitive grammar,CSG)，长度增长文法)</strong></td>
<td>α→β ，&#x3D;&#x3D;1≤ |α|≤|β|&#x3D;&#x3D; （ 长度不减），α∈V^+^，β∈V^+^ <br />亦即α∈V* V<del>N</del> V*（必须要有一个非终结符号） ，β∈V^+^</td>
<td>对应递归语言类，界限自动机<strong>LBA</strong>。静态语义处理。</td>
</tr>
<tr>
<td><strong>2型文法L<del>2</del> ( 上下文无关文法(context free grammar,CFG))</strong></td>
<td>A→β ，A∈V<del>N</del> （&#x3D;&#x3D;A是单个非终结符号&#x3D;&#x3D; ，长度为1），β∈V^+^ 。 扩充的2型文法：A→β ，A∈V<del>N</del>，β∈V*</td>
<td>对应上下文无关语言类，用于定义程序设计语言的<strong>语法规则</strong>。下推自动机<strong>PDA</strong>（&#x3D;&#x3D;栈&#x3D;&#x3D;）。</td>
</tr>
<tr>
<td><strong>3型文法L<del>3</del> ( 正则文法(regular grammar ,RG)、正规文法)</strong></td>
<td>A→a 或 A→aB , A,B∈V<del>N</del> ，a∈V<del>T</del> （右线性文法的一种情况）。<br />&#x3D;&#x3D;左线性文法：&#x3D;&#x3D; A→a或A→Ba  , A,B∈V<del>N</del> ，a∈V<del>T</del> ^<em>^ ； <br />&#x3D;&#x3D;右线性文法：&#x3D;&#x3D; A→a 或 A→aB , A,B∈V<del>N</del> ，**a∈V<del>T</del> ^</em>^** 。这3种共同构成3型文法</td>
<td>对应正规语言类，用于描述程序设计语言的<strong>词法规则</strong>。对应于<strong>FSA</strong>（有限状态自动机）。&#x3D;&#x3D;3型没有记忆功能&#x3D;&#x3D; ，要记也是记它自己，例如A-&gt;aA</td>
</tr>
</tbody></table>
<blockquote>
<p>在写正规文法时，可以从左往右考虑，一个非终结符号表示一个字符，然后把下一个字符交给下一个非终结符号表示</p>
</blockquote>
<blockquote>
<p>如果要有记忆功能，可以用栈作为记忆装置（&#x3D;&#x3D;下推自动机&#x3D;&#x3D;）。如识别aaabbb，匹配一个b就弹出一个a，如果最终栈底的终结符号不能和符号串末尾的终结符号匹配的话，则报错。</p>
</blockquote>
<blockquote>
<p>正规文法不能出现$\varepsilon$</p>
</blockquote>
<p><strong>例子：</strong></p>
<p><img data-src="https://s2.loli.net/2022/03/10/wOAmUG4D3QTrhcZ.png" alt="image-20220310224157836"></p>
<p><img data-src="https://s2.loli.net/2022/03/10/1JOq2LHtpFAhao5.png" alt="image-20220310224629051"></p>
<hr>
<p>&#x3D;&#x3D;文法的记忆功能：&#x3D;&#x3D; 精简版的括号配对问题。记住左右两边有几个配对的括号。<strong>3型文法没有记忆功能</strong>，因为它的非终结符号只能在一侧，无法记忆左右两边的一对。<strong>2型文法可以记忆两个</strong>，即左右两边的一对，如S→aSb，故2型文法可以用来表示a^n^b^n^ 。但2型文法的左边是单个的非终结符号，故不能记忆超过两个。<strong>1型文法可以记忆三个</strong>，故1型文法可以用来表示a^n^b^n^c^n^。</p>
<p><img data-src="https://s2.loli.net/2022/03/10/Jo9TInwgZizP7e1.png" alt="image-20220310224733082"></p>
<p>例子：所有由0和1组成并且每个0之后都至少跟着一个1的串的集合</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">S -&gt; LS | <span class="type">ε</span></span><br><span class="line"><span class="type">L</span> -&gt; <span class="number">01</span> | <span class="type">1</span></span><br></pre></td></tr></table></figure>

<p>所有由0和1组成的具有相同多个0和1的串的集合</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">S</span> -&gt; <span class="number">0</span>S1S | <span class="number">1</span>S0S | ε</span><br></pre></td></tr></table></figure>

<h2 id="3、文法和语言"><a href="#3、文法和语言" class="headerlink" title="3、文法和语言"></a>3、文法和语言</h2><h3 id="文法经过推导得到语言"><a href="#文法经过推导得到语言" class="headerlink" title="文法经过推导得到语言"></a>文法经过推导得到语言</h3><p><strong>推导：</strong></p>
<p><img data-src="https://s2.loli.net/2022/05/19/X8oUYwJbPTEC9AN.png" alt="image-20220519160515000"></p>
<p>每一棵语法分析树都和唯一的最左推导、唯一的最右推导相关联</p>
<p><strong>归约：</strong></p>
<ul>
<li>最右归约：最左推导的逆过程称为最右归约</li>
<li>最左归约：最右推导（规范推导）的逆过程称为最左归约</li>
</ul>
<p><strong>句型：</strong>设有文法G[S]，如果 <img data-src="https://s2.loli.net/2022/03/04/UxMbG8l9iDrJEXs.png">，则称符号串u为文法G[S]的句型</p>
<p><strong>句子：</strong>设有文法G[S]，如果 <img data-src="https://s2.loli.net/2022/03/04/UxMbG8l9iDrJEXs.png">，且u∈V<del>T</del> * ，则称符号串u为文法G[S]的句子。</p>
<p>&#x3D;&#x3D;句子是一个终结符号串。&#x3D;&#x3D; </p>
<p><strong>语言：</strong>设有文法G[S]，则文法G[S]描述的语言为<img data-src="https://s2.loli.net/2022/03/04/TDboNIEAueO5l4q.png">(&#x3D;&#x3D;语言是合法句子的集合&#x3D;&#x3D; )</p>
<p>如果两个文法生成相同语言，则称这两个文法是等价的。</p>
<h3 id="语言经过凑规则得到文法"><a href="#语言经过凑规则得到文法" class="headerlink" title="语言经过凑规则得到文法"></a>语言经过凑规则得到文法</h3><p><strong>步骤：</strong>找出语言的若干典型句子→分析句子特点→根据句子特点凑规则→得到文法→检查文法</p>
<p>检查文法时应满足：①语言的所有句子都能由S推导得到;  ②S推导得到的所有终结符号串都是语言的句子.（不多不少）</p>
<p><strong>例子：</strong></p>
<p><img data-src="https://s2.loli.net/2022/05/19/vNcVBHm3sKZgDi8.png" alt="image-20220519161355512"></p>
<blockquote>
<p>给定一个文法，可以从结构上<strong>唯一</strong> 确定其语言；给定一个语言，可以确定相应的文法（<strong>不唯一</strong> ）。</p>
</blockquote>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul>
<li><p>规则递归（直接递归）：文法的产生式为U→xUy形式</p>
</li>
<li><p>规则左递归（直接左递归）：文法的产生式为U→Uy形式</p>
</li>
<li><p>规则右递归（直接右递归）：文法的产生式为U→xU形式</p>
</li>
<li><p>文法递归（间接递归）：文法中有推导<img data-src="https://s2.loli.net/2022/03/04/xBEeGqjbaPUFmcW.png"></p>
</li>
<li><p>文法左递归（间接左递归）：文法中有推导<img data-src="https://s2.loli.net/2022/03/04/SHPlQYW7qhtwUXa.png" alt="文法左递归.png"></p>
</li>
<li><p>文法右递归（间接右递归）：文法中有推导<img data-src="https://s2.loli.net/2022/03/10/RYGZlHrem34jb6d.png" alt="image-20220310164820052"></p>
</li>
</ul>
<h3 id="语法分析树"><a href="#语法分析树" class="headerlink" title="语法分析树"></a>语法分析树</h3><p>语法分析树展现了从文法的开始符号推导出相应语言中的符号串的过程。一棵语法分析树的叶子结点从左向右构成了一个终结符号串。</p>
<ul>
<li>根结点的标号（文法符号）为文法的开始符号</li>
<li>每个内部结点的标号为一个非终结符号</li>
<li>叶子结点的标号为一个终结符号或者ε</li>
<li>若一个标记为U的结点，它有标记依次为x<del>1</del>、x<del>2</del>、…、x<del>n</del>的直接后继结点，则U→x<del>1</del>x<del>2</del>…x<del>n</del>必定是文法G的一条产生式。</li>
</ul>
<h3 id="二义性问题"><a href="#二义性问题" class="headerlink" title="二义性问题"></a>二义性问题</h3><ul>
<li><p><strong>句子的二义性</strong>（&#x3D;&#x3D;必考&#x3D;&#x3D; ）：一个句子有两棵（或以上）不同的语法树；存在两个（或以上）不同的最左推导；存在两个（或以上）不同的最右推导（每一棵语法分析树都和唯一的最左推导、唯一的最右推导相关联）</p>
</li>
<li><p><strong>文法的二义性</strong>：文法G中的某一句子具有二义性</p>
</li>
<li><p><strong>语言的二义性</strong>：不存在任何无二义性的文法来描述某语言L。（也称为先天二义性）</p>
</li>
</ul>
<h3 id="运算符的结合性和优先级"><a href="#运算符的结合性和优先级" class="headerlink" title="运算符的结合性和优先级"></a>运算符的结合性和优先级</h3><p><strong>结合性</strong></p>
<ul>
<li><p>左结合性：当一个运算分量左右两侧都有同一个运算符时，它属于左边的运算符。如+-*&#x2F;</p>
</li>
<li><p>右结合性：一个运算分量左右两侧都有同一个运算符时，它属于右边的运算符。如&#x3D;</p>
<blockquote>
<p>左结合性的文法，语法分析树是向左下端延伸的；<br>右结合性的文法，语法分析树是向右下端延伸的</p>
</blockquote>
</li>
</ul>
<p><strong>优先级</strong></p>
<ul>
<li><p>n层优先级一般需要n+1个非终结符号，其中，最下面那个产生式左边的非终结符号的产生式体只能是单个运算分量或括号括起来的表达式。然后，对于每个优先级都有一个非终结符，表示能被该优先级或更高的优先级的运算符分开的表达式。</p>
</li>
<li><p>例子：算术表达式的文法</p>
<p>  <img data-src="https://s2.loli.net/2022/03/11/WrPyD8RK4UvhQ5J.png" alt="image-20220311184147910"></p>
</li>
</ul>
<h2 id="4、文法的实用限制"><a href="#4、文法的实用限制" class="headerlink" title="4、文法的实用限制"></a>4、文法的实用限制</h2><h3 id="消除文法的二义性（-x3D-x3D-重难点-x3D-x3D-）"><a href="#消除文法的二义性（-x3D-x3D-重难点-x3D-x3D-）" class="headerlink" title="消除文法的二义性（&#x3D;&#x3D;重难点&#x3D;&#x3D;）"></a>消除文法的二义性（&#x3D;&#x3D;重难点&#x3D;&#x3D;）</h3><p><strong>方法一：设定消除二义性规则：</strong>在语义上加些限制</p>
<p><strong>方法二：重写文法</strong>：重新构造一个等价的无二义性文法。</p>
<p>考虑运算符的优先级和结合性。</p>
<ul>
<li>采用优先级联的方式——最低级的运算最靠近语法树的根结点，从上往下，运算的优先级依次增加</li>
<li>左结合性：左递归，右结合性：右递归</li>
</ul>
<p><img data-src="https://s2.loli.net/2022/03/11/PiaWFlI5uXQVpEG.png" alt="image-20220311104535673"></p>
<p><img data-src="https://s2.loli.net/2022/03/11/ElRIWuefnUO83it.png" alt="image-20220311111404819"></p>
<h3 id="文法的压缩（化简）"><a href="#文法的压缩（化简）" class="headerlink" title="文法的压缩（化简）"></a>文法的压缩（化简）</h3><p>若文法G[S]的所有产生式都满足下列实用限制条件：</p>
<p>1、没有<strong>多余产生式</strong>（包括无法推导出终结符号串的产生式（不可终止）和从开始符号出发的所有推导都不会用到的产生式（不可达））。</p>
<p>2、没有<strong>有害产生式U→U</strong>（有该产生式的文法一定是二义性的）</p>
<p>则称文法G[S]是<strong>压缩或化简</strong>的。</p>
<p>例子：</p>
<img data-src="https://s2.loli.net/2022/03/11/QKhBbEqpDTuOmng.png" alt="image-20220311091509810" style="zoom:67%;" />



<h3 id="删除单规则（单产生式）：A→B"><a href="#删除单规则（单产生式）：A→B" class="headerlink" title="删除单规则（单产生式）：A→B"></a>删除单规则（单产生式）：A→B</h3><p>单产生式会使得语法树的深度加深，加大存储开销</p>
<img data-src="https://s2.loli.net/2022/03/11/SG89bKnl6wyrTqX.png" alt="image-20220311091824568" style="zoom: 67%;" />

<h3 id="删除空产生式（ε-规则）：-U→ε"><a href="#删除空产生式（ε-规则）：-U→ε" class="headerlink" title="删除空产生式（ε 规则）： U→ε"></a>删除空产生式（ε 规则）： U→ε</h3><p><strong>步骤：</strong></p>
<ul>
<li>找出可能推导出ε的非终结符号，本例中为B、D</li>
<li>将产生式体中可能为ε的非终结符号替换为ε并删除ε</li>
<li>特殊情形：S-&gt;ε的时候，不能去掉</li>
</ul>
<img data-src="https://s2.loli.net/2022/03/11/YdKyhqXgNU7THcv.png" alt="image-20220311091942023" style="zoom:67%;" />

 

<h3 id="消除直接左递归U→Uy"><a href="#消除直接左递归U→Uy" class="headerlink" title="消除直接左递归U→Uy"></a>消除直接左递归U→Uy</h3><p><strong>（期末考试一般考直接改写法）</strong></p>
<p>方法：</p>
<ul>
<li><p>&#x3D;&#x3D;采用EBNF表示&#x3D;&#x3D; </p>
<blockquote>
<p>[x]— x可以出现零次或一次</p>
<p>{x}——x可以出现零次到多次</p>
<p>x(y|z)——等价于xy 或 xz，用于提取公因子</p>
</blockquote>
<p>  步骤： <img data-src="https://s2.loli.net/2022/03/11/R2xWwSv16Zf8grb.png" alt="image-20220311093151304"></p>
<p>  即<img data-src="https://s2.loli.net/2022/04/07/cH1sfzCBe7LYE9O.png" alt="image-20220407163924252"></p>
</li>
<li><p>&#x3D;&#x3D;直接改写法：&#x3D;&#x3D; 引进新的非终结符号，将左递归改写为右递归</p>
<p>  <img data-src="https://s2.loli.net/2022/03/11/D75j3twy8Qgl1Kz.png" alt="image-20220311093533406"></p>
</li>
<li><p><img data-src="https://s2.loli.net/2022/03/11/CBjznZkLeY4Dru9.png"></p>
</li>
</ul>
<h3 id="消除间接左递归"><a href="#消除间接左递归" class="headerlink" title="消除间接左递归"></a>消除间接左递归<img data-src="https://s2.loli.net/2022/04/07/WKsIfw9HEaAeC1u.png" alt="image-20220407164315981" style="zoom: 67%;" /></h3><ul>
<li><p>方法：&#x3D;&#x3D;转换成直接左递归来消除&#x3D;&#x3D;</p>
<p>  <img data-src="https://s2.loli.net/2022/04/07/vWbnjNEoTaGDdRz.png" alt="image-20220407205525749"></p>
</li>
<li><p>例子：</p>
  <img data-src="https://s2.loli.net/2022/04/07/IcoNtZhf1Kx6UbF.png" alt="image-20220407231035529" style="zoom:67%;" />

  <img data-src="https://s2.loli.net/2022/04/07/QjGiIAygplPCMBD.png" alt="image-20220407231055235" style="zoom:67%;" /></li>
</ul>
<h1 id="第三章-有穷自动机-x3D-x3D-8个算法，确定化、最小化、RG和FA和RE之间的六个转换-x3D-x3D"><a href="#第三章-有穷自动机-x3D-x3D-8个算法，确定化、最小化、RG和FA和RE之间的六个转换-x3D-x3D" class="headerlink" title="第三章  有穷自动机(&#x3D;&#x3D;8个算法，确定化、最小化、RG和FA和RE之间的六个转换&#x3D;&#x3D;)"></a>第三章  有穷自动机(&#x3D;&#x3D;8个算法，确定化、最小化、RG和FA和RE之间的六个转换&#x3D;&#x3D;)</h1><blockquote>
<p>自动机的概念：自动机是一种能进行<strong>运算</strong>并实现<strong>自我控制</strong>(根据外界的信息改变自己的状态)的装置，计算机就是一部自动机。自动机是描述符号串处理的强有力的工具。<strong>功能：识别语言</strong></p>
</blockquote>
<h2 id="3-1-有穷自动机的形式定义"><a href="#3-1-有穷自动机的形式定义" class="headerlink" title="3.1 有穷自动机的形式定义"></a>3.1 有穷自动机的形式定义</h2><h3 id="1、有穷自动机的分类及组成"><a href="#1、有穷自动机的分类及组成" class="headerlink" title="1、有穷自动机的分类及组成"></a>1、有穷自动机的分类及组成</h3><ul>
<li><p>&#x3D;&#x3D;DFA:&#x3D;&#x3D;  Deterministic Finite (State) Automation，确定的有穷(状态)自动机。当前状态经一个输入到达<strong>下一个</strong>状态。</p>
</li>
<li><p>&#x3D;&#x3D;NDFA（or NFA）:&#x3D;&#x3D;  Non Deterministic Finite (State) Automation非确定的有穷自动机。当前状态经一个输入可到达<strong>多个</strong>状态。</p>
<blockquote>
<p>FA的等价性： L(A<del>1</del>) &#x3D; L(A<del>2</del>)，则称有穷自动机A<del>1</del>和A<del>2</del>是<strong>等价</strong>的（类比文法等价）</p>
</blockquote>
<blockquote>
<p>关系：<strong>DFA是NDFA的特例</strong>，对每个NDFA N一定存在一个DFA M，使得L(M)&#x3D;L(N)，但这种DFA M可能不唯一。</p>
<p>q表示状态，Q表示状态集</p>
<p><strong>用有穷自动机表示无穷：状态转换的回路（文法：递归）</strong></p>
<p><img data-src="https://s2.loli.net/2022/03/31/WaIvVMDhmdj1gJL.png" alt="image-20220331234125325"></p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th>DFA &#x3D; (Q，∑，t，&#x3D;&#x3D;q<del>0</del>&#x3D;&#x3D;，F)</th>
<th>DFA的扩充</th>
<th>NDFA &#x3D;  (Q，∑，t，&#x3D;&#x3D;Q<del>0</del>&#x3D;&#x3D;，F)</th>
<th>NDFA 的扩充</th>
</tr>
</thead>
<tbody><tr>
<td>Q：有穷非空的状态集</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Σ：有穷的输入字母表</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>t：<strong>单值映射Q×&#x3D;&#x3D;Σ&#x3D;&#x3D;→Q</strong> 。 t(q, x)&#x3D;q’。可以理解由当前状态和<strong>一个输入字符</strong>得到下一个状态</td>
<td>t：<em><em>单值映射Q×&#x3D;&#x3D;Σ</em>&#x3D;&#x3D;→Q</em>* 。 t(q, ε) &#x3D; q。t(q, aα) &#x3D; t ( t(q, a),  α)，其中q∈Q， a ∈Σ,  α∈Σ*。可以理解由当前状态和<strong>一个符号串</strong>得到下一个状态</td>
<td>t：<strong>多值映射Q×&#x3D;&#x3D;Σ&#x3D;&#x3D;→2^Q^</strong>。t(q,x)&#x3D;{q<del>1</del>,q<del>2</del>,…,q<del>n</del>} (状态的幂集)</td>
<td>t：<em><em>多值映射Q×&#x3D;&#x3D;Σ</em>&#x3D;&#x3D;→2^Q^</em>* 。 t(q, ε)&#x3D;q。t(q, aα) &#x3D; t(q<del>1</del>,α)∪t(q<del>2</del>,α)∪… ∪t(q<del>n</del>,α)，其中 a ∈Σ,  α∈Σ*, t(q, a) &#x3D; {q<del>1</del>, q<del>2</del>… q<del>n</del>}。</td>
</tr>
<tr>
<td><strong>q<del>0</del>：∈Q，是开始状态</strong></td>
<td></td>
<td><strong>Q<del>0</del>：⊆Q，是开始状态集</strong>。即使只有一个开始状态，也要用{}</td>
<td></td>
</tr>
<tr>
<td>F：⊆Q，非空终止状态集合</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>DFA的扩充，使得DFA可以描述对符号串的识别。**如果t(q<del>0</del>, α) ∈ F，则α可被DFA接受(或识别)*<em>，即从开始状态经α可到达某一个终止状态。被DFA A识别的符号串集合，记为L(A)，L(A) &#x3D; {α∈Σ</em> | t(q<del>0</del>, α)  ∈ F}，即这台自动机所能识别和接受的语言。α是L(A)的句子 。</td>
<td></td>
<td>NDFA的扩充，使得NDFA可以描述对符号串的识别。**如果q ∈ t(q<del>0</del>, α) , q<del>0</del>∈ Q<del>0</del> ，q∈ F，则α可被DFA接受(或识别)*<em>，即从某一个开始状态经α可到达某一个终止状态。被NDFA A识别的符号串集合，记为L(A)，L(A) &#x3D; {α∈Σ</em> | t(q<del>0</del>, α)  ∩ F ≠ ∅ ,q<del>0</del>∈Q<del>0</del> }</td>
</tr>
</tbody></table>
<h3 id="2、有穷自动机的表示："><a href="#2、有穷自动机的表示：" class="headerlink" title="2、有穷自动机的表示："></a>2、有穷自动机的表示：</h3><ul>
<li><p>状态转换表</p>
</li>
<li><p>状态转换图（<strong>更常用</strong>）</p>
<blockquote>
<p>非空终止状态用同心圆表示</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;DFA:&#x3D;&#x3D; </p>
  <img data-src="https://s2.loli.net/2022/03/17/dbpaewYO5WZ4yc9.png" alt="image-20220317150650779" style="zoom:67%;" />
</li>
<li><p>&#x3D;&#x3D;NDFA&#x3D;&#x3D;</p>
  <img data-src="https://s2.loli.net/2022/03/17/ZgFyLjveGRzAbwU.png" alt="image-20220317154458730"  /></li>
</ul>
<h2 id="3-2-NDFA到DFA的转换（-x3D-x3D-必考-x3D-x3D-）"><a href="#3-2-NDFA到DFA的转换（-x3D-x3D-必考-x3D-x3D-）" class="headerlink" title="3.2 NDFA到DFA的转换（&#x3D;&#x3D;必考&#x3D;&#x3D;）"></a>3.2 NDFA到DFA的转换（&#x3D;&#x3D;必考&#x3D;&#x3D;）</h2><blockquote>
<p>DFA是NDFA的特例，对每个NDFA N一定存在一个DFA M，使得L(M)&#x3D;L(N)，但这种DFA M可能不唯一</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">	a[NDFA]--&gt;|确定化|b[DFA];</span><br><span class="line">	b[DFA]--&gt; |化简|c[最小化的DFA];</span><br><span class="line">	c[最小化的DFA] --&gt; d[词法分析程序];</span><br></pre></td></tr></table></figure>



<h3 id="1、确定化-NDFA-gt-DFA（-x3D-x3D-注意造表法是可以直接用的，不需要消-x3D-x3D-varepsilon-）"><a href="#1、确定化-NDFA-gt-DFA（-x3D-x3D-注意造表法是可以直接用的，不需要消-x3D-x3D-varepsilon-）" class="headerlink" title="1、确定化:   NDFA -&gt; DFA（&#x3D;&#x3D;注意造表法是可以直接用的，不需要消&#x3D;&#x3D;$\varepsilon$）"></a>1、确定化:   NDFA -&gt; DFA（&#x3D;&#x3D;注意造表法是可以直接用的，不需要消&#x3D;&#x3D;$\varepsilon$）</h3><p>子集法 &#x2F; 造表法（&#x3D;&#x3D;考造表法&#x3D;&#x3D;）</p>
<ul>
<li><p>&#x3D;&#x3D;子集法。&#x3D;&#x3D; </p>
<p>  <strong>步骤：</strong></p>
<ul>
<li><p>&#x3D;&#x3D;空移环路的寻找和消除&#x3D;&#x3D;：消除从状态A开始并以A结束的空移动序列(空移环路上的所有状态都是等价的)，把它们合并成一个结点并取公共名。<strong>注意Q<del>0</del>和F</strong>。<strong>注意a弧、b弧等等会变成自环</strong></p>
<blockquote>
<p>ε自动机：自动机的弧上允许标记ε，称此FA为ε自动机，记为εFA（εNDFA或εDFA）。εNDFA &#x3D; (Q，∑ ∪{ε}，t，Q<del>0</del>，F)</p>
<p>消除ε自动机中的空移：对于εFA ，总可以构造等价的FA，使得L (εFA) &#x3D; L(FA)</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;消除余下的空移&#x3D;&#x3D;： εNDFA -&gt; NDFA。<strong>去ε弧、添等价弧(包括ε弧)、置特殊状态（终态必须置，初态可以不置）</strong></p>
</li>
</ul>
<p>  <img data-src="https://s2.loli.net/2022/03/17/6ADyZeGocNvkCr7.png" alt="image-20220317165134820"></p>
<ul>
<li><p>&#x3D;&#x3D;利用子集法确定化&#x3D;&#x3D;   NDFA  -&gt; DFA</p>
<p>  思想：把从状态到状态的多值映射转化为状态集到状态集的单值映射</p>
<p>  <img data-src="https://s2.loli.net/2022/03/17/mr486kDGcZIheNl.png" alt="image-20220317170543983"></p>
</li>
</ul>
<blockquote>
<p>子集法的正确性的证明：α∈L(A)当且仅当α∈L(A’)</p>
<p>DFA:从开始状态（是一个状态类）到某一个终止状态子集，NFA：从某一个开始状态到某一个终止状态，这两个映射是可以转换的</p>
</blockquote>
<p>  <strong>局限性：</strong>状态数太多（2^Q^ - 1个状态，存储和查找的开销大）、存在不可达状态（挂起）</p>
<p>  <strong>例子：</strong></p>
<p>  <img data-src="https://s2.loli.net/2022/03/24/dEcwUWZuGxOsYDF.png" alt="image-20220324214849272"></p>
<hr>
</li>
<li><p>&#x3D;&#x3D;造表法（考）&#x3D;&#x3D;(造表法本质还是子集法，子集法和造表法统称为子集法  )</p>
<ul>
<li><p><strong>思想</strong>：为避免不可达状态，从初始状态出发，计算t′，依次构造其后继状态，进行确定化。</p>
<blockquote>
<p>一些概念：</p>
<ul>
<li><strong>I<del>a</del><strong>：I<del>a</del> &#x3D; t’(I, a)，即从I中的状态出发经过一条a弧（可跳过a弧</strong>前后</strong>的任意条ε弧）到达的状态集合</li>
<li><strong>状态子集I的ε闭包（ ε-CLOSURE(I) ）</strong>：包含了I中的状态和它们经过任意条ε弧能到达的Q中的状态</li>
<li><strong>I<del>a</del>子集</strong>：即从I中的状态出发，经过一条a弧（可跳过a弧<strong>前</strong>的任意条ε弧）到达的状态集合，称为<strong>J</strong>。I<del>a</del> &#x3D; ε-CLOSURE(J)</li>
</ul>
</blockquote>
</li>
<li><p><strong>步骤：</strong></p>
<p>  <img data-src="https://s2.loli.net/2022/03/17/voLRXMOuwQh8KlJ.png" alt="image-20220317182540359"></p>
</li>
<li><p><strong>特点</strong>：简单有效、不存在不可达状态、状态数比子集法大大减少</p>
</li>
<li><p>例子：</p>
  <img data-src="https://s2.loli.net/2022/03/24/NXDbZx2z1VdTJLK.png" alt="image-20220324215954121" style="zoom:67%;" />

  <img data-src="https://s2.loli.net/2022/03/24/B9zabF2JuGSEV13.png" alt="image-20220324215944493" style="zoom: 50%;" /></li>
</ul>
</li>
</ul>
<h3 id="2、最小化：DFA-gt-MFA"><a href="#2、最小化：DFA-gt-MFA" class="headerlink" title="2、最小化：DFA -&gt; MFA"></a>2、最小化：DFA -&gt; MFA</h3><ul>
<li><p>目标：寻找等价的、状态数更少的DFA M’（M’是唯一的）</p>
</li>
<li><p><strong>思想：合并等价状态、删除无关状态</strong></p>
<blockquote>
<p><code>等价状态：</code>从两个状态出发可以识别同一个字符串(任意一个)到达终态，则称这两个状态是等价的，否则称它们是可区分的。即$$\forall\alpha\epsilon\Sigma^*, t(q, \alpha)\epsilon F当且仅当t(q’, \alpha)\epsilon F$$</p>
</blockquote>
</li>
<li><p>最小化算法（划分法）：把状态集划分成若干个互不相交的等价状态集</p>
<p>  步骤：</p>
<ul>
<li><p>构造状态集的划分，&#x3D;&#x3D;从终止状态集和非终止状态集里再细分&#x3D;&#x3D;（因此最终至少有两个状态）</p>
</li>
<li><p>取每组中的一个状态作代表，合并等价状态。</p>
<blockquote>
<p>例如，A和B是等价状态，则如果选A为代表而删除B，则应<strong>将射入B的弧补到A上</strong>，<strong>不需要补射出B的弧</strong>，因为由等价状态的定义可知，A和B的射出的弧到达的下一个状态是相同的</p>
</blockquote>
</li>
<li><p>删去无关状态，包括不可达状态和死状态等</p>
<p>  <img data-src="https://s2.loli.net/2022/03/17/owSlZ7rmcPRtM2A.png" alt="image-20220317220019401"></p>
</li>
</ul>
</li>
<li><p>例子：</p>
<p>  <img data-src="https://s2.loli.net/2022/03/24/9kuErAlD1L76efa.png" alt="image-20220324221541448"></p>
</li>
</ul>
<p><img data-src="https://s2.loli.net/2022/03/24/RDnC9dptK1QNkXu.png" alt="image-20220324221835671"></p>
<h3 id="3、从化简后的DFA到程序表示-MFA-gt-scanner"><a href="#3、从化简后的DFA到程序表示-MFA-gt-scanner" class="headerlink" title="3、从化简后的DFA到程序表示 MFA -&gt; scanner"></a>3、从化简后的DFA到程序表示 MFA -&gt; scanner</h3><p><img data-src="https://s2.loli.net/2022/03/24/QnbFtWksm9KjPAc.png" alt="image-20220324222006003"></p>
<h2 id="3-3-正规文法-RG-与FA"><a href="#3-3-正规文法-RG-与FA" class="headerlink" title="3.3 正规文法(RG)与FA"></a>3.3 正规文法(RG)与FA</h2><h3 id="1、RG与FA"><a href="#1、RG与FA" class="headerlink" title="1、RG与FA"></a>1、RG与FA</h3><ul>
<li>RG是语言的生成规则</li>
<li>FA识别（接受）语言</li>
</ul>
<h3 id="2、RG-gt-FA："><a href="#2、RG-gt-FA：" class="headerlink" title="2、RG -&gt; FA："></a>2、RG -&gt; FA：</h3><p>由正规文法G[S]可直接构造一个与之等价的FA A，使得L(G)&#x3D;L(A)。</p>
<p><strong>步骤：</strong></p>
<ul>
<li><p>令G的终结符号集V<del>T</del>为A的字母表∑； </p>
</li>
<li><p>G的非终结符号作为A的状态，G的开始符号为A的开始状态； </p>
</li>
<li><p>&#x3D;&#x3D;增加一个终止状态Z（Z ∉ V<del>N</del>）；&#x3D;&#x3D;</p>
</li>
<li><p>形如U→a的规则，引一条从状态U到终止状态Z的标记为a的弧； </p>
</li>
<li><p>形如U→aW的规则，引一条从状态U到W的a弧</p>
<p>  对应关系如下：</p>
<table>
<thead>
<tr>
<th>G[S]&#x3D;（V<del>N</del>，V<del>T</del>，P，S）</th>
<th>NFA &#x3D; (Q，∑，t，{q<del>0</del>}，F) (初态唯一,因为要和S对应)</th>
</tr>
</thead>
<tbody><tr>
<td>V<del>N</del></td>
<td>Q</td>
</tr>
<tr>
<td>V<del>T</del></td>
<td>∑</td>
</tr>
<tr>
<td>P</td>
<td>t，形如U→a的规则，引一条从状态U到终止状态Z的标记为a的弧；     形如U→aW的规则，引一条从状态U到W的a弧（特别地，如果有形如U→aU的规则，引一条从状态U到状态U的自环）</td>
</tr>
<tr>
<td>S</td>
<td>q<del>0</del></td>
</tr>
<tr>
<td></td>
<td><strong>F(新增加的，∉ V<del>N</del>)</strong></td>
</tr>
</tbody></table>
</li>
</ul>
<p>&#x3D;&#x3D;eg.&#x3D;&#x3D;</p>
<p><img data-src="https://s2.loli.net/2022/03/31/joSRI4KyDEards1.png" alt="image-20220331230128319"></p>
<p><img data-src="https://s2.loli.net/2022/03/31/7YVoTF6COnZKIJR.png" alt="image-20220331231013992"></p>
<h3 id="3、FA-gt-RG"><a href="#3、FA-gt-RG" class="headerlink" title="3、FA -&gt; RG"></a>3、FA -&gt; RG</h3><p>由有穷自动机FA A可直接构造一个与之等价的正规文法G，使得L(G)&#x3D;L(A)</p>
<p><strong>步骤：</strong></p>
<ul>
<li><p>自动机A中的每一个状态均作为G的非终结符号，其中A的开始状态作为G的开始符号，A的输入字母表∑中的所有符号作为G的终结符号；</p>
</li>
<li><p>对A中V ∈ t(U,a)的映射，构造G的产生式U∷&#x3D;aV；若V∈F，则构造G的产生式 U::&#x3D;a；</p>
</li>
<li><p>若A中q<del>0</del>∈F，则构造G的产生式S∷&#x3D;ε</p>
<p>  对应关系如下：</p>
<table>
<thead>
<tr>
<th>DFA &#x3D; (Q，∑，t，q<del>0</del>，F)</th>
<th>G[S]&#x3D;（V<del>N</del>，V<del>T</del>，P，S）</th>
</tr>
</thead>
<tbody><tr>
<td>Q</td>
<td>V<del>N</del></td>
</tr>
<tr>
<td>∑</td>
<td>V<del>T</del></td>
</tr>
<tr>
<td>t</td>
<td>P，对A中V ∈ t(U,a)的映射，构造G的产生式U∷&#x3D;aV；<br />若V∈F，则构造G的产生式 U::&#x3D;a；<br />若A中q<del>0</del>∈F，则构造G的产生式S∷&#x3D;ε</td>
</tr>
<tr>
<td>q<del>0</del></td>
<td>S</td>
</tr>
<tr>
<td>F</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<p>&#x3D;&#x3D;eg.&#x3D;&#x3D;</p>
<p><img data-src="https://s2.loli.net/2022/03/31/bZth9rlPiADF12E.png" alt="image-20220331231121040"></p>
<p><img data-src="https://s2.loli.net/2022/03/31/Tqyr9uzPmBH3pFL.png" alt="image-20220331231701572"></p>
<h2 id="3-4-正规表达式-x2F-正则表达式-RE-与FA"><a href="#3-4-正规表达式-x2F-正则表达式-RE-与FA" class="headerlink" title="3.4 正规表达式&#x2F;正则表达式(RE)与FA"></a>3.4 正规表达式&#x2F;正则表达式(RE)与FA</h2><h3 id="1、RE（可以直观地描述出语言的特征）"><a href="#1、RE（可以直观地描述出语言的特征）" class="headerlink" title="1、RE（可以直观地描述出语言的特征）"></a>1、RE（可以直观地描述出语言的特征）</h3><ul>
<li><p>&#x3D;&#x3D;概念：&#x3D;&#x3D; </p>
<p>  三种运算：或运算 a|b 、连接运算 ab、闭包运算 a^<em>^(正闭包a^+^)。*<em>（优先级由低到高）</em></em></p>
<p>  &#x3D;&#x3D;注意在RE中，0个或无穷多个不是用{}来表示，而是用*来表示，大括号是集合&#x3D;&#x3D;</p>
</li>
</ul>
<p><img data-src="https://s2.loli.net/2022/03/31/5pFHox1ryEjbhTw.png" alt="image-20220331231923652"></p>
<p><strong>eg.</strong></p>
<p><img data-src="https://s2.loli.net/2022/03/31/YozVNxEDCfHuWy2.png" alt="image-20220331232616611"></p>
<img data-src="https://s2.loli.net/2022/03/31/1dEyrHmjPx54nhX.png" alt="image-20220331233246560" style="zoom:50%;" />

<ul>
<li><p>&#x3D;&#x3D;RE等价：&#x3D;&#x3D; 设e<del>1</del>，e<del>2</del>均为∑上的正规表达式，若 L(e<del>1</del>)&#x3D;L(e<del>2</del>)，则称e<del>1</del>与e<del>2</del>等价，记为：e<del>1</del>&#x3D; e<del>2</del></p>
<p>  <img data-src="https://s2.loli.net/2022/03/31/P3IEHFbZvWhRwYr.png" alt="image-20220331233053138"></p>
<p>  <img data-src="https://s2.loli.net/2022/03/31/QWnVp9zkxHY2MoZ.png" alt="image-20220331233112495"></p>
</li>
<li><p>&#x3D;&#x3D;RE的性质：&#x3D;&#x3D; </p>
<p>  <img data-src="https://s2.loli.net/2022/03/31/Xjo15J2dBLHhYC3.png" alt="image-20220331232826488"></p>
</li>
</ul>
<h3 id="2、RE-–-gt-FA"><a href="#2、RE-–-gt-FA" class="headerlink" title="2、RE –&gt; FA"></a>2、RE –&gt; FA</h3><p>对于字母表Σ上的任意正规表达式e，一定可以构造一个输入字母表Σ上的<strong>NDFA A</strong>，使得L(A)&#x3D;L(e)</p>
<p><strong>步骤：</strong></p>
<ul>
<li><p>构造广义NFA：<strong>S是惟一开始状态，Z是惟一终止状态</strong>。弧标记e。</p>
</li>
<li><p>根据分解规则分解e ，得到与e对应的NFA。</p>
<p>  分解规则如下：</p>
<p>  <img data-src="https://s2.loli.net/2022/03/17/uoEaYrUIJ8gFxbj.png" alt="image-20220317230004987"></p>
</li>
</ul>
<p>&#x3D;&#x3D;eg&#x3D;&#x3D;</p>
<p><img data-src="https://s2.loli.net/2022/03/31/p6tFHduCrOm1oL5.png" alt="image-20220331233904038"><img data-src="https://s2.loli.net/2022/03/31/Q7WpazfkA3UgZwi.png" alt="image-20220331233938288" style="zoom:67%;" /></p>
<h3 id="3、FA-gt-RE"><a href="#3、FA-gt-RE" class="headerlink" title="3、FA -&gt; RE"></a>3、FA -&gt; RE</h3><ul>
<li><p>由有穷自动机FA A所识别的语言L(A)，可以用Σ上 的RE e来表示，使得L(A)&#x3D;L(e)</p>
<p>  <strong>步骤</strong></p>
</li>
<li><p>（&#x3D;&#x3D;当初态和终态不唯一时&#x3D;&#x3D;）在FA A的状态图中增加两个结点：<strong>S是惟一开始状态</strong>，从S向原开始状态连ε弧；<strong>Z是惟一终止状态</strong>，从原终止状态向Z连ε弧。</p>
</li>
<li><p>利用下列替换规则逐步消去状态图中的结点和弧，直至仅剩下S到Z的一条弧为止，则该弧上的标记即为RE e。</p>
<p>  <img data-src="https://s2.loli.net/2022/03/17/tVZi5aIBq1HJ6P9.png" alt="image-20220317230404452"></p>
</li>
</ul>
<p>&#x3D;&#x3D;eg&#x3D;&#x3D;</p>
<img data-src="https://s2.loli.net/2022/03/31/YdrHoz6ZUMKlbIk.png" alt="image-20220331234216167" style="zoom:67%;" />

<img data-src="https://s2.loli.net/2022/03/31/rsiz7VASouyqd6H.png" alt="image-20220331234837905" style="zoom:50%;" />

<h2 id="3-5-RE与RG"><a href="#3-5-RE与RG" class="headerlink" title="3.5 RE与RG"></a>3.5 RE与RG</h2><h3 id="1、RG-gt-RE"><a href="#1、RG-gt-RE" class="headerlink" title="1、RG -&gt; RE"></a>1、RG -&gt; RE</h3><p>对任何一个正规文法G，都存在一个等价的正规表达式e，使得L(e)&#x3D;L(G)</p>
<blockquote>
<p>正规文法的拓广：产生式的形式为 U→αV 或 U→α， α为可空字符串，即<strong>右线性文法，</strong>容易改写成RG。</p>
</blockquote>
<p><strong>由右线性文法到正规表达式的转换规则：</strong></p>
<ul>
<li>形如U→αV, V→β的产生式转换成正规表达式U &#x3D; αβ；</li>
<li>&#x3D;&#x3D;形如U→αU|β的产生式转换成U &#x3D; α*β；&#x3D;&#x3D;</li>
<li>形如U→α|β的产生式转换成U &#x3D; α|β。</li>
<li>反复使用上述三条规则，直到文法只剩下一条关于文法开始符号的产生式，且该条产生式的右部不含非终结符号。这个产生式的右部就是正规表达式。</li>
</ul>
<p><strong>例子：</strong></p>
<img data-src="https://s2.loli.net/2022/04/07/mjVd8KzNpU5EICS.png" alt="image-20220407223903410" style="zoom:67%;" />

<img data-src="https://s2.loli.net/2022/04/07/ef5n4uIJqNZTc6P.png" alt="image-20220407224157566" style="zoom: 50%;" />

<h3 id="2、RE-gt-RG"><a href="#2、RE-gt-RG" class="headerlink" title="2、RE -&gt; RG"></a>2、RE -&gt; RG</h3><p>直接转换较困难，可通过FA来间接转换</p>
<p><strong>规则：</strong></p>
<ul>
<li><p>令RG为G[S] ，对RE e，形成产生式S→e ；</p>
</li>
<li><p>利用下列替换规则，重写产生式，直至符合RG形式要求： </p>
<ul>
<li><p>A→xy       替换成   A→xB ， B→y (新增B ∈ V<del>N</del>) </p>
</li>
<li><p>A→x*y     替换成   A→xA | y</p>
</li>
<li><p>A→x | y   替换成   A→x ， A→y</p>
<p>  即得所求之RG G[S]。</p>
</li>
</ul>
</li>
</ul>
<p><strong>例子：</strong></p>
<p><img data-src="https://s2.loli.net/2022/04/07/YJ6rljcPZOHA5kz.png" alt="image-20220407225050765"></p>
<img data-src="https://s2.loli.net/2022/04/07/TzrkhKHd2lDIoiV.png" alt="image-20220407225042766" style="zoom:50%;" />

<h2 id="3-6-RG、FA、RE三者关系"><a href="#3-6-RG、FA、RE三者关系" class="headerlink" title="3.6 RG、FA、RE三者关系"></a>3.6 RG、FA、RE三者关系</h2><img data-src="https://s2.loli.net/2022/03/31/evJchpxWLl6E8fb.png" alt="image-20220331201340852" style="zoom:50%;" />

<p><img data-src="https://s2.loli.net/2022/03/31/TEmsJP1gAUjzN7n.png" alt="image-20220331234446610"> </p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
</search>
