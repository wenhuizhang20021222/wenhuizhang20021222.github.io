---
title: 六、主存储器管理
tags:
  - 操作系统
category:
  - 操作系统
abbrlink: 53712
date: 2022-06-27 23:08:05
---

# 第六章  主存储器管理

![image-20220426184538793](https://s2.loli.net/2022/04/26/9zCRymrJVXKgWdp.png)

## 6.1 存储器管理的基本概念

![image-20220422195823004](https://s2.loli.net/2022/04/22/9uJisnzPHkCyhqf.png)

### 1、基本概念

- 存储器的层次结构：

    <img src="https://s2.loli.net/2022/04/18/kBPG8J9SEaDzYq5.png" alt="image-20220418230644829" style="zoom:67%;" />

- ==内存的概念与作用==：内存是用于存放数据的硬件。程序执行时需要先放到内存中才能被CPU处理。

- ==存储单元和地址==：每个地址对应一个存储单元

    ![image-20220422194032845](https://s2.loli.net/2022/04/22/RTVxmjzKpG9QhCs.png)

    > 按字节编址的意思是一个字节对应一个地址，而一个地址又对应一个存储单元，故一个存储单元是一个字节。
    >
    > 1K = 2^10^; 1M = 2^20^;1G = 2^30^B

- 主存储器分为两大部分：

    - 系统区：存放操作系统内核程序与数据结构，供操作系统使用
    - 用户区：存放应用程序与数据，往往被划分为一个或多个区域，供用户进程使用。

- 存储器管理的主要目标：为用户提供方便、安全和充分大的存储器，支持大型应用和系统程序及数据的使用。

- ==主存储器管理的四个功能==

    - 存储空间的分配和回收
    - （存储器的）抽象与（地址）映射
    - 隔离与共享：进程对存储空间的独占式使用以及共享访问
    - 存储扩充：在逻辑上为用户提供一个比实际物理内存更大的存储空间

    ![image-20220422201759192](https://s2.loli.net/2022/04/22/wZlaXGmOqE3Rgnr.png)

- ==逻辑地址：==用户编程时所使用的地址。又称相对地址、虚地址。

    > 相对地址是指相对于进程在内存中的起始位置

- 地址空间：逻辑地址的集合。

- ==物理地址：==内存中的地址。又称绝对地址、实地址。

- 主存空间：物理地址的集合。

- 地址变换：将逻辑地址转换为物理地址。又称地址映射、重定位。

### 2、程序的装入（三种方式）

> 为将一个用户源程序变为一个在内存中可执行的文件，通常要经历以下步骤：编译、链接、装入。 
>
> ![image-20220422194535038](https://s2.loli.net/2022/04/22/kSb8GL1XeHc4yZA.png)

==装入的三种方式：==（用三种不同的方法完成从逻辑地址到物理地址的转换）绝对装入、静态重定位、动态重定位

![image-20220422201910868](https://s2.loli.net/2022/04/22/21KBG8SnQRJa3qA.png)

---



![image-20220422194810619](https://s2.loli.net/2022/04/22/BJuhFYnTjV1ftZq.png)

特点：

- 知道程序驻留在内存中的确定位置，编译之后代码中包含了程序的物理地址。
- 装入模块之后，程序的逻辑地址与物理地址是完全相同的，不需要对程序和数据进行修改。
- 只能将目标代码装入到内存中事先指定的位置，不适应多道程序环境的动态特性。
- 通常在程序中采用符号地址，通过编译器，将符号地址转换为绝对地址

---



![image-20220422194854316](https://s2.loli.net/2022/04/22/xucXk1thRyiBHmq.png)

特点：

- 物理地址 = 程序起始地址 + 逻辑地址
- 地址变换通常是在装入时一次完成的，以后不再改变，故称为静态重定位
- 不需硬件支持，且要求分配连续存储空间，但程序运行时不能在内存移动，难以实现数据与代码的共享

---



![image-20220422194951839](https://s2.loli.net/2022/04/22/wc1LaQNlAHX7Yev.png)

> 多道程序中，重定位寄存器的内容存储在进程PCB中。当进程被调入时，重定位寄存器被重新设置，原有进程的重定位寄存器的内容随进程上下文切换而得到保护

### 3、程序的链接：（三种方式）

![image-20220422195515438](https://s2.loli.net/2022/04/22/MYpJXOCoErfDwQU.png)

![image-20220422195557231](https://s2.loli.net/2022/04/22/E1V3ZHSMBhIiuUn.png)

> 在装入目标模块时，如果发生一个外部模块调用，就会引起装入程序去寻找相应的外部目标模块，并将其装入内存，同时还要修改目标模块中的相对地址

----

![image-20220422195610600](https://s2.loli.net/2022/04/22/mdWYMIwtRxn7y8r.png)

### 4、内存保护

概念：防止一个进程破坏操作系统或其他进程

方法

- **界限存储器法：**通过对每个进程设置一对界限寄存器来防止越界访问，达到存储保护的目的。两种实现方式：上下界寄存器、基址限长寄存器

- **存储保护键：**通过保护键匹配来判断存储访问方式是否合法。为每个存储块分配一个保护键，相当于一把锁；进入系统的每个作业赋予一个保护键，相当于一把钥匙。当作业运行时，检查钥匙和锁是否匹配，若二者匹配，则允许访问。否则发出保护性中断信号

- **环保护机制**：处理器状态分为多个环，分别具有不同的存储访问特权级，通常环的编号越小，特权级越高。

    <img src="https://s2.loli.net/2022/04/22/uzQVWwOtlcnBYG1.png" alt="image-20220422200314969" style="zoom:67%;" />

- **访问权限**：只读、只能执行…



## 6.2 连续分配管理方式

> 连续分配：指为用户进程分配的必须是一个连续的内存空间

![image-20220422212711179](https://s2.loli.net/2022/04/22/8cJ1SPaBdwxyoNH.png)

### 1、单一连续分配

![image-20220422212019478](https://s2.loli.net/2022/04/22/Uk51jlfVH7PoCwc.png)

### 2、固定分区分配

![image-20220422212047775](https://s2.loli.net/2022/04/22/q6tSomYnjTP2Mb7.png)

![image-20220422212113844](https://s2.loli.net/2022/04/22/IDFb1U9ugJECczh.png)

### 3、动态分区分配及内外部碎片

![image-20220422212138065](https://s2.loli.net/2022/04/22/w18xeFYEnylipuZ.png)

![image-20220422212158090](https://s2.loli.net/2022/04/22/v5Sokj4dAZJFr6I.png)

![image-20220422212228592](https://s2.loli.net/2022/04/22/Ybwf3uDgi2MUls4.png)

> 动态重定位装入方式，需要修改进程的起始地址，即重定位寄存器

### 4、动态分区分配算法

![image-20220422215829014](https://s2.loli.net/2022/04/22/RHy9NQuJXAzM7oP.png)

> 首次适应和邻近适应一般都不需要对空闲分区队列重新排序，因为虽然空闲分区的大小变小了，但它在内存中的位置并没有发生变化，即在分区队列中的位置一般不会发生改变。
>
> 首次适应算法的缺点：低地址端有许多小空闲分区时会增加查找开销。
>
> 首次适应和最佳适应在执行时间和利用空间方面都好于最坏适应。
>
> 首次适应和最佳适应在利用空间方面能力相当，但首次适应更快

**扩展：可重定位分区分配技术**

<img src="https://s2.loli.net/2022/04/22/IBYsaClkRcHoE9u.png" alt="image-20220422221246833" style="zoom:67%;" />

### 5、伙伴系统（Knuth， 1973）

- **算法思想：**伙伴系统采用伙伴算法对空闲内存进行管理。该方法通过不断以1/2的形式来分割大的空闲存储块，从而获得小的空闲存储块。当内存块释放时，应尽可能合并空闲块

- **如何实现：**

    - **内存分配：**设系统初始时可供分配的空间为2^m^个单元。当进程申请大小为n的空间时，设2^i-1^<n≤2^i^，则为进程分配大小为2^i^的空间。如系统不存在大小为2^i^的空闲块，则查找系统中是否存在大于2^i^的空闲块2^i+1^, 2^i+2^…，若找到则对其进行对半划分，直到产生大小为2^i^的空闲块为止。

    - **内存回收：**当进程释放存储空间时，应检查释放块的伙伴是否空闲，若空闲则合并。如果这个较大的空闲块也存在空闲伙伴，此时也应合并。重复上述过程，直至没有可以合并的伙伴为止。

        > 伙伴：当一个块被分成两个大小相等的块时，这两个块称为伙伴

- **伙伴地址公式：**

    <img src="https://s2.loli.net/2022/04/22/L7U5PkTdwH3OYEI.png" alt="image-20220422222038028" style="zoom:67%;" />

- **例子：**

    <img src="https://s2.loli.net/2022/04/22/3slKQh9UVF61GNY.png" alt="image-20220422222207775" style="zoom:67%;" />

    <img src="https://s2.loli.net/2022/04/22/6rAveaZuP2FtsGl.png" alt="image-20220422222218692" style="zoom:67%;" />

- 伙伴系统可以用**二叉树**来表示

    <img src="https://s2.loli.net/2022/04/22/5WgtNnbmEVT7U2q.png" alt="image-20220422222353326" style="zoom:50%;" />

- **伙伴系统的优缺点：**

    - 适合于小数据量的内存管理（大数据量的内存管理采用段页式的分配管理）
    - 分配和回收时需要对伙伴进行拆分和合并；存储空间有浪费

## 6.3 内存空间的扩充----覆盖与交换技术

![image-20220422204051322](https://s2.loli.net/2022/04/22/Birx7bMAGERwJ9t.png)

### 1、覆盖技术：

![image-20220422203902006](https://s2.loli.net/2022/04/22/Alw9ZgyxRfj8Kem.png)

![image-20220422203914236](https://s2.loli.net/2022/04/22/1fzUj6pA2xSyuPr.png)

> 可以理解为A先调用B再调用C。覆盖区的大小由覆盖段中最大的覆盖决定。

### 2、交换技术

![image-20220422203956311](https://s2.loli.net/2022/04/22/5zmfZlBMkPJbXIC.png)

![image-20220422204018912](https://s2.loli.net/2022/04/22/o6CZmg17Vk9DtqN.png)



![image-20220422204034668](https://s2.loli.net/2022/04/22/3mWqcjL49PvEoMu.png)

### 3、覆盖技术与交换技术的区别

- 由谁完成：交换技术由操作系统完成；而覆盖技术由程序员给出作业各部分之间的覆盖结构，并清楚系统的存储结构
- 交换技术主要在不同作业之间进行，而覆盖技术是在同一个作业之间进行
- 覆盖技术主要用于早期操作系统，而交换技术在现代操作系统中仍然在使用



---

## 非连续分配管理方式

## 6.4 基本分页存储管理

![image-20220426185513138](https://s2.loli.net/2022/04/26/shWHLjUf6P3EOMn.png)

- **思想：**把内存分成一个个相等的内存块，再按照页面大小把进程拆分成一个个小部分

    > 👉==页式管理中地址是一维的==，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位

### 1、分页存储管理的基本概念与实现思想

![image-20220426184900709](https://s2.loli.net/2022/04/26/6jOa9wRxq5kZpeE.png)

> 页框：page frame

### 2、分页的逻辑地址结构

![image-20220426185131448](https://s2.loli.net/2022/04/26/fgxcYj4lD6J5t7Z.png)

> 为了方便计算页号和页内偏移量，页面大小通常为2的整数幂，一般在512B到64KB之间



### 3、页表机制及其相关技术

#### （1）页表

![image-20220426185341689](https://s2.loli.net/2022/04/26/1Ue85KMBbnET3ug.png)

> 页号是隐含在索引中的。且进程页表通常是装在连续的内存块中的。
>
> 为了方便页表的查询，常常会让一个页表项占更多的字节，使得每个页面恰好可以装得下整数个页表项（如页面大小为4KB，内存块号需要20位，但页表项的大小为4B，这样一个页框就可以存放1K个页表项）。多余的空间可以用来存放别的东西。
>
> 不同的页号可能对应相同的块号，以实现内存共享。
>
> 页表一般存放在内存中，也可以在页表中设置存取控制字段，以实现存储保护。

---



#### （2）存储分块表

- **作用**：记录内存中各物理块的使用情况及未分配物理块总数

- **表示方法：**位示图或者空闲存储块链

    - **位示图：**利用二进制的一位表示一个物理块的状态，1表示已分配，0表示未分配。所有物理块状态位的集合构成位示图。

        ![image-20220426202759287](https://s2.loli.net/2022/04/26/DmTfiFCbVOxh7Wc.png)

        > 位示图占用的存储空间为：物理块数/8（字节）

    - **空闲存储块链：**将所有的空闲存储块用链表链接起来，利用空闲物理块中的单元存放指向下一个物理块的指针。

#### （3）存储空间的分配和回收：

- **页面分配**：计算进程所需页面数，然后在请求表中登记进程号、请求页面数等。如存储分块表中有足够的空闲块可供进程使用，则在系统中取得页表始址，并在页表中登记页号及其对应的物理块号，否则无法分配。

- **页面回收**：将存储分块表中相应的物理块改为未分配，或将回收块加入到空闲存储块链中，并释放页表，修改请求表中的页表始址及状态。

    ​    

### 4、地址变换机构

#### （1）基本地址变换机构

![image-20220426191039460](https://s2.loli.net/2022/04/26/LI2TRfFBOoytP73.png)

- **概念：**用于实现逻辑地址到物理地址转换的一组硬件机构

- **作用：**借助进程的页表将逻辑地址转换为物理地址，也就是将逻辑地址中的页号转换为内存中的物理块号

- 通常会在系统中设置一个==页表寄存器PTR==，存放页表在内存中的起始地址F和页表长度M。进程未执行时，==页表的始址和页表长度==（也就是页表有多少项）放在进程控制块PCB中，当进程被调度时，os内核会把它们放到页表寄存器中。

- **地址变换过程：**

    ![image-20220426190157556](https://s2.loli.net/2022/04/26/ceUhD6AbCLjO2xR.png)

- ![image-20220426190052298](https://s2.loli.net/2022/04/26/gA7iu4MrpZRTPFf.png)

    ​    

- **例子：**

    ![image-20220426190431148](https://s2.loli.net/2022/04/26/cbvfMPXd7yW89Qs.png)

#### （2）具有快表的地址变换机构

- **局部性原理：**

    ![image-20220426191351742](https://s2.loli.net/2022/04/26/VUxWraSvYoB4Jhg.png)

- **快表（TLB， translation look-aside buffer，联想寄存器）**：一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为**慢表**。

- **引入快表后，地址的变换过程：**

    ![image-20220426191704882](https://s2.loli.net/2022/04/26/S8IdibhkaMsR4BW.png)

    ![image-20220426191721463](https://s2.loli.net/2022/04/26/8cIa4M9qDkFpbNm.png)

    ---

    > 当发生进程调度的时候，快表会invalid或者fflush，或者增加一个进程的标志，以防止命中错误

> 由于成本关系，快表大小一般由64—1024个表项组成。
>
> 由于局部性原理，一般来说，快表的命中率可以达到80%~90%。
>
> ![image-20220426191925850](https://s2.loli.net/2022/04/26/slGYgA7d1MCbyvL.png)
>
> > ==有效内存访问时间：==
> >
> > <img src="https://s2.loli.net/2022/04/26/heXDntpmFlMWKsj.png" alt="image-20220426212647995" style="zoom:67%;" />

#### （3）基本地址变换机构和具有快表的地址变换机构的对比

![image-20220426192036001](https://s2.loli.net/2022/04/26/jPJtQiqcYAU2IHD.png)

### 5、两级页表

- **单级页表中存在的问题：**

    - 页表必须连续存放，因此当页表很大时，需要占用多个连续的页框
    - 没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面

- 解决单级页表必须连续存放的问题：采用多级页表（==页目录表，外层页表，顶层页表）==

- **两级页表的原理和地址结构**

    ![image-20220426192645889](https://s2.loli.net/2022/04/26/2jpR47Q8aVzD1gE.png)

    ![image-20220426192700866](https://s2.loli.net/2022/04/26/W4pJXv9qlIZ3VBw.png)

- **如何实现地址变换**

    ![image-20220426192838963](https://s2.loli.net/2022/04/26/edxUD4VpF2HsA8n.png)

    > 也可以引入快表，以减少访存次数

- **解决单级页表中不需要让整个页表常驻内存的问题：**

    <img src="https://s2.loli.net/2022/04/26/p2avYgUiflN5FrV.png" alt="image-20220426193011056" style="zoom:80%;" />

- ==需要注意的几个细节==

    ![image-20220426193150942](https://s2.loli.net/2022/04/26/4xwt1QhX8ZTLqID.png)

    > 如果没有快表机构，则n级页表需要n+1次访存



### 6、反向页表（Invert Page Table， IPT）

- **思想**：为内存中的每一个**物理块**建立一个页表项并按照块号排序，每个页表项包含正在访问该页框的进程标识、页号以及特征位

    > 整个系统只有一张表，每个物理内存的页只有一个条目对应

- **作用**：完成主存页框到访问进程的页号即物理地址到逻辑地址的转换

- **地址变换过程：**

    <img src="https://s2.loli.net/2022/04/26/WQYzlCV81HUub2y.png" alt="image-20220426205421650" style="zoom:67%;" />

- **缺点：**

    <img src="https://s2.loli.net/2022/04/26/I1FVZMurYnXgqDW.png" alt="image-20220426205905801" style="zoom:67%;" />



### 7、分页存储管理的保护与共享

- **分页存储管理采用两种方式保护内存：**
    - 地址越界保护：页表长度与逻辑地址中的页号比较
    - 存取控制保护：在页表中增加保护位
- **分页存储管理的共享方式**
    - 数据共享：允许不同进程对共享的数据页用不同的页号来访问，即只需要页表指向共享的数据页框即可。
    - 代码共享：由于共享代码页面内包含地址，不同逻辑空间若页号不同，则导致无法访问，因此必须赋予相同页号。

## 6.5 基本分段存储管理

![image-20220426194710516](https://s2.loli.net/2022/04/26/EUgOtpouZxdRrj7.png)

> 与基本分页存储管理的最大区别：离散分配时所分配地址空间的基本单位不同

### 1、分段的概念

![image-20220426193521781](https://s2.loli.net/2022/04/26/6S8VgteFOHUaKGT.png)

![image-20220426193535550](https://s2.loli.net/2022/04/26/KaqjebsJzuM8HyA.png)

### 2、段表

![image-20220426193632599](https://s2.loli.net/2022/04/26/upbHoCI6h7faYeZ.png)

> 段表一般存放在内存

### 3、地址变换机构

![image-20220426193928129](https://s2.loli.net/2022/04/26/l9q2p3DKLEj6GrM.png)

> 为了提高内存的访问速度，也可以使用快表

### 4、分段、分页管理的对比

![image-20220426194236685](https://s2.loli.net/2022/04/26/bs3XU8gmfHcN1Dt.png)

<img src="https://s2.loli.net/2022/04/26/ywH4ZpnUKe9xPtS.png" alt="image-20220426195041398" style="zoom:67%;" />

![image-20220426194640929](https://s2.loli.net/2022/04/26/YRG4QD5itvZVHAN.png)

![image-20220426194106414](https://s2.loli.net/2022/04/26/klur4s6xOcE871I.png)

### 5、分段保护

- **地址越界保护：**段号与段表长度的比较，段内位移与段长的比较
- **存取控制保护：**设置存取权限，访问段时判断访问类型与存取权限是否相符



## 6.6 段页式存储管理

![image-20220426200531616](https://s2.loli.net/2022/04/26/Ja58EfCTXBvVmho.png)

### 1、分页、分段的优缺点分析

![image-20220426195201025](https://s2.loli.net/2022/04/26/AoFm2UpIqyGW54c.png)

### 2、段页式存储管理：先分段后分页

> 分段对用户可见，分页对用户不可见

![image-20220426195338399](https://s2.loli.net/2022/04/26/JrxjkvDLqe67gi9.png)

### 3、段页式管理的逻辑地址结构

![image-20220426195806199](https://s2.loli.net/2022/04/26/nBUGbur8LSdHolX.png)

### 4、段表和页表

![image-20220426200023173](https://s2.loli.net/2022/04/26/YVDGOsEfQBhtPnl.png)

> 一个进程对应一个段表，一个段又对应一个页表，因此一个进程可以对应多个页表

### 5、地址变换机构

![image-20220426200419461](https://s2.loli.net/2022/04/26/yCvbqgiJHwY7N4e.png)



