---
title: 并发控制
tags:
  - 数据库
category:
  - 数据库
abbrlink: 62852
date: 2022-06-27 22:56:56
---

# 七、并发控制

# UNIT 16  事务管理

## 16.1  事务的定义与特性 、事务管理

- **事务产生的原因：**保证数据库状态的一致性

- **事务（transaction）：**用户定义的一个数据库操作序列，这些工作要么全做要么全不做，是一个不可分割的工作单位。

    > 事务是数据库系统工作的一个不可分割的基本单位，既是保持数据库完整性约束或逻辑一致性的单位，又是数据库恢复及并发控制的基本单位。

- **SQL定义事务的语句：**

    ```sql
    BEGIN TRANSACTION	#事务开始语句
    COMMIT	  #事务提交语句，此时系统将事务所有对数据库的更新写入磁盘的物理数据库中，事务正常结束
    ROLLBACK  #事务非正常结束，此时系统将数据库的所有已完成的更新操作全部撤销，将事务回滚至事务开始处并重新开始执行
    ```

- **事务的三个阶段**：事务初态、事务执行、事务完成

    ![image-20220503192133312](https://s2.loli.net/2022/05/03/JaiEyIGlmXsYBVF.png)

- **事务的五个状态**：活动状态、失败状态、中止状态、局部提交状态、提交状态

    ![image-20220503192208460](https://s2.loli.net/2022/05/03/tp4Q7wbhBX3OHZe.png)

    

- ==事务的四个特性：ACID==  

    - **原子性（Atomicity）：**事务包含的一组更新操作是原子不可分的，即更新操作对于数据库而言，要么全做，要么全不做，不能部分地完成

    - **一致性（Consistency）：**指事务对数据库的每一个插入、删除、修改等更新操作，都必须遵守一定的完整性约束，系统一旦查出数据库的完整性受到破坏，则撤销该事务并清除该事务对数据库的任何影响。一个成功的事务把数据库从一个一致的状态转换到另一个一致的状态。

    - **隔离性（Isolation）：**指两个或多个事务可以同时运行而不互相影响，一个事务内部的操作及其使用的数据对并发的其他事务是隔离的、不可见的。

    - **持久性（Durability）：**指一个事务成功完成之后，其工作的结果就会永远保存在数据库中，是永久有效的，即使随后系统发生故障也能保持或恢复。

        > 破坏事务ACID特性的因素有：①多个事务的并行运行（并发控制）；②事务的运行过程中被强行停止（故障恢复）

## 16.2  事务并发导致的不一致性

- **并发控制：**保证事务的隔离性，从而保证数据库中数据的一致性

    当事务操作相同的数据且这些操作是冲突的，则会破坏事务的隔离性

- **事务并发导致的不一致性**

    包括丢失修改（lost update）、不可重复读（non-repeatable read）、读脏数据（dirty read）、幻像（phantom）

<img src="https://s2.loli.net/2022/05/02/NdQICqbpTUw6HBh.png" alt="image-20220502105703368" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/02/fezlxuHdRMWCi6q.png" alt="image-20220502105416862" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/02/VcifCBzhLoZUyKa.png" alt="image-20220502105434043" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/02/tcUNXbLw6fxdQ8m.png" alt="image-20220502105958563" style="zoom:67%;" />

> **不可重复读和幻象的区别：**不可重复读的重点是修改；同样的条件，第1次和第2次读取的值不一样。幻读的重点在于新增或者删除；同样的条件， 第1次和第2次读出来的记录数不一样。从控制角度来看，不可重复读只需要锁住满足条件的记录，幻读要锁住满足条件及其相近的记录。

- **出现不一致性的原因：**不同事务间冲突操作的无序执行，违反了隔离性原则

- **并发控制的方法**

    - **时间戳：**对事务规定一定的顺序

    - **加锁：（主要技术）**对于共享的资源DB进行控制



## 16.3  封锁及封锁协议

### 1、封锁的定义

- **概念：**事务T在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其**加锁**。加锁后事务T就对该数据对象有了一定的**控制**，在事务T释放它的锁之前，其他事务对该数据的操作受到**一定限制**。

### 2、基本的封锁类型

- **排它锁**（Exclusive Locks，简称X锁，也称写锁）
- **共享锁**（Share Locks，简称S锁，也称读锁）

<img src="https://s2.loli.net/2022/05/10/VBJL7PADZoWzqOy.png" alt="image-20220510101032697" style="zoom:50%;" />

![image-20220503200409098](https://s2.loli.net/2022/05/03/Pc2ldCGzSiN7U5q.png)

### 3、封锁协议包含的内容

- 什么操作需要申请何种锁？----排它锁、共享锁
- 何时加锁？----事务开始前、操作前
- 何时解锁？----操作结束后、事务结束前

### 4、封锁协议的分类   

- ==一级封锁协议==

    事务T在**修改**数据R之前，必须先对R加**X锁**，直到**事务结束才释放**。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）

    ==一级封锁协议不加S锁==

    <img src="https://s2.loli.net/2022/05/10/CvwZySBr9LxhmEX.png" alt="image-20220510103651090" style="zoom:67%;" />

- ==二级封锁协议==

    **在一级封锁协议的基础上**，加上事务T在**读取**数据R之前必须先对其加**S锁**，**读完后即可释放S锁**

    <img src="https://s2.loli.net/2022/05/10/cPYrELMTeukGNoH.png" alt="image-20220510103811156" style="zoom:67%;" />      

- ==三级封锁协议==

    **在一级封锁协议的基础上**，加上事务T在**读取**数据R之前必须先对其加**S锁**，**直到事务结束才释放**

    <img src="https://s2.loli.net/2022/05/10/7r8VxWoZYlmIzQc.png" alt="image-20220510103942568" style="zoom:67%;" />

- ==一二三级封锁协议的一致性保证==

    <img src="https://s2.loli.net/2022/05/02/N162xhCXYOvqiBE.png" alt="image-20220502113625070" style="zoom:80%;" />

### 5、并发调度的可串行性

- **调度的正确性**：

    - 能将数据库置于一致状态的调度一定是正确的调度

    - 将所有事务串行起来的调度策略一定是正确的调度（因为每个事务都会保证一致性状态，故事务串行一定会保证一致性）

    - 与串行调度等价的调度是正确的调度

- **并发事务的正确性准则：**多个事务的并发执行是正确的，当且仅当其结果与**某一次序串行地执行**它们时的结果相同，我们称这种调度策略为**可串行化的调度**。

    <img src="https://s2.loli.net/2022/05/02/48u6gehbtD5PVnT.png" alt="image-20220502114421860" style="zoom:67%;" />

    <img src="https://s2.loli.net/2022/05/02/rGFxKEV5iQNSPs4.png" alt="image-20220502114251187" style="zoom:67%;" />



## 16.4 两段锁协议

- **概念：**所有事务必须分两个阶段（获得阶段和释放阶段，亦即扩展阶段和收缩阶段）对数据项加锁和解锁。

    - **获得封锁：**在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁； 

    - **释放封锁：**==在释放一个封锁之后，事务不再申请和获得任何其他封锁。==

        例子：

        <img src="https://s2.loli.net/2022/05/10/ZMBYK4H9SIQCOit.png" alt="image-20220510105713156" style="zoom:67%;" />

> - ==两段锁协议是可串行化的充分条件，而不是必要条件==
>
> - 一次封锁法遵守两段锁协议，但两段锁协议不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生`死锁`。
>
>     例子：
>
>     ![image-20220510105806932](https://s2.loli.net/2022/05/10/gYxvJR9oVeKG5US.png)
>
> - 三级封锁是两段锁的一种，因为三级封锁都是事务结束再释放锁，事务结束后显然事务不会再申请和获得任何其他封锁。

- **活锁和死锁**

    - **活锁（饥饿）**：某一个事务无限等待。解决方法：先来先服务

    - **死锁：**两个或多个事务都已封锁了一些数据对象，然后又都请求对已被其他事务封锁的数据对象加锁，从而出现死等待。

    - **解决死锁**：

        - **预防：**破坏死锁产生的四个必要条件（互斥、请求和保持、不可剥夺、循环等待）。几个方法：静态申请法，一次性申请所有资源，资源的利用率不高；延迟进程的执行，能够获得所有资源时才允许执行，并发度不好；有序资源分配法，给资源编号

        - **避免**：类似os中的银行家算法，在资源分配之前进行检查，防止死锁的发生

        - **诊断与解除**

            - **死锁的诊断：**

                - **超时法**：超过规定的时间就认为发生死锁。

                    > 不足：可能误判死锁，也可能不能及时发现死锁

                - **等待图法：**以`事务`为结点，边表示事务等待的情况，若T1等待T2，则 T1→T2。系统周期性地检测事务等待图，若图中存在回路，则出现死锁。

            - **死锁的解除**：选择一个处理死锁代价最小的事务，撤销。对撤销的事务所执行的数据修改操作必须加以恢复。



## 16.5  封锁的粒度

- **封锁的粒度**：指封锁对象的大小，封锁的粒度包括整个数据库、关系、元组、索引

<img src="https://s2.loli.net/2022/05/02/dKOgEQJji3fncZ1.png" alt="image-20220502143147735" style="zoom:67%;" />

- **封锁粒度的选择**：选择封锁粒度时应该同时考虑并发度和开销两个因素。==封锁粒度越大，并发度越小，系统开销越小。==

- **多粒度封锁**

    - **概念：**在一个系统中同时支持多种封锁粒度供不同的事务选择。

        > `多粒度封锁协议`允许多粒度树中的每个结点被独立地加锁。对每个结点的加锁意味着这个结点的所有后裔结点也被加以同样类型的锁。

    - **显式封锁：**应事务的要求直接加到数据对象上的封锁

    - **隐式封锁：**该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁

    - **判断能否对一个数据对象加锁：**

        - 检查**该数据对象**有无显式封锁与之冲突； 

        - 检查其**所有上级结点**，看本事务的显式封锁是否与该数据对象上的隐式封锁冲突； 

        - 检查其**所有下级结点**，看上面的显式封锁是否与本事务的隐式封锁冲突。

            > 不需要检查下级结点的隐式封锁，因为有隐式封锁肯定可以向上找到显式封锁

- ==意向锁==

    - **概念：**如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁；对任一结点加锁时，必须先对它的（所有）上层结点加意向锁。

    - **意向共享锁（简称IS锁）**：如果对数据对象加IS锁，表示它的后裔结点拟加S锁 

    - **意向排它锁（简称IX锁）**：如果对数据对象加IX锁，表示它的后裔结点拟加X锁 

    - **共享意向排它锁（简称SIX锁）**：如果对数据对象加SIX锁，表示先加S锁，再加IX

        eg.  对某个表加SIX锁，表示该事务要读整个表（所以要对该表加S锁），同时会更新个别元组（所以要对该表加IX锁）

        <img src="https://s2.loli.net/2022/05/10/iOJKRkQElyd7TzM.png" alt="image-20220510113003330" style="zoom:67%;" />

        > 加锁是从上往下的

![image-20220503201553550](https://s2.loli.net/2022/05/03/mzDWoftL9S6kxRs.png)

> IS锁和IX锁是相容的，因为最终会转化到下层结点，如果最终S锁和X锁加到了同一个对象上，那么在这个对象上的这两个锁是不相容的；如果没有加到同一个对象上，那么IS锁和IX锁就不会出现问题。

## 16.6  隔离级别（四种）

- **未提交读（读未提交， read uncommitted）**：事务隔离的最低级别，一个事务可以读到另外一个事务未提交的数据，不允许丢失修改，接受读脏数据和不可重复读现象。

- **提交读（读已提交， read committed）**：SQL Server 默认级别。若事务还没提交，其它事务不能读取该事务正在修改的数据。不允许丢失修改和读脏数据，接受不可重复读现象。

- **可重复读（repeatable read）**：事务多次读取统一数据对象的结果一致。不允许丢失修改、读脏数据和读不一致，接受幻影读现象。

- **可串行读（serializable）**：事务隔离的最高级别，保证可串行化，不允许丢失修改、读脏数据、读不一致以及幻影读现象的发生。

- 隔离级别允许不同类型的行为：

    | **隔离级别** | 丢失修改 | **脏读** | **不可重复读取** | **幻像** |
    | :----------: | :------: | :------: | :--------------: | :------: |
    | **未提交读** |    否    |    是    |        是        |    是    |
    |  **提交读**  |    否    |    否    |        是        |    是    |
    | **可重复读** |    否    |    否    |        否        |    是    |
    | **可串行读** |    否    |    否    |        否        |    否    |

- **设置隔离级别的语法**

    ```sql
    set transaction isolation level
    {
    	read committed | 
    	read uncommitted |
    	repeatable read |
    	serializable read
    }
    ```



## 16.7 数据库恢复

- **概念**：把数据库从**错误状态**恢复到某一个已知的**正确状态**（亦称为一致状态或完整状态）的功能。

- **目标：**在故障发生时，确保事务的原子性和持久性

- **特点：**因为DB与内存用户工作区之间的数据交换是通过缓冲区进行的，而这个交换一般是以缓冲区是否满来触发的。因此，有可能提交事务的数据仍在缓冲区而没有写到DB中，而未提交事务的数据却写到了DB中。所以，故障恢复时，可能既要REDO已经提交了的事务，又要UNDO未提交的事务，以保证事务的原子性

- **技术**

    DBMS提供备份机制、日志机制、检查点机制来协助数据库故障恢复;

    ==基本原理：数据冗余。==

- ==数据转储：==DBA定期地将整个数据库复制到磁带或另一个磁盘上保存起来的过程。这些备用的数据文本称为后备副本或后援副本。

    **数据转储的分类：**

    - 按照转储时的状态可以分为**静态转储和动态转储**。静态转储是指在系统中无运行事务时进行的转储操作。动态转储是指转储期间允许对数据库进行存取或者修改，但此时需要把转储期间各事务对数据库的修改记录在日志文件中，从而将来可以恢复
    - 按方式不同可以分为**海量转储和增量转储**。海量转储是指每次转储全部数据库。增量转储是指每次只转储上一次转储后更新的数据库。

    ![image-20220503193938217](https://s2.loli.net/2022/05/03/oEV9AIyQY7LlmZD.png)

- ==登记日志文件==：记录事务对数据库的`更新`操作

    **日志文件的格式：**以记录为单位的日志文件和以数据块为单位的日志文件。

    - 以记录为单位的日志文件：一个日志记录包括每个事务的开始标志（BEGIN TRANSACTION）、结束标志（COMMIT 或 ROLLBACK）、每个更新操作

    - 以数据块为单位的日志文件：包含事务标识和被更新的数据块

    <img src="https://s2.loli.net/2022/05/02/aeJHjWo2fNvlnSM.png" alt="image-20220502151104445" style="zoom:67%;" />

    **登记日志文件的原则：**

    - 登记的次序按并发事务执行的时间次序
    - 必须先写日志文件，后写数据库==（日志先写原则）==

- **系统故障的恢复实现策略**

    - **系统故障导致的数据库不一致**
        （1）未完成的事务对DB产生影响
        （2）已完成的事务在缓冲区的内容未写入DB

    - **恢复功能**
        （1）UNDO未完成的事务
        （2）REDO已完成的事务

    - **恢复步骤**
        （1）正向扫描日志文件，建立UNDO和REDO队列；（不需要redo日志中所有已完成的事务）
        （2）反向扫描日志文件，对每个UNDO事务的更新执行逆操作；
        （3）正向扫描日志文件，对每个REDO事务的更新重新执行。

- ==检查点技术：==

    当事务正常运行时，数据库系统按一定的时间间隔设检查点。一旦系统需要恢复数据库状态，就可以根据最新的检查点的信息，从检查点开始执行，而不必从头开始执行那些被中断的事务。

    系统在检查点做的动作主要如下：

    - 暂时中止现有事务的执行
    - 在日志中写入检查点记录，并把日志强制写入磁盘
    - 把主存中被修改的数据缓冲区强制写入磁盘
    - 重新开始执行事务

    例子：

    ![image-20220503195636843](https://s2.loli.net/2022/05/03/hbQXdSE3r46sk52.png)

    ![image-20220503195650256](https://s2.loli.net/2022/05/03/f4wAEDbW2xU6ZtX.png)

    
