---
title: 五、死锁
tags:
  - 操作系统
category:
  - 操作系统
abbrlink: 45543
date: 2022-06-27 23:07:21
---

# 5、死锁

## 基本概念

### （1）死锁产生的原因

- 竞争资源：多个进程竞争资源，而资源又不能同时满足其需求（如下图1）
- 进程推进顺序不当：进程申请资源和释放资源的顺序不当（如下图2）

图1：竞争资源引起的死锁

<img src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205152043664.png" alt="image-20220515204316626" style="zoom:50%;" />

这类图中的`Pi`表示进程，`Ri`表示资源，由`Ri`指向`Pi`的箭头表示`Ri`已经被分配给了`Pi`，而由`Pi`指向`Ri`的箭头表示`Pi`请求`Ri`

图2：进程推进顺序不当引起的死锁

<img src="https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205152048260.png" alt="image-20220515204834225" style="zoom:50%;" />

如上图，当进程的推进路线进入了死锁不可避免区，就会产生死锁

### （2）死锁产生的4个必要条件

1. 互斥条件：在一段时间内某资源仅为一个进程所占有
2. 请求和保持条件（占有并等待）：又称为部分分配条件。当进程因请求资源被阻塞时，已分配资源保持不放
3. 不剥夺条件（非抢占）：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走
4. 循环等待条件：死锁发生时存在一个进程资源的循环

### （3）资源分配图

用来表示系统资源的分配关系，由一组结点N和一组边E所构成，其中：

- N包括进程节点P和资源节点R，进程节点用圆圈表示，资源节点用方框表示，每个方框对应着一种资源，方框中的一个点表示一种资源里的一个资源
- E包括资源请求边（由P节点指向R节点）和资源分配边（由R节点指向P节点）

**✳使用资源分配图来初步分析死锁：**

- 如果分配图没有环：无死锁
- 如果分配图包含环：如果每个R节点中都只有一个资源，则一定会死锁；如果有多个资源，则只是存在死锁的可能，并不一定会死锁

### （4）死锁的解除

1. 系统重启法
2. 进程终止（进程撤销、逐步撤销）
3. 资源抢占

## 处理死锁的基本方法

1. 忽略死锁：被大多数系统采用，因为死锁出现概率低，忽略死锁的代价小
2. 预防死锁：设置某些限制条件，通过破坏死锁产生的四个必要条件之一来预防死锁
3. 避免死锁：在资源的动态分配过程之中，用某种方法防止系统进入不安全状态
4. 检测死锁及解除：系统定期检测是否出现死锁，如果出现则解除之

### （1）预防死锁

可以通过破坏产生死锁的四个必要条件之中的一个或几个条件来防止死锁的发生

#### ①破坏互斥条件

- 主要思路：使资源可以同时访问，而非互斥使用
- 局限性：互斥对一些资源是固有属性不能改变

#### ②破坏请求和保持条件

- 主要思路：当每个进程申请一个资源时，不能占有其他资源
- *方法1：要求进程一次申请其所需的全部资源，如果有足够的资源则分配给进程，否则不分配，进程等待（静态资源分配法）*
- *方法2：允许进程仅在没有资源时才可以申请资源，一个进程申请资源并使用，但是在申请更多资源时应释放已经分配的所有资源*
- 优点：简单并且易于实现
- 缺点：资源利用率低，进程延迟运行，可能发生饥饿

#### ③破坏不可剥夺条件

- 主要思路：对一个已经获得某些资源的进程，若新的资源请求的不到满足，则其已经占有的资源都可以被抢占，即这些资源都被隐式释放了（常用于状态已于恢复和保存的资源）
- 局限性：这种释放有可能造成已有工作的失效，重新申请和释放会带来新的系统开销

#### ④破坏循环等待条件

采取层次分配策略，将资源分为多个层次，并且应用如下规则：

- 当进程得到某一层的一个资源后，只能申请较高层次的资源
- 当进程释放某层的一个资源时，必须先释放占有的较高层次的资源  
- 当进程得到某一层的一个资源后，它想申请该层的另一个资源时，必须先释放该层中的已占资源  

采取层次分配的变种：按序分配策略

首先将系统的所有资源排一个顺序，如系统若共有n个进程，有m个资源，用$r_i$表示第$i$个资源，则这$m$个资源是$r_1,r_2,......,r_m$，并应用如下规则：

- 进程不得在占用资源$r_i$后再申请$r_j(j<i)$
- 即只能申请编号之后的资源，不许申请编号之前的资源

证明：

![image-20220515214959740](https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205152149789.png)

### （2）避免死锁

允许系统中存在前3个必要条件，通过合适的资源分配算法，防止系统进入不安全状态 ，确保不会出现第四个必要条件，从而避免死锁。  

**【定义】安全状态**：如果系统能按照某种顺序来为每个进程分配其所需的资源直到最大需求，使每个进程都可以顺利完成，则称此时的系统状态为安全状态，称序列为安全序列

**【定义】不安全状态**：某一时刻系统中不存在安全序列

#### ①资源分配图算法

资源分配图的简化：

- 在资源分配图中找到一个既不阻塞又非孤立的进程节点Pi（不阻塞：该节点并未处于等待中，非孤立：有边项链）
- 将Pi运行完成，删掉其所有的请求边和分配边

不断进行上述两个过程，如果能消去图中所有的边，则该图为可完全简化的，否则是不可完全简化

> 死锁定理： S为死锁状态的条件，当且仅当S状态的资源分配图是不可完全简化的  

#### ②银行家算法

----------

***首先进行初始化***

假设系统中有n个进程，所需求的资源有m类，则定义以下的数据结构：

- **最大需求矩阵Max**（n行m列）：定义了系统中每个进程对m类资源的最大需求数目
- **分配矩阵Allocation**（n行m列）：定义了系统中每个进程对m类资源的已经分配的情况
- **需求矩阵Need**（n行m列）：定义了系统中的每一个进程还需要的各类资源数目
- **可用资源向量Available**（m列）：定义了系统中的每类资源所剩余的数目

资源分配表由以上的数据结构构成，如下图所示：

![image-20220516232351253](https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205162323289.png)

-----------

***其次进行预分配***

假设进程Pi对场上的资源做出请求，该请求用请求向量**Requesti**（m列）来表示，对应所分别请求的m类资源的数目，首先进行以下两步检查：

1. 如果$Request_i\le Need_i$，则说明该进程请求的不比自己需要的多，可以继续向下，否则报错
2. 如果$Request_i\le Available$，则说明该进程的请求可以被剩余资源所满足，可以继续向下，否则报错

经过以上两步检查之后，尝试将资源做出分配满足请求，更新资源分配表，方法如下：
$$
Available=Available-Request_i\\
Allocation_i=Allocation_i+Request_i\\
Need_i=Need_i-Request_i
$$

---------------

***最后进行安全性检查***

新定义两个数据结构

- **空闲资源向量Work**（m列）：是一个随着安全性检查改变的向量，指的是安全性检查的过程中，系统的每类资源剩余的数目，其初始定义为Available，之后随着进程的释放会发生改变
- **完成向量Finish**（n行）：表示某个进程是否可以完成，初始定义为false，随着进程的完成会发生改变

安全性检查的过程为：

- 在几个进程之中找到一个未完成的进程$i$，$Need_i$向量小于Work向量，执行之，将其填入安全性检查表，而$Work+Allocation_i$作为新的Work，置$Finish_i=true$
- 重复以上操作，直至将安全性检查表填满，或者遇到无法分配的状况

安全性检查表示意图如下：

![image-20220516232237019](https://yzxtuchuang.oss-cn-beijing.aliyuncs.com/img/202205162322116.png)

> 可以证明：只要存在一个序列不是安全序列，那么任意路径都不是安全序列。只要有一个序列是安全序列，那么在算法进行过程中出现的任何分叉点所构成的其它序列就都是安全序列  
